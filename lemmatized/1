   писать   простой   рейтрейсер   использовать   vulkan   raytracing   график   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   faq   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиграфика   писать   простой   рейтрейсер   использовать   vulkan   raytracing   автор   0r   nge   все   привет   сегодня   я   рассказывать   вы   как   получать   результат   изображать   на   заглавный   картинка   к   этот   статья   использовать   vulkan   raytracing   часть   0   приветствие   часть   1   кролик   и   чайник   часть   2   камера   мотор   часть   2   сталь   и   мрамор   часть   3   да   быть   свет   часть   4   зеркало   часть   5   зацикливаться   часть   6   стекло   и   финал   часть   0   приветствие   в   прошлый   раз   мы   с   вы   рассматривать   что   же   из   себя   представлять   vulkan   ray   tracing   и   как   с   он   работать   итог   тот   статья   становиться   простой   приложение   создавать   то   не   менее   сцена   пайплайн   шейдер   и   выводить   на   экран   результат   трассировка   луч   по   этот   сцена   и   хоть   наш   треугольник   и   получаться   на   порядок   реалистичный   растеризованный   все   же   хотеться   бы   увидеть   рейтрейсинг   во   весь   его   краса   ведь   не   зря   мы   потратить   деньги   на   rtx   видеокарта   именно   это   и   быть   посвящать   данный   статья   хотеться   бы   сразу   отмечать   цель   статья   показывать   как   использовать   vulkan   для   построение   полноценный   рейтрейсер   показывать   основной   архитектурный   момент   и   давать   несколько   совет   по   написание   эффективный   шейдер   для   рейтрейсинг   часть   1   кролик   и   чайник   первый   дело   мы   понадобиться   сам   сцена   я   взять   на   себя   смелость   подготовить   переосмыслять   версия   классический   икона   рейтрейсинг   сцена   тернер   уиттед   зеркальный   и   стеклянный   шар   над   кусок   линолеум   в   наш   случай   сцена   называться   хромировать   чайник   и   стеклянный   кролик   на   мраморный   пол   модель   кролик   stanford   bunny   быть   позаимствовать   отсюда   https   casual   effects   com   g3d   data10   index   html   mesh3   модель   чайник   использоваться   тот   что   встраивать   в   3ds   max   модель   пол   быть   мастерски   изготавливать   автор   статья   собственноручно   текстура   взять   с   сайт   https   texturehaven   com   для   загрузка   сцена   использоваться   библиотека   tinyobjloader   для   загрузка   текстура   использоваться   все   любимая   stb _ image   также   для   более   удобный   работа   со   сцена   и   ее   ресурс   быть   добавлять   вспомогательный   структура   rtaccelerationstructure   rtmesh   rtmaterial   rtscene   код   по   больший   часть   оставаться   без   изменение   только   вместо   один   bottom   level   acceleration   structure   blas   теперь   у   мы   они   несколько   а   соответственно   и   несколько   vkgeometrynv   и   vkgeometryinstance   важно   также   отмечать   что   поле   instanceid   каждый   инстанс   мы   теперь   присваивать   порядковый   номер   объект   в   сцена   это   помогать   мы   в   будущее   обращаться   к   его   атрибут   создавать   для   каждый   объект   сцена   свой   blas   и   instance   мы   строить   top   level   acceleration   sctructure   tlas   наш   сцена   готовый   часть   2   камера   мотор   для   наш   треугольник   мы   хватать   ортографический   проекция   где   все   луч   идти   параллельно   чтобы   видеть   наш   новый   сцена   во   весь   ее   краса   мы   понадобиться   перспективный   камера   мы   не   быть   заниматься   моделирование   реальный   линза   а   останавливаться   на   простой   камера   обскура   pinhole   camera   в   такой   модель   камера   наш   луч   выходить   из   один   точка   позиция   наблюдатель   и   расходиться   образовывать   пирамида   формирование   луч   для   каждый   пиксел   наш   экран   в   такой   случай   являться   очень   простой   отправной   точка   это   всегда   позиция   наблюдатель   а   конечный   точка   проекция   на   дальний   плоскость   отсечение   основание   пирамида   я   добавлять   в   состав   фреймворок   класс   camera   реализовать   весь   необходимый   мы   метод   и   позволять   управлять   камера   с   помощь   пользовательский   ввод   для   передача   параметр   камера   в   шейдер   использоваться   uniform   buffer   object   ubo   следующий   содержание   struct   uniformparams   vec4   campos   vec4   camdir   vec4   camup   vec4   camside   vec4   camnearfarfov   в   шейдер   же   для   построение   луч   быть   добавлять   функция   calcraydir   который   для   заданный   пиксел   экран   находить   необходимый   направление   луч   использовать   ориентация   камера   и   угол   обзор   теперь   же   если   запускать   наш   приложение   то   мы   увидеть   следующий   картина   теперь   вместо   один   цветной   треугольник   у   мы   на   экран   несколько   сотня   тысяча   цветной   треугольник   хвала   рейтрейсинг   часть   2   сталь   и   мрамор   разноцветный   треугольник   это   конечно   же   хорошо   но   как   насчет   текстура   к   счастие   текстурирование   треугольник   мало   чем   отличаться   от   таковой   в   растеризация   мы   все   так   же   нужный   текстурный   координата   каждый   вершина   треугольник   их   интерполировать   значение   для   интересовать   мы   пиксел   а   также   сам   текстура   и   сэмплер   sampler   для   интерполяция   текстурный   координата   а   также   любой   вершинный   атрибут   мы   и   пригождаться   тот   самый   барицентрический   координата   который   мы   и   выводить   до   сей   пора   но   где   же   мы   взять   вершинный   атрибут   для   растеризация   мы   складывать   вершинный   атрибут   в   вершинный   буфер   и   далее   конвейер   все   делать   за   мы   но   в   случай   рейтрейсинг   нужно   заниматься   это   сам   хороший   новость   в   то   что   это   совсем   не   сложный   для   передача   атрибут   в   шейдер   мы   пригождаться   shader   storage   buffer   object   ssbo   или   structuredbuffer   в   термин   directx   складывать   вершинный   атрибут   в   ssbo   и   передавать   в   шейдер   вроде   ничто   сложный   но   как   узнавать   какой   именно   вершина   мы   нужный   для   начало   мы   нужно   узнавать   в   какой   именно   треугольник   мы   попадать   и   помогать   мы   в   это   gl _ primitiveid   который   содержать   порядковый   номер   треугольник   в   данный   объект   уже   хорошо   но   часто   все   наш   геометрия   индексировать   чтобы   избегать   дублирование   данные   а   значит   мы   понадобиться   также   индекс   который   мы   передавать   через   ssbo   итак   у   мы   быть   номер   треугольник   по   который   мы   мочь   прочитывать   индекс   с   помощь   который   мы   читать   вершинный   атрибут   проинтерполировать   который   мы   наконец   мочь   обращаться   к   текстура   но   как   мы   узнавать   к   какой   именно   для   это   мы   пригождаться   еще   один   ssbo   буфер   хранить   в   себя   индекс   текстура   для   каждый   треугольник   объект   для   чтение   из   он   мы   пригождаться   знакомый   уже   мы   gl _ primitiveid   итак   давать   записывать   какой   в   итог   буфер   мы   понадобиться   materialsids   ssbo   индекс   материал   для   каждый   треугольник   facesbuffer   ssbo   индекс   вершина   attribsbuffer   ssbo   вершинный   атрибут   texture   sampler2d   текстура   но   ведь   у   мы   несколько   объект   в   сцена   как   быть   с   это   к   счастие   для   это   существовать   расширение   vk _ ext _ descriptor _ indexing   добавлять   много   вкусности   и   послабление   для   дескриптор   но   самый   главное   для   мы   возможность   при   создание   разметка   набор   дескриптор   descriptor   set   layout   указывать   что   этот   самый   дескриптор   неопределенный   количество   такой   образ   мы   мочь   в   рантайм   решать   размерность   массив   передавать   ресурс   что   просто   идеально   для   наш   ситуация   разбирать   подробно   я   этот   расширение   не   быть   это   выходить   за   рамка   данный   статья   так   что   для   дальнейший   ознакомление   мочь   проходить   по   этот   ссылочка   https   www   khronos   org   registry   vulkan   specs   1   1   extensions   html   ptor _ indexing   помнить   как   мы   при   создание   инстанс   в   качество   id   указывать   порядковый   номер   объект   так   вот   он   то   мы   теперь   и   пригождаться   чтобы   брать   из   массив   нужный   буфер   для   это   мы   понадобиться   встроенный   переменная   gl _ instancecustomindexnv   который   как   раз   и   содержать   тот   самый   значение   вот   так   быть   выглядеть   наш   код   текстурирование   const   vec3   barycentrics   vec3   1   0f   hitattribs   x   hitattribs   y   hitattribs   x   hitattribs   y   const   uint   matid   matidsarray   nonuniformext   gl _ instancecustomindexnv   matids   gl _ primitiveid   const   uvec4   face   facesarray   nonuniformext   gl _ instancecustomindexnv   faces   gl _ primitiveid   vertexattribute   v0   attribsarray   nonuniformext   gl _ instancecustomindexnv   vertexattribs   int   face   x   vertexattribute   v1   attribsarray   nonuniformext   gl _ instancecustomindexnv   vertexattribs   int   face   y   vertexattribute   v2   attribsarray   nonuniformext   gl _ instancecustomindexnv   vertexattribs   int   face   z   const   vec2   uv   barylerp   v0   uv   xy   v1   uv   xy   v2   uv   xy   barycentrics   const   vec3   texel   texturelod   texturesarray   nonuniformext   matid   uv   0   0f   rgb   как   видеть   все   оказываться   совсем   не   сложный   и   очень   даже   гибко   запускать   наш   приложение   и   увидеть   следующий   картинка   уже   намного   хорошо   но   что   то   не   хватать   ах   да   освещение   часть   3   да   быть   свет   давать   добавлять   простой   освещение   классика   компьютерный   график   диффузный   модель   освещение   ламберт   согласно   этот   модель   освещение   рассеиваться   равномерно   по   полусфера   а   освещенность   диктоваться   только   плотность   световой   поток   который   обратно   пропорциональный   угол   поток   свет   к   поверхность   или   просто   говорить   все   любимый   мистер   n   dot   l   и   тут   начинать   проявляться   достоинство   рейтрейсинг   перед   растеризация   тень   точка   находиться   в   тень   если   она   не   видеть   напрямую   источник   свет   и   это   очень   легко   сделать   с   помощь   рейтрейсинг   достаточно   лишь   пускать   луч   в   направление   источник   свет   и   посмотреть   не   попадаться   ли   мы   что   по   путь   если   находить   пересечение   значит   источник   свет   закрывать   и   мы   в   тень   если   же   пересечение   не   быть   значит   мы   мочь   считать   освещение   для   это   при   нахождение   первичный   пересечение   мы   нужно   построить   новый   луч   и   вызывать   tracenv   еще   раз   для   проверка   видимость   источник   свет   делать   это   можно   и   в   hit   шейдер   но   рекомендоваться   весь   вызов   tracenv   производить   в   raygen   шейдер   так   как   это   позволять   планировщик   scheduler   работать   с   максимальный   эффективность   еще   один   оптимизация   использовать   raypayload   как   можно   меньший   размер   а   также   специализированный   hit   и   miss   шейдер   для   теневой   луч   мы   в   качество   raypayload   понадобиться   всего   один   значение   быть   ли   пересечение   или   нет   соответственно   в   hit   шейдер   мы   быть   отмечать   что   пересечение   быть   и   в   miss   шейдер   что   не   быть   давать   дополнять   наш   код   raygen   шейдер   const   vec3   hitcolor   primaryray   coloranddist   rgb   const   float   hitdistance   primaryray   coloranddist   w   const   vec3   hitnormal   primaryray   normal   xyz   float   lighting   1   0f   if   we   hit   something   if   hitdistance   0   0f   const   vec3   hitpos   origin   direction   hitdistance   const   vec3   tolight   normalize   params   sunposandambient   xyz   const   vec3   shadowrayorigin   hitpos   hitnormal   0   01f   const   uint   shadowrayflags   gl _ rayflagsopaquenv   gl _ rayflagsterminateonfirsthitnv   const   uint   shadowrecordoffset   1   const   uint   shadowmissindex   1   tracenv   scene   rayflags   cullmask   shadowrecordoffset   stbrecordstride   shadowmissindex   shadowrayorigin   0   0f   tolight   tmax   sws _ loc _ shadow _ ray   if   shadowray   distance   0   0f   lighting   params   sunposandambient   w   else   lighting   max   params   sunposandambient   w   dot   hitnormal   tolight   замечать   что   для   теневой   луч   мы   указывать   флаг   gl _ rayflagsterminateonfirsthitnv   такой   образ   мы   останавливать   трассировка   при   первый   же   пересечение   без   поиск   близкий   ведь   мы   важный   сам   факт   наличие   пересечение   такой   образ   мы   проверять   быть   ли   первичный   пересечение   или   мы   ударяться   в   небо   если   пересечение   быть   то   восстанавливать   координата   точка   пересечение   ведь   мы   знать   расстояние   до   точка   пересечение   от   начальный   точка   луч   получать   направление   на   источник   свет   и   вызывать   tracenv   указывать   в   качество   шейдер   наш   специализированный   теневой   шейдер   а   также   расположение   payload   для   теневой   луч   замечать   что   для   задание   отправной   точка   наш   луч   мы   немного   смещать   она   вдоль   нормаль   это   сделать   для   избежание   нежелательный   самозатенение   также   для   это   можно   использовать   значение   tmin   отличный   от   ноль   после   это   мы   проверять   быть   ли   пересечение   и   если   не   быть   то   считать   освещение   по   модель   ламберт   если   же   пересечение   быть   то   в   качество   освещение   взять   константный   значение   окружающий   свет   ambient   light   не   смотря   на   простота   этот   модель   благодаря   наличие   тень   мы   получать   довольно   симпатичный   картинка   часть   4   зеркало   как   вы   уже   мочь   замечать   рейтрейсинг   это   простой   но   в   тот   же   время   очень   мощный   инструмент   с   помощь   простой   механизм   запуск   луч   и   проверка   результат   пересечение   можно   реализовывать   множество   фич   реализовать   который   с   помощь   растеризация   или   сложный   или   и   вовсе   невозможный   давать   рассматривать   например   отражение   современный   растерный   рендеры   научаться   многий   трюк   для   построение   приемлемый   отражение   но   весь   они   далекий   от   реалистичность   и   делать   довольно   много   допущение   с   помощь   рейтрейсинг   мы   мочь   получать   отражение   очень   легко   достаточно   простой   отражать   приходить   луч   и   отслеживать   его   пересечение   давать   попробовать   для   начало   определяться   что   отражать   свойство   у   мы   быть   обладать   чайник   ведь   он   легко   мочь   быть   хромированный   для   это   мы   в   hit   шейдер   быть   записывать   в   raypayload   флаг   означать   попадать   ли   мы   в   чайник   или   нет   так   как   я   создавать   сцена   я   знать   что   порядковый   номер   чайник   2   теперь   все   что   мы   нужно   сделать   в   raygen   шейдер   это   проверять   попадать   ли   мы   в   чайник   и   вместо   теневой   луч   выпускать   еще   один   первичный   луч   отражать   направление   текущий   луч   и   использовать   цвет   в   точка   пересечение   в   качество   отражение   const   float   isteapot   primaryray   normal   w   if   teapot   let   s   reflect   if   isteapot   0   0f   const   vec3   hitpos   origin   direction   hitdistance   hitnormal   0   01f   const   vec3   reflecteddir   reflect   direction   hitnormal   tracenv   scene   rayflags   cullmask   primaryrecordoffset   stbrecordstride   primarymissindex   hitpos   0   0f   reflecteddir   tmax   sws _ loc _ primary _ ray   мы   использовать   тот   же   raypayload   и   тот   же   шейдер   что   и   для   первичный   луч   ведь   мы   по   суть   просто   продолжать   трассировка   первичный   луч   теперь   мы   мочь   наслаждаться   вид   хромированный   чайник   как   вы   наверное   мочь   замечать   отражение   на   наш   чайник   какой   то   странный   на   отражение   пол   нет   тень   а   также   боковой   и   верхний   ручка   чайник   отражаться   текстурированный   это   происходить   потому   что   после   нахождение   пересечение   отраженный   луч   мы   просто   забирать   получаться   цвет   и   на   этот   останавливаться   во   первый   мы   как   минимум   нужно   рассчитать   освещение   в   точка   пересечение   а   во   второй   если   мы   снова   попадать   в   зеркальный   поверхность   то   нужно   отражать   луч   и   продолжать   трассировка   попробовать   поставлять   два   зеркало   напротив   друг   друг   и   вы   увидеть   бесконечный   отражение   мы   себя   конечно   же   бесконечный   отражение   позволять   не   мочь   но   как   минимум   несколько   уровень   отражение   вполне   мочь   осиливать   часть   5   зацикливаться   весь   мы   знать   что   рекурсия   это   плохо   но   рекурсия   на   gpu   еще   худо   и   хоть   vulkan   raytracing   и   предоставлять   мы   возможность   для   организация   рекурсивный   трассировка   производительность   ради   стоить   она   по   возможность   избегать   в   наш   случай   вполне   можно   обходиться   и   обычный   цикл   на   каждый   итерация   мы   трассировать   луч   проверять   куда   попадать   и   решать   если   попадать   в   небо   прерывать   цикл   если   попадать   в   чайник   строить   отраженный   луч   и   продолжать   если   попадать   оставаться   часть   сцена   считать   освещение   и   прерывать   цикл   императивный   путь   я   подбирать   максимальный   количество   итерация   равный   10   это   позволять   иметь   достаточный   количество   переотражение   чтобы   создавать   правдоподобный   картинка   при   это   сохранять   хороший   производительность   изменять   наш   шейдер   в   соответствие   с   излагать   алгоритм   vec3   finalcolor   vec3   0   0f   for   int   i   0   i   sws _ max _ recursion   i   tracenv   scene   rayflags   cullmask   primaryrecordoffset   stbrecordstride   primarymissindex   origin   tmin   direction   tmax   sws _ loc _ primary _ ray   const   vec3   hitcolor   primaryray   coloranddist   rgb   const   float   hitdistance   primaryray   coloranddist   w   if   hit   background   quit   if   hitdistance   0   0f   finalcolor   hitcolor   break   else   const   vec3   hitnormal   primaryray   normal   xyz   const   float   isteapot   primaryray   normal   w   const   vec3   hitpos   origin   direction   hitdistance   if   isteapot   0   0f   our   teapot   is   mirror   so   continue   origin   hitpos   hitnormal   0   01f   direction   reflect   direction   hitnormal   else   we   hit   diffuse   primitive   simple   lambertian   const   vec3   tolight   normalize   params   sunposandambient   xyz   const   vec3   shadowrayorigin   hitpos   hitnormal   0   01f   tracenv   scene   rayflags   cullmask   shadowrecordoffset   stbrecordstride   shadowmissindex   shadowrayorigin   0   0f   tolight   tmax   sws _ loc _ shadow _ ray   const   float   lighting   shadowray   distance   0   0f   params   sunposandambient   w   max   params   sunposandambient   w   dot   hitnormal   tolight   finalcolor   hitcolor   lighting   break   результат   правдоподобный   отражение   часть   6   стекло   и   финал   наш   рейтрейсер   начинать   обретать   черта   взрослый   трассировщик   теперь   иметь   на   рука   универсальный   цикл   трассировка   мы   мочь   расширять   функционал   добавлять   новый   материал   и   более   реалистичный   модель   освещение   довольно   небольшой   изменение   можно   получать   полноценный   трассировщик   путь   path   tracer   для   расчет   реалистичный   изображение   давать   напоследок   добавлять   еще   один   фич   рейтрейсинг   преломление   вещь   практически   нереализуемый   стандартный   растеризация   но   благодаря   наш   цикл   трассировка   мы   мочь   легко   получать   реалистичный   многоуровневый   преломление   давать   сделать   наш   кролик   стеклянный   для   этот   вводить   константа   порядковый   номер   объект   наш   сцена   и   в   шейдер   пересечение   быть   записывать   в   raypayload   номер   объект   с   который   пересекаться   const   float   objid   float   gl _ instancecustomindexnv   primaryray   normalandobjid   vec4   normal   objid   подбирать   индекс   преломление   для   наш   кролик   я   выбирать   обычный   стекло   с   индекс   преломление   равный   1   52   так   как   функция   refract   принимать   соотношение   индекс   преломление   два   среда   а   в   наш   случай   это   воздух   стекло   потому   финальный   значение   равно   1   0   1   52   const   float   kbunnyrefractionindex   1   0f   1   52f   теперь   добавлять   в   наш   цикл   проверка   на   попадание   в   кролик   if   objectid   object _ id _ teapot   our   teapot   is   mirror   so   reflect   and   continue   origin   hitpos   hitnormal   0   001f   direction   reflect   direction   hitnormal   else   if   objectid   object _ id _ bunny   our   bunny   is   glass   so   refract   and   continue   const   float   ndotd   dot   hitnormal   direction   const   vec3   refrnormal   ndotd   0   0f   hitnormal   hitnormal   origin   hitpos   direction   0   001f   direction   refract   direction   refrnormal   kbunnyrefractionindex   так   как   преломлять   луч   заходить   внутрь   объект   мы   нужно   отслеживать   это   и   переворачивать   нормаль   чтобы   получать   правильный   результат   преломление   давать   полюбоваться   наш   стеклянный   кролик   мы   с   вы   проходить   путь   от   разноцветный   треугольник   до   сцена   с   несколько   объект   текстурированный   и   реализовать   отражать   и   преломлять   поверхность   на   этот   основа   уже   можно   строить   более   или   менее   серьезный   рейтрейсер   пастрейсер   в   следующий   статья   я   постараться   рассматривать   гибридный   рендеринг   совмещать   растеризация   и   рейтрейсинг   исходный   код   к   статья   находиться   здесь   https   github   com   iorange   rtxon   tree   version _ 2 _ 2   график   raytracing   rtx   vulkan   рейтрейсинг   18   ноябрь   2018   обновление   27   ной   2018   комментарий   60   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   gamedev   ru   разработка   игра   2001   2019