   писать   простой   рейтрейсер   использовать   Vulkan   Raytracing   график   статья   программирование  
 игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   FAQ 

   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект
   форум   работа   входить   программированиестатьиграфика   писать   простой   рейтрейсер   использовать   Vulkan   Raytracing
 
   автор   0r   ngE   все   привет   сегодня   я   рассказывать   вы  
 как   получать   результат   изображать   на   заглавный   картинка   к   этот   статья  
 использовать 
   Vulkan   Raytracing   часть   0   приветствие   часть   1   кролик   и
   чайник   часть   2   камера   мотор   часть   2   сталь   и   мрамор
   часть 
   3   да   быть   свет   часть   4   зеркало   часть  
 5   зацикливаться   часть   6   стекло   и   финал   часть   0   приветствие  
 в   прошлый 
   раз   мы   с   вы   рассматривать   что   же   из
   себя   представлять   Vulkan   Ray   Tracing   и   как   с   он   работать
   итог   тот 
   статья   становиться   простой   приложение   создавать   то   не  
 менее   сцена   пайплайн   шейдер   и   выводить   на   экран   результат   трассировка  
 луч   по   этот 
   сцена   и   хоть   наш   треугольник   и   получаться
   на   порядок   реалистичный   растеризованный   все   же   хотеться   бы   увидеть   рейтрейсинг
   во   весь   его 
   краса   ведь   не   зря   мы   потратить  
 деньги   на   RTX   видеокарта   именно   это   и   быть   посвящать   данный  
 статья   хотеться   бы   сразу 
   отмечать   цель   статья   показывать   как   использовать
   Vulkan   для   построение   полноценный   рейтрейсер   показывать   основной   архитектурный   момент   и
   давать   несколько   совет   по 
   написание   эффективный   шейдер   для   рейтрейсинг  
 часть   1   кролик   и   чайник   первый   дело   мы   понадобиться   сам  
 сцена   я   взять   на   себя 
   смелость   подготовить   переосмыслять   версия   классический
   икона   рейтрейсинг   сцена   тернер   уиттед   зеркальный   и   стеклянный   шар   над
   кусок   линолеум   в   наш   случай 
   сцена   называться   хромированный   чайник  
 и   стеклянный   кролик   на   мраморный   пол   модель   кролик   Stanford   Bunny  
 быть   позаимствовать   отсюда   https   casual   effects 
   com   g3d   data10   index
   html   mesh3   модель   чайник   использоваться   тот   что   встраивать   в   3DS
   Max   модель   пол   быть   мастерски   изготавливать 
   автор   статья   собственноручно  
 текстура   взять   с   сайт   https   texturehaven   com   для   загрузка   сцена  
 использоваться   библиотека   tinyobjloader   для   загрузка   текстура   использоваться 
   все   любимая   stb
 _ image   также   для   более   удобный   работа   со   сцена   и   ее
   ресурс   быть   добавлять   вспомогательный   структура   RTAccelerationStructure   RTMesh   RTMaterial 
   RTScene  
 код   по   больший   часть   оставаться   без   изменение   только   вместо   один  
 Bottom   Level   Acceleration   Structure   BLAS   теперь   у   мы   они 
   несколько
   а   соответственно   и   несколько   VkGeometryNV   и   VkGeometryInstance   важно   также   отмечать
   что   поле   instanceId   каждый   инстанс   мы   теперь   присваивать   порядковый 
  
 номер   объект   в   сцена   это   помогать   мы   в   будущее   обращаться  
 к   его   атрибут   создавать   для   каждый   объект   сцена   свой   BLAS 

   и   instance   мы   строить   Top   Level   Acceleration   Sctructure   TLAS   наш
   сцена   готовый   часть   2   камера   мотор   для   наш   треугольник   мы
 
   хватать   ортографический   проекция   где   все   луч   идти   параллельно   чтобы  
 видеть   наш   новый   сцена   во   весь   ее   краса   мы   понадобиться  
 перспективный 
   камера   мы   не   быть   заниматься   моделирование   реальный   линза   а
   останавливаться   на   простой   камера   обскура   pinhole   camera   в   такой   модель
   камера 
   наш   луч   выходить   из   один   точка   позиция   наблюдатель  
 и   расходиться   образовывать   пирамида   формирование   луч   для   каждый   пиксел   наш  
 экран   в 
   такой   случай   являться   очень   простой   отправной   точка   это
   всегда   позиция   наблюдатель   а   конечный   точка   проекция   на   дальний   плоскость
   отсечение   основание 
   пирамида   я   добавлять   в   состав   фреймворок   класс  
 Camera   реализовать   весь   необходимый   мы   метод   и   позволять   управлять   камера  
 с   помощь   пользовательский 
   ввод   для   передача   параметр   камера   в   шейдер
   использоваться   Uniform   Buffer   Object   UBO   следующий   содержание   struct   UniformParams   vec4
   camPos   vec4   camDir 
   vec4   camUp   vec4   camSide   vec4   camNearFarFov  
 в   шейдер   же   для   построение   луч   быть   добавлять   функция   CalcRayDir  
 который   для   заданный   пиксел 
   экран   находить   необходимый   направление   луч   использовать
   ориентация   камера   и   угол   обзор   теперь   же   если   запускать   наш
   приложение   то   мы   увидеть 
   следующий   картина   теперь   вместо   один  
 цветной   треугольник   у   мы   на   экран   несколько   сотня   тысяча   цветной  
 треугольник   хвала   рейтрейсинг   часть   2 
   сталь   и   мрамор   разноцветный   треугольник
   это   конечно   же   хорошо   но   как   насчет   текстура   к   счастие
   текстурирование   треугольник   мало   чем   отличаться 
   от   таковой   в   растеризация  
 мы   все   так   же   нужный   текстурный   координата   каждый   вершина   треугольник  
 их   интерполировать   значение   для   интересовать   мы 
   пиксел   а   также   сам
   текстура   и   сэмплер   sampler   для   интерполяция   текстурный   координата   а   также
   любой   вершинный   атрибут   мы   и   пригождаться 
   тот   самый   барицентрический  
 координата   который   мы   и   выводить   до   сей   пора   но   где  
 же   мы   взять   вершинный   атрибут   для   растеризация 
   мы   складывать   вершинный
   атрибут   в   вершинный   буфер   и   далее   конвейер   все   делать   за
   мы   но   в   случай   рейтрейсинг   нужно   заниматься 
   это   сам  
 хороший   новость   в   то   что   это   совсем   не   сложный   для  
 передача   атрибут   в   шейдер   мы   пригождаться   Shader   Storage 
   Buffer   Object
   SSBO   или   StructuredBuffer   в   термин   DirectX   складывать   вершинный   атрибут   в
   SSBO   и   передавать   в   шейдер   вроде   ничто   сложный 
   но  
 как   узнавать   какой   именно   вершина   мы   нужный   для   начало   мы  
 нужно   узнавать   в   какой   именно   треугольник   мы   попадать   и 
   помогать
   мы   в   это   gl _ PrimitiveID   который   содержать   порядковый   номер   треугольник
   в   данный   объект   уже   хорошо   но   часто   все   наш   геометрия
 
   индексировать   чтобы   избегать   дублирование   данные   а   значит   мы   понадобиться  
 также   индекс   который   мы   передавать   через   SSBO   итак   у   мы  
 быть 
   номер   треугольник   по   который   мы   мочь   прочитывать   индекс   с
   помощь   который   мы   читать   вершинный   атрибут   проинтерполировать   который   мы   наконец
   мочь 
   обращаться   к   текстура   но   как   мы   узнавать   к  
 какой   именно   для   это   мы   пригождаться   еще   один   SSBO   буфер  
 хранить   в 
   себя   индекс   текстура   для   каждый   треугольник   объект   для
   чтение   из   он   мы   пригождаться   знакомый   уже   мы   gl _ PrimitiveID
   итак   давать   записывать 
   какой   в   итог   буфер   мы   понадобиться  
 MaterialsIDs   SSBO   индекс   материал   для   каждый   треугольник   FacesBuffer   SSBO   индекс  
 вершина   AttribsBuffer   SSBO   вершинный 
   атрибут   Texture   sampler2D   текстура   но   ведь
   у   мы   несколько   объект   в   сцена   как   быть   с   это
   к   счастие   для   это 
   существовать   расширение   VK _ EXT _ descriptor _
 indexing   добавлять   много   вкусности   и   послабление   для   дескриптор   но   самый  
 главное   для   мы   возможность   при   создание   разметка   набор 
   дескриптор   descriptor
   set   layout   указывать   что   этот   самый   дескриптор   неопределенный   количество   такой
   образ   мы   мочь   в   рантайм   решать   размерность   массив 
   передавать  
 ресурс   что   просто   идеально   для   наш   ситуация   разбирать   подробно   я  
 этот   расширение   не   быть   это   выходить   за   рамка   данный 
   статья
   так   что   для   дальнейший   ознакомление   мочь   проходить   по   этот   ссылочка
   https   www   khronos   org   registry   vulkan   specs   1   1 
  
 extensions   html   ptor _ indexing   помнить   как   мы   при   создание   инстанс  
 в   качество   id   указывать   порядковый   номер   объект   так   вот   он  
 то 
   мы   теперь   и   пригождаться   чтобы   брать   из   массив   нужный
   буфер   для   это   мы   понадобиться   встроенный   переменная   gl _ InstanceCustomIndexNV   который
   как   раз 
   и   содержать   тот   самый   значение   вот   так  
 быть   выглядеть   наш   код   текстурирование   const   vec3   barycentrics   vec3   1  
 0f   HitAttribs   x 
   HitAttribs   y   HitAttribs   x   HitAttribs   y   const
   uint   matID   MatIDsArray   nonuniformEXT   gl _ InstanceCustomIndexNV   MatIDs   gl _ PrimitiveID   const
   uvec4   face   FacesArray   nonuniformEXT   gl _ InstanceCustomIndexNV 
   Faces   gl _ PrimitiveID  
 VertexAttribute   v0   AttribsArray   nonuniformEXT   gl _ InstanceCustomIndexNV   VertexAttribs   int   face   x  
 VertexAttribute   v1   AttribsArray   nonuniformEXT   gl _ InstanceCustomIndexNV   VertexAttribs   int   face   y 

   VertexAttribute   v2   AttribsArray   nonuniformEXT   gl _ InstanceCustomIndexNV   VertexAttribs   int   face   z
   const   vec2   uv   BaryLerp   v0   uv   xy   v1   uv   xy
   v2 
   uv   xy   barycentrics   const   vec3   texel   textureLod   TexturesArray  
 nonuniformEXT   matID   uv   0   0f   rgb   как   видеть   все   оказываться  
 совсем   не 
   сложный   и   очень   даже   гибко   запускать   наш   приложение
   и   увидеть   следующий   картинка   уже   намного   хорошо   но   что   то
   не   хватать 
   ах   да   освещение   часть   3   да   быть  
 свет   давать   добавлять   простой   освещение   классика   компьютерный   график   диффузный   модель  
 освещение   ламберт   согласно 
   этот   модель   освещение   рассеиваться   равномерно   по   полусфера
   а   освещенность   диктоваться   только   плотность   световой   поток   который   обратно   пропорциональный
   угол   поток   свет 
   к   поверхность   или   просто   говорить   все  
 любимый   мистер   N   dot   L   и   тут   начинать   проявляться   достоинство  
 рейтрейсинг   перед   растеризация   тень 
   точка   находиться   в   тень   если   она
   не   видеть   напрямую   источник   свет   и   это   очень   легко   сделать
   с   помощь   рейтрейсинг   достаточно 
   лишь   пускать   луч   в   направление  
 источник   свет   и   посмотреть   не   попадаться   ли   мы   что   по  
 путь   если   находить   пересечение   значит 
   источник   свет   закрывать   и   мы
   в   тень   если   же   пересечение   не   быть   значит   мы   мочь
   считать   освещение   для   это   при 
   нахождение   первичный   пересечение   мы  
 нужно   построить   новый   луч   и   вызывать   traceNV   еще   раз   для  
 проверка   видимость   источник   свет   делать   это 
   можно   и   в   Hit
   шейдер   но   рекомендоваться   весь   вызов   traceNV   производить   в   Raygen   шейдер
   так   как   это   позволять   планировщик   scheduler 
   работать   с   максимальный  
 эффективность   еще   один   оптимизация   использовать   RayPayload   как   можно   меньший   размер  
 а   также   специализированный   Hit   и   Miss   шейдер 
   для   теневой   луч
   мы   в   качество   RayPayload   понадобиться   всего   один   значение   быть   ли
   пересечение   или   нет   соответственно   в   Hit   шейдер 
   мы   быть  
 отмечать   что   пересечение   быть   и   в   Miss   шейдер   что   не  
 быть   давать   дополнять   наш   код   Raygen   шейдер   const 
   vec3   hitColor
   PrimaryRay   colorAndDist   rgb   const   float   hitDistance   PrimaryRay   colorAndDist   w   const
   vec3   hitNormal   PrimaryRay   normal   xyz   float   lighting   1 
   0f  
 if   we   hit   something   if   hitDistance   0   0f   const   vec3  
 hitPos   origin   direction   hitDistance   const   vec3   toLight   normalize   Params 
   sunPosAndAmbient
   xyz   const   vec3   shadowRayOrigin   hitPos   hitNormal   0   01f   const   uint
   shadowRayFlags   gl _ RayFlagsOpaqueNV   gl _ RayFlagsTerminateOnFirstHitNV   const   uint   shadowRecordOffset   1   const
   uint 
   shadowMissIndex   1   traceNV   Scene   rayFlags   cullMask   shadowRecordOffset   stbRecordStride  
 shadowMissIndex   shadowRayOrigin   0   0f   toLight   tmax   SWS _ LOC _ SHADOW _ RAY  
 if   ShadowRay   distance   0   0f 
   lighting   Params   sunPosAndAmbient   w   else
   lighting   max   Params   sunPosAndAmbient   w   dot   hitNormal   toLight   замечать   что
   для   теневой   луч   мы   указывать 
   флаг   gl _ RayFlagsTerminateOnFirstHitNV   такой  
 образ   мы   останавливать   трассировка   при   первый   же   пересечение   без   поиск  
 близкий   ведь   мы   важный   сам   факт   наличие 
   пересечение   такой   образ
   мы   проверять   быть   ли   первичный   пересечение   или   мы   ударяться   в
   небо   если   пересечение   быть   то   восстанавливать   координата 
   точка   пересечение  
 ведь   мы   знать   расстояние   до   точка   пересечение   от   начальный   точка  
 луч   получать   направление   на   источник   свет   и   вызывать 
   traceNV   указывать
   в   качество   шейдер   наш   специализированный   теневой   шейдер   а   также   расположение
   PayLoad   для   теневой   луч   замечать   что   для   задание 
   отправной  
 точка   наш   луч   мы   немного   смещать   она   вдоль   нормаль   это  
 сделать   для   избежание   нежелательный   самозатенение   также   для   это   можно 
   использовать
   значение   tmin   отличный   от   ноль   после   это   мы   проверять   быть
   ли   пересечение   и   если   не   быть   то   считать   освещение 
  
 по   модель   ламберт   если   же   пересечение   быть   то   в   качество  
 освещение   взять   константный   значение   окружающий   свет   ambient   light   не   смотря 

   на   простота   этот   модель   благодаря   наличие   тень   мы   получать   довольно
   симпатичный   картинка   часть   4   зеркало   как   вы   уже   мочь   замечать
 
   рейтрейсинг   это   простой   но   в   тот   же   время   очень  
 мощный   инструмент   с   помощь   простой   механизм   запуск   луч   и   проверка  
 результат 
   пересечение   можно   реализовывать   множество   фич   реализовать   который   с   помощь
   растеризация   или   сложный   или   и   вовсе   невозможный   давать   рассматривать   например
   отражение 
   современный   растерный   рендеры   научаться   многий   трюк   для   построение  
 приемлемый   отражение   но   весь   они   далекий   от   реалистичность   и   делать  
 довольно   много 
   допущение   с   помощь   рейтрейсинг   мы   мочь   получать   отражение
   очень   легко   достаточно   простой   отражать   приходить   луч   и   отслеживать   его
   пересечение   давать 
   попробовать   для   начало   определяться   что   отражать   свойство  
 у   мы   быть   обладать   чайник   ведь   он   легко   мочь   быть  
 хромированный   для   это 
   мы   в   Hit   шейдер   быть   записывать   в
   RayPayload   флаг   означать   попадать   ли   мы   в   чайник   или   нет
   так   как   я 
   создавать   сцена   я   знать   что   порядковый  
 номер   чайник   2   теперь   все   что   мы   нужно   сделать   в  
 Raygen   шейдер   это   проверять 
   попадать   ли   мы   в   чайник   и
   вместо   теневой   луч   выпускать   еще   один   первичный   луч   отражать   направление
   текущий   луч   и   использовать 
   цвет   в   точка   пересечение   в  
 качество   отражение   const   float   isTeapot   PrimaryRay   normal   w   if   teapot  
 let   s   reflect   if   isTeapot 
   0   0f   const   vec3   hitPos
   origin   direction   hitDistance   hitNormal   0   01f   const   vec3   reflectedDir   reflect
   direction   hitNormal   traceNV   Scene   rayFlags 
   cullMask   primaryRecordOffset   stbRecordStride   primaryMissIndex  
 hitPos   0   0f   reflectedDir   tmax   SWS _ LOC _ PRIMARY _ RAY   мы  
 использовать   тот   же   RayPayload   и   тот   же   шейдер   что 
   и
   для   первичный   луч   ведь   мы   по   суть   просто   продолжать   трассировка
   первичный   луч   теперь   мы   мочь   наслаждаться   вид   хромированный   чайник 
  
 как   вы   наверное   мочь   замечать   отражение   на   наш   чайник   какой  
 то   странный   на   отражение   пол   нет   тень   а   также   боковой 

   и   верхний   ручка   чайник   отражаться   текстурированный   это   происходить   потому   что
   после   нахождение   пересечение   отраженный   луч   мы   просто   забирать   получаться   цвет
 
   и   на   этот   останавливаться   во   первый   мы   как   минимум  
 нужно   рассчитать   освещение   в   точка   пересечение   а   во   второй   если  
 мы 
   снова   попадать   в   зеркальный   поверхность   то   нужно   отражать   луч
   и   продолжать   трассировка   попробовать   поставлять   два   зеркало   напротив   друг   друг
   и 
   вы   увидеть   бесконечный   отражение   мы   себя   конечно   же  
 бесконечный   отражение   позволять   не   мочь   но   как   минимум   несколько   уровень  
 отражение   вполне 
   мочь   осиливать   часть   5   зацикливаться   весь   мы   знать
   что   рекурсия   это   плохо   но   рекурсия   на   GPU   еще   худо
   и   хоть 
   Vulkan   Raytracing   и   предоставлять   мы   возможность   для  
 организация   рекурсивный   трассировка   производительность   ради   стоить   она   по   возможность   избегать  
 в   наш   случай 
   вполне   можно   обходиться   и   обычный   цикл   на
   каждый   итерация   мы   трассировать   луч   проверять   куда   попадать   и   решать
   если   попадать   в 
   небо   прерывать   цикл   если   попадать   в  
 чайник   строить   отраженный   луч   и   продолжать   если   попадать   оставаться   часть  
 сцена   считать   освещение   и 
   прерывать   цикл   императивный   путь   я   подбирать
   максимальный   количество   итерация   равный   10   это   позволять   иметь   достаточный   количество
   переотражение   чтобы   создавать   правдоподобный 
   картинка   при   это   сохранять   хороший  
 производительность   изменять   наш   шейдер   в   соответствие   с   излагать   алгоритм   vec3  
 finalColor   vec3   0   0f   for 
   int   i   0   i   SWS
 _ MAX _ RECURSION   i   traceNV   Scene   rayFlags   cullMask   primaryRecordOffset   stbRecordStride   primaryMissIndex
   origin   tmin   direction   tmax   SWS _ LOC _ PRIMARY _ RAY   const   vec3
 
   hitColor   PrimaryRay   colorAndDist   rgb   const   float   hitDistance   PrimaryRay   colorAndDist  
 w   if   hit   background   quit   if   hitDistance   0   0f   finalColor  
 hitColor 
   break   else   const   vec3   hitNormal   PrimaryRay   normal   xyz   const
   float   isTeapot   PrimaryRay   normal   w   const   vec3   hitPos   origin   direction
   hitDistance 
   if   isTeapot   0   0f   our   teapot   is   mirror  
 so   continue   origin   hitPos   hitNormal   0   01f   direction   reflect   direction  
 hitNormal   else 
   we   hit   diffuse   primitive   simple   lambertian   const   vec3
   toLight   normalize   Params   sunPosAndAmbient   xyz   const   vec3   shadowRayOrigin   hitPos   hitNormal
   0   01f 
   traceNV   Scene   rayFlags   cullMask   shadowRecordOffset   stbRecordStride   shadowMissIndex  
 shadowRayOrigin   0   0f   toLight   tmax   SWS _ LOC _ SHADOW _ RAY   const  
 float   lighting   ShadowRay   distance   0   0f 
   Params   sunPosAndAmbient   w   max
   Params   sunPosAndAmbient   w   dot   hitNormal   toLight   finalColor   hitColor   lighting   break
   результат   правдоподобный   отражение   часть   6   стекло 
   и   финал   наш  
 рейтрейсер   начинать   обретать   черта   взрослый   трассировщик   теперь   иметь   на   рука  
 универсальный   цикл   трассировка   мы   мочь   расширять   функционал 
   добавлять   новый   материал
   и   более   реалистичный   модель   освещение   довольно   небольшой   изменение   можно   получать
   полноценный   трассировщик   путь   path   tracer   для   расчет 
   реалистичный   изображение  
 давать   напоследок   добавлять   еще   один   фич   рейтрейсинг   преломление   вещь   практически  
 нереализуемый   стандартный   растеризация   но   благодаря   наш   цикл   трассировка 
   мы   мочь
   легко   получать   реалистичный   многоуровневый   преломление   давать   сделать   наш   кролик   стеклянный
   для   этот   вводить   константа   порядковый   номер   объект   наш 
   сцена  
 и   в   шейдер   пересечение   быть   записывать   в   RayPayload   номер   объект  
 с   который   пересекаться   const   float   objId   float   gl _ InstanceCustomIndexNV   PrimaryRay 

   normalAndObjId   vec4   normal   objId   подбирать   индекс   преломление   для   наш   кролик
   я   выбирать   обычный   стекло   с   индекс   преломление   равный   1   52
 
   так   как   функция   refract   принимать   соотношение   индекс   преломление   два  
 среда   а   в   наш   случай   это   воздух   стекло   потому   финальный  
 значение 
   равно   1   0   1   52   const   float   kBunnyRefractionIndex   1
   0f   1   52f   теперь   добавлять   в   наш   цикл   проверка   на
   попадание 
   в   кролик   if   objectId   OBJECT _ ID _ TEAPOT   our  
 teapot   is   mirror   so   reflect   and   continue   origin   hitPos   hitNormal  
 0   001f   direction   reflect 
   direction   hitNormal   else   if   objectId   OBJECT
 _ ID _ BUNNY   our   bunny   is   glass   so   refract   and   continue
   const   float   NdotD   dot   hitNormal   direction 
   const   vec3   refrNormal  
 NdotD   0   0f   hitNormal   hitNormal   origin   hitPos   direction   0   001f  
 direction   refract   direction   refrNormal   kBunnyRefractionIndex   так   как 
   преломлять   луч   заходить
   внутрь   объект   мы   нужно   отслеживать   это   и   переворачивать   нормаль   чтобы
   получать   правильный   результат   преломление   давать   полюбоваться   наш 
   стеклянный   кролик  
 мы   с   вы   проходить   путь   от   разноцветный   треугольник   до   сцена  
 с   несколько   объект   текстурированный   и   реализовать   отражать   и 
   преломлять   поверхность
   на   этот   основа   уже   можно   строить   более   или   менее   серьезный
   рейтрейсер   пастрейсер   в   следующий   статья   я   постараться   рассматривать 
   гибридный  
 рендеринг   совмещать   растеризация   и   рейтрейсинг   исходный   код   к   статья   находиться  
 здесь   https   github   com   iOrange   rtxON   tree   Version _ 2 _ 2  
 график 
   raytracing   rtx   Vulkan   рейтрейсинг   18   ноябрь   2018   обновление   27
   ной   2018   комментарий   60   убирать   реклама   контакт   сообщество   участник   каталог
   сайт 
   категория   архив   новость   GameDev   ru   разработка   игра   2001  
 2019 
 писать простой рейтрейсер использовать Vulkan Raytracing график статья программирование игра новость статья код арт дизайн индустрия подсказка термин FAQ
 страница сообщество форум качалка участник пользователь темный тема публикация проект форум работа входить программированиестатьиграфика писать простой рейтрейсер использовать Vulkan Raytracing
 автор 0r ngE все привет сегодня я рассказывать вы как получать результат изображать на заглавный картинка к этот статья использовать
 Vulkan Raytracing часть 0 приветствие часть 1 кролик и чайник часть 2 камера мотор часть 2 сталь и мрамор часть
 3 да быть свет часть 4 зеркало часть 5 зацикливаться часть 6 стекло и финал часть 0 приветствие в прошлый
 раз мы с вы рассматривать что же из себя представлять Vulkan Ray Tracing и как с он работать итог тот
 статья становиться простой приложение создавать то не менее сцена пайплайн шейдер и выводить на экран результат трассировка луч по этот
 сцена и хоть наш треугольник и получаться на порядок реалистичный растеризованный все же хотеться бы увидеть рейтрейсинг во весь его
 краса ведь не зря мы потратить деньги на RTX видеокарта именно это и быть посвящать данный статья хотеться бы сразу
 отмечать цель статья показывать как использовать Vulkan для построение полноценный рейтрейсер показывать основной архитектурный момент и давать несколько совет по
 написание эффективный шейдер для рейтрейсинг часть 1 кролик и чайник первый дело мы понадобиться сам сцена я взять на себя
 смелость подготовить переосмыслять версия классический икона рейтрейсинг сцена тернер уиттед зеркальный и стеклянный шар над кусок линолеум в наш случай
 сцена называться хромированный чайник и стеклянный кролик на мраморный пол модель кролик Stanford Bunny быть позаимствовать отсюда https casual effects
 com g3d data10 index html mesh3 модель чайник использоваться тот что встраивать в 3DS Max модель пол быть мастерски изготавливать
 автор статья собственноручно текстура взять с сайт https texturehaven com для загрузка сцена использоваться библиотека tinyobjloader для загрузка текстура использоваться
 все любимая stb _ image также для более удобный работа со сцена и ее ресурс быть добавлять вспомогательный структура RTAccelerationStructure
 RTMesh RTMaterial RTScene код по больший часть оставаться без изменение только вместо один Bottom Level Acceleration Structure BLAS теперь у
 мы они несколько а соответственно и несколько VkGeometryNV и VkGeometryInstance важно также отмечать что поле instanceId каждый инстанс мы теперь
 присваивать порядковый номер объект в сцена это помогать мы в будущее обращаться к его атрибут создавать для каждый объект сцена
 свой BLAS и instance мы строить Top Level Acceleration Sctructure TLAS наш сцена готовый часть 2 камера мотор для наш
 треугольник мы хватать ортографический проекция где все луч идти параллельно чтобы видеть наш новый сцена во весь ее краса мы
 понадобиться перспективный камера мы не быть заниматься моделирование реальный линза а останавливаться на простой камера обскура pinhole camera в такой
 модель камера наш луч выходить из один точка позиция наблюдатель и расходиться образовывать пирамида формирование луч для каждый пиксел наш
 экран в такой случай являться очень простой отправной точка это всегда позиция наблюдатель а конечный точка проекция на дальний плоскость
 отсечение основание пирамида я добавлять в состав фреймворок класс Camera реализовать весь необходимый мы метод и позволять управлять камера с
 помощь пользовательский ввод для передача параметр камера в шейдер использоваться Uniform Buffer Object UBO следующий содержание struct UniformParams vec4 camPos
 vec4 camDir vec4 camUp vec4 camSide vec4 camNearFarFov в шейдер же для построение луч быть добавлять функция CalcRayDir который для
 заданный пиксел экран находить необходимый направление луч использовать ориентация камера и угол обзор теперь же если запускать наш приложение то
 мы увидеть следующий картина теперь вместо один цветной треугольник у мы на экран несколько сотня тысяча цветной треугольник хвала рейтрейсинг
 часть 2 сталь и мрамор разноцветный треугольник это конечно же хорошо но как насчет текстура к счастие текстурирование треугольник мало
 чем отличаться от таковой в растеризация мы все так же нужный текстурный координата каждый вершина треугольник их интерполировать значение для
 интересовать мы пиксел а также сам текстура и сэмплер sampler для интерполяция текстурный координата а также любой вершинный атрибут мы
 и пригождаться тот самый барицентрический координата который мы и выводить до сей пора но где же мы взять вершинный атрибут
 для растеризация мы складывать вершинный атрибут в вершинный буфер и далее конвейер все делать за мы но в случай рейтрейсинг
 нужно заниматься это сам хороший новость в то что это совсем не сложный для передача атрибут в шейдер мы пригождаться
 Shader Storage Buffer Object SSBO или StructuredBuffer в термин DirectX складывать вершинный атрибут в SSBO и передавать в шейдер вроде
 ничто сложный но как узнавать какой именно вершина мы нужный для начало мы нужно узнавать в какой именно треугольник мы
 попадать и помогать мы в это gl _ PrimitiveID который содержать порядковый номер треугольник в данный объект уже хорошо но
 часто все наш геометрия индексировать чтобы избегать дублирование данные а значит мы понадобиться также индекс который мы передавать через SSBO
 итак у мы быть номер треугольник по который мы мочь прочитывать индекс с помощь который мы читать вершинный атрибут проинтерполировать
 который мы наконец мочь обращаться к текстура но как мы узнавать к какой именно для это мы пригождаться еще один
 SSBO буфер хранить в себя индекс текстура для каждый треугольник объект для чтение из он мы пригождаться знакомый уже мы
 gl _ PrimitiveID итак давать записывать какой в итог буфер мы понадобиться MaterialsIDs SSBO индекс материал для каждый треугольник FacesBuffer
 SSBO индекс вершина AttribsBuffer SSBO вершинный атрибут Texture sampler2D текстура но ведь у мы несколько объект в сцена как быть
 с это к счастие для это существовать расширение VK _ EXT _ descriptor _ indexing добавлять много вкусности и послабление
 для дескриптор но самый главное для мы возможность при создание разметка набор дескриптор descriptor set layout указывать что этот самый
 дескриптор неопределенный количество такой образ мы мочь в рантайм решать размерность массив передавать ресурс что просто идеально для наш ситуация
 разбирать подробно я этот расширение не быть это выходить за рамка данный статья так что для дальнейший ознакомление мочь проходить
 по этот ссылочка https www khronos org registry vulkan specs 1 1 extensions html ptor _ indexing помнить как мы
 при создание инстанс в качество id указывать порядковый номер объект так вот он то мы теперь и пригождаться чтобы брать
 из массив нужный буфер для это мы понадобиться встроенный переменная gl _ InstanceCustomIndexNV который как раз и содержать тот самый
 значение вот так быть выглядеть наш код текстурирование const vec3 barycentrics vec3 1 0f HitAttribs x HitAttribs y HitAttribs x
 HitAttribs y const uint matID MatIDsArray nonuniformEXT gl _ InstanceCustomIndexNV MatIDs gl _ PrimitiveID const uvec4 face FacesArray nonuniformEXT gl
 _ InstanceCustomIndexNV Faces gl _ PrimitiveID VertexAttribute v0 AttribsArray nonuniformEXT gl _ InstanceCustomIndexNV VertexAttribs int face x VertexAttribute v1 AttribsArray
 nonuniformEXT gl _ InstanceCustomIndexNV VertexAttribs int face y VertexAttribute v2 AttribsArray nonuniformEXT gl _ InstanceCustomIndexNV VertexAttribs int face z const
 vec2 uv BaryLerp v0 uv xy v1 uv xy v2 uv xy barycentrics const vec3 texel textureLod TexturesArray nonuniformEXT matID
 uv 0 0f rgb как видеть все оказываться совсем не сложный и очень даже гибко запускать наш приложение и увидеть
 следующий картинка уже намного хорошо но что то не хватать ах да освещение часть 3 да быть свет давать добавлять
 простой освещение классика компьютерный график диффузный модель освещение ламберт согласно этот модель освещение рассеиваться равномерно по полусфера а освещенность диктоваться
 только плотность световой поток который обратно пропорциональный угол поток свет к поверхность или просто говорить все любимый мистер N dot
 L и тут начинать проявляться достоинство рейтрейсинг перед растеризация тень точка находиться в тень если она не видеть напрямую источник
 свет и это очень легко сделать с помощь рейтрейсинг достаточно лишь пускать луч в направление источник свет и посмотреть не
 попадаться ли мы что по путь если находить пересечение значит источник свет закрывать и мы в тень если же пересечение
 не быть значит мы мочь считать освещение для это при нахождение первичный пересечение мы нужно построить новый луч и вызывать
 traceNV еще раз для проверка видимость источник свет делать это можно и в Hit шейдер но рекомендоваться весь вызов traceNV
 производить в Raygen шейдер так как это позволять планировщик scheduler работать с максимальный эффективность еще один оптимизация использовать RayPayload как
 можно меньший размер а также специализированный Hit и Miss шейдер для теневой луч мы в качество RayPayload понадобиться всего один
 значение быть ли пересечение или нет соответственно в Hit шейдер мы быть отмечать что пересечение быть и в Miss шейдер
 что не быть давать дополнять наш код Raygen шейдер const vec3 hitColor PrimaryRay colorAndDist rgb const float hitDistance PrimaryRay colorAndDist
 w const vec3 hitNormal PrimaryRay normal xyz float lighting 1 0f if we hit something if hitDistance 0 0f const
 vec3 hitPos origin direction hitDistance const vec3 toLight normalize Params sunPosAndAmbient xyz const vec3 shadowRayOrigin hitPos hitNormal 0 01f const
 uint shadowRayFlags gl _ RayFlagsOpaqueNV gl _ RayFlagsTerminateOnFirstHitNV const uint shadowRecordOffset 1 const uint shadowMissIndex 1 traceNV Scene rayFlags cullMask
 shadowRecordOffset stbRecordStride shadowMissIndex shadowRayOrigin 0 0f toLight tmax SWS _ LOC _ SHADOW _ RAY if ShadowRay distance 0 0f
 lighting Params sunPosAndAmbient w else lighting max Params sunPosAndAmbient w dot hitNormal toLight замечать что для теневой луч мы указывать
 флаг gl _ RayFlagsTerminateOnFirstHitNV такой образ мы останавливать трассировка при первый же пересечение без поиск близкий ведь мы важный сам
 факт наличие пересечение такой образ мы проверять быть ли первичный пересечение или мы ударяться в небо если пересечение быть то
 восстанавливать координата точка пересечение ведь мы знать расстояние до точка пересечение от начальный точка луч получать направление на источник свет
 и вызывать traceNV указывать в качество шейдер наш специализированный теневой шейдер а также расположение PayLoad для теневой луч замечать что
 для задание отправной точка наш луч мы немного смещать она вдоль нормаль это сделать для избежание нежелательный самозатенение также для
 это можно использовать значение tmin отличный от ноль после это мы проверять быть ли пересечение и если не быть то
 считать освещение по модель ламберт если же пересечение быть то в качество освещение взять константный значение окружающий свет ambient light
 не смотря на простота этот модель благодаря наличие тень мы получать довольно симпатичный картинка часть 4 зеркало как вы уже
 мочь замечать рейтрейсинг это простой но в тот же время очень мощный инструмент с помощь простой механизм запуск луч и
 проверка результат пересечение можно реализовывать множество фич реализовать который с помощь растеризация или сложный или и вовсе невозможный давать рассматривать
 например отражение современный растерный рендеры научаться многий трюк для построение приемлемый отражение но весь они далекий от реалистичность и делать
 довольно много допущение с помощь рейтрейсинг мы мочь получать отражение очень легко достаточно простой отражать приходить луч и отслеживать его
 пересечение давать попробовать для начало определяться что отражать свойство у мы быть обладать чайник ведь он легко мочь быть хромированный
 для это мы в Hit шейдер быть записывать в RayPayload флаг означать попадать ли мы в чайник или нет так
 как я создавать сцена я знать что порядковый номер чайник 2 теперь все что мы нужно сделать в Raygen шейдер
 это проверять попадать ли мы в чайник и вместо теневой луч выпускать еще один первичный луч отражать направление текущий луч
 и использовать цвет в точка пересечение в качество отражение const float isTeapot PrimaryRay normal w if teapot let s reflect
 if isTeapot 0 0f const vec3 hitPos origin direction hitDistance hitNormal 0 01f const vec3 reflectedDir reflect direction hitNormal traceNV
 Scene rayFlags cullMask primaryRecordOffset stbRecordStride primaryMissIndex hitPos 0 0f reflectedDir tmax SWS _ LOC _ PRIMARY _ RAY мы использовать
 тот же RayPayload и тот же шейдер что и для первичный луч ведь мы по суть просто продолжать трассировка первичный
 луч теперь мы мочь наслаждаться вид хромированный чайник как вы наверное мочь замечать отражение на наш чайник какой то странный
 на отражение пол нет тень а также боковой и верхний ручка чайник отражаться текстурированный это происходить потому что после нахождение
 пересечение отраженный луч мы просто забирать получаться цвет и на этот останавливаться во первый мы как минимум нужно рассчитать освещение
 в точка пересечение а во второй если мы снова попадать в зеркальный поверхность то нужно отражать луч и продолжать трассировка
 попробовать поставлять два зеркало напротив друг друг и вы увидеть бесконечный отражение мы себя конечно же бесконечный отражение позволять не
 мочь но как минимум несколько уровень отражение вполне мочь осиливать часть 5 зацикливаться весь мы знать что рекурсия это плохо
 но рекурсия на GPU еще худо и хоть Vulkan Raytracing и предоставлять мы возможность для организация рекурсивный трассировка производительность ради
 стоить она по возможность избегать в наш случай вполне можно обходиться и обычный цикл на каждый итерация мы трассировать луч
 проверять куда попадать и решать если попадать в небо прерывать цикл если попадать в чайник строить отраженный луч и продолжать
 если попадать оставаться часть сцена считать освещение и прерывать цикл императивный путь я подбирать максимальный количество итерация равный 10 это
 позволять иметь достаточный количество переотражение чтобы создавать правдоподобный картинка при это сохранять хороший производительность изменять наш шейдер в соответствие с
 излагать алгоритм vec3 finalColor vec3 0 0f for int i 0 i SWS _ MAX _ RECURSION i traceNV Scene
 rayFlags cullMask primaryRecordOffset stbRecordStride primaryMissIndex origin tmin direction tmax SWS _ LOC _ PRIMARY _ RAY const vec3 hitColor PrimaryRay
 colorAndDist rgb const float hitDistance PrimaryRay colorAndDist w if hit background quit if hitDistance 0 0f finalColor hitColor break else
 const vec3 hitNormal PrimaryRay normal xyz const float isTeapot PrimaryRay normal w const vec3 hitPos origin direction hitDistance if isTeapot
 0 0f our teapot is mirror so continue origin hitPos hitNormal 0 01f direction reflect direction hitNormal else we hit
 diffuse primitive simple lambertian const vec3 toLight normalize Params sunPosAndAmbient xyz const vec3 shadowRayOrigin hitPos hitNormal 0 01f traceNV Scene
 rayFlags cullMask shadowRecordOffset stbRecordStride shadowMissIndex shadowRayOrigin 0 0f toLight tmax SWS _ LOC _ SHADOW _ RAY const float lighting
 ShadowRay distance 0 0f Params sunPosAndAmbient w max Params sunPosAndAmbient w dot hitNormal toLight finalColor hitColor lighting break результат правдоподобный
 отражение часть 6 стекло и финал наш рейтрейсер начинать обретать черта взрослый трассировщик теперь иметь на рука универсальный цикл трассировка
 мы мочь расширять функционал добавлять новый материал и более реалистичный модель освещение довольно небольшой изменение можно получать полноценный трассировщик путь
 path tracer для расчет реалистичный изображение давать напоследок добавлять еще один фич рейтрейсинг преломление вещь практически нереализуемый стандартный растеризация но
 благодаря наш цикл трассировка мы мочь легко получать реалистичный многоуровневый преломление давать сделать наш кролик стеклянный для этот вводить константа
 порядковый номер объект наш сцена и в шейдер пересечение быть записывать в RayPayload номер объект с который пересекаться const float
 objId float gl _ InstanceCustomIndexNV PrimaryRay normalAndObjId vec4 normal objId подбирать индекс преломление для наш кролик я выбирать обычный стекло
 с индекс преломление равный 1 52 так как функция refract принимать соотношение индекс преломление два среда а в наш случай
 это воздух стекло потому финальный значение равно 1 0 1 52 const float kBunnyRefractionIndex 1 0f 1 52f теперь добавлять
 в наш цикл проверка на попадание в кролик if objectId OBJECT _ ID _ TEAPOT our teapot is mirror so
 reflect and continue origin hitPos hitNormal 0 001f direction reflect direction hitNormal else if objectId OBJECT _ ID _ BUNNY
 our bunny is glass so refract and continue const float NdotD dot hitNormal direction const vec3 refrNormal NdotD 0 0f
 hitNormal hitNormal origin hitPos direction 0 001f direction refract direction refrNormal kBunnyRefractionIndex так как преломлять луч заходить внутрь объект мы
 нужно отслеживать это и переворачивать нормаль чтобы получать правильный результат преломление давать полюбоваться наш стеклянный кролик мы с вы проходить
 путь от разноцветный треугольник до сцена с несколько объект текстурированный и реализовать отражать и преломлять поверхность на этот основа уже
 можно строить более или менее серьезный рейтрейсер пастрейсер в следующий статья я постараться рассматривать гибридный рендеринг совмещать растеризация и рейтрейсинг
 исходный код к статья находиться здесь https github com iOrange rtxON tree Version _ 2 _ 2 график raytracing rtx
 Vulkan рейтрейсинг 18 ноябрь 2018 обновление 27 ной 2018 комментарий 60 убирать реклама контакт сообщество участник каталог сайт категория архив
 новость GameDev ru разработка игра 2001 2019 писать простой рейтрейсер использовать Vulkan Raytracing график статья программирование игра новость статья код арт дизайн индустрия подсказка термин FAQ
 страница сообщество форум качалка участник пользователь темный тема публикация проект форум работа входить программированиестатьиграфика писать простой рейтрейсер использовать Vulkan Raytracing
 автор 0r ngE все привет сегодня я рассказывать вы как получать результат изображать на заглавный картинка к этот статья использовать
 Vulkan Raytracing часть 0 приветствие часть 1 кролик и чайник часть 2 камера мотор часть 2 сталь и мрамор часть
 3 да быть свет часть 4 зеркало часть 5 зацикливаться часть 6 стекло и финал часть 0 приветствие в прошлый
 раз мы с вы рассматривать что же из себя представлять Vulkan Ray Tracing и как с он работать итог тот
 статья становиться простой приложение создавать то не менее сцена пайплайн шейдер и выводить на экран результат трассировка луч по этот
 сцена и хоть наш треугольник и получаться на порядок реалистичный растеризованный все же хотеться бы увидеть рейтрейсинг во весь его
 краса ведь не зря мы потратить деньги на RTX видеокарта именно это и быть посвящать данный статья хотеться бы сразу
 отмечать цель статья показывать как использовать Vulkan для построение полноценный рейтрейсер показывать основной архитектурный момент и давать несколько совет по
 написание эффективный шейдер для рейтрейсинг часть 1 кролик и чайник первый дело мы понадобиться сам сцена я взять на себя
 смелость подготовить переосмыслять версия классический икона рейтрейсинг сцена тернер уиттед зеркальный и стеклянный шар над кусок линолеум в наш случай
 сцена называться хромированный чайник и стеклянный кролик на мраморный пол модель кролик Stanford Bunny быть позаимствовать отсюда https casual effects
 com g3d data10 index html mesh3 модель чайник использоваться тот что встраивать в 3DS Max модель пол быть мастерски изготавливать
 автор статья собственноручно текстура взять с сайт https texturehaven com для загрузка сцена использоваться библиотека tinyobjloader для загрузка текстура использоваться
 все любимая stb _ image также для более удобный работа со сцена и ее ресурс быть добавлять вспомогательный структура RTAccelerationStructure
 RTMesh RTMaterial RTScene код по больший часть оставаться без изменение только вместо один Bottom Level Acceleration Structure BLAS теперь у
 мы они несколько а соответственно и несколько VkGeometryNV и VkGeometryInstance важно также отмечать что поле instanceId каждый инстанс мы теперь
 присваивать порядковый номер объект в сцена это помогать мы в будущее обращаться к его атрибут создавать для каждый объект сцена
 свой BLAS и instance мы строить Top Level Acceleration Sctructure TLAS наш сцена готовый часть 2 камера мотор для наш
 треугольник мы хватать ортографический проекция где все луч идти параллельно чтобы видеть наш новый сцена во весь ее краса мы
 понадобиться перспективный камера мы не быть заниматься моделирование реальный линза а останавливаться на простой камера обскура pinhole camera в такой
 модель камера наш луч выходить из один точка позиция наблюдатель и расходиться образовывать пирамида формирование луч для каждый пиксел наш
 экран в такой случай являться очень простой отправной точка это всегда позиция наблюдатель а конечный точка проекция на дальний плоскость
 отсечение основание пирамида я добавлять в состав фреймворок класс Camera реализовать весь необходимый мы метод и позволять управлять камера с
 помощь пользовательский ввод для передача параметр камера в шейдер использоваться Uniform Buffer Object UBO следующий содержание struct UniformParams vec4 camPos
 vec4 camDir vec4 camUp vec4 camSide vec4 camNearFarFov в шейдер же для построение луч быть добавлять функция CalcRayDir который для
 заданный пиксел экран находить необходимый направление луч использовать ориентация камера и угол обзор теперь же если запускать наш приложение то
 мы увидеть следующий картина теперь вместо один цветной треугольник у мы на экран несколько сотня тысяча цветной треугольник хвала рейтрейсинг
 часть 2 сталь и мрамор разноцветный треугольник это конечно же хорошо но как насчет текстура к счастие текстурирование треугольник мало
 чем отличаться от таковой в растеризация мы все так же нужный текстурный координата каждый вершина треугольник их интерполировать значение для
 интересовать мы пиксел а также сам текстура и сэмплер sampler для интерполяция текстурный координата а также любой вершинный атрибут мы
 и пригождаться тот самый барицентрический координата который мы и выводить до сей пора но где же мы взять вершинный атрибут
 для растеризация мы складывать вершинный атрибут в вершинный буфер и далее конвейер все делать за мы но в случай рейтрейсинг
 нужно заниматься это сам хороший новость в то что это совсем не сложный для передача атрибут в шейдер мы пригождаться
 Shader Storage Buffer Object SSBO или StructuredBuffer в термин DirectX складывать вершинный атрибут в SSBO и передавать в шейдер вроде
 ничто сложный но как узнавать какой именно вершина мы нужный для начало мы нужно узнавать в какой именно треугольник мы
 попадать и помогать мы в это gl _ PrimitiveID который содержать порядковый номер треугольник в данный объект уже хорошо но
 часто все наш геометрия индексировать чтобы избегать дублирование данные а значит мы понадобиться также индекс который мы передавать через SSBO
 итак у мы быть номер треугольник по который мы мочь прочитывать индекс с помощь который мы читать вершинный атрибут проинтерполировать
 который мы наконец мочь обращаться к текстура но как мы узнавать к какой именно для это мы пригождаться еще один
 SSBO буфер хранить в себя индекс текстура для каждый треугольник объект для чтение из он мы пригождаться знакомый уже мы
 gl _ PrimitiveID итак давать записывать какой в итог буфер мы понадобиться MaterialsIDs SSBO индекс материал для каждый треугольник FacesBuffer
 SSBO индекс вершина AttribsBuffer SSBO вершинный атрибут Texture sampler2D текстура но ведь у мы несколько объект в сцена как быть
 с это к счастие для это существовать расширение VK _ EXT _ descriptor _ indexing добавлять много вкусности и послабление
 для дескриптор но самый главное для мы возможность при создание разметка набор дескриптор descriptor set layout указывать что этот самый
 дескриптор неопределенный количество такой образ мы мочь в рантайм решать размерность массив передавать ресурс что просто идеально для наш ситуация
 разбирать подробно я этот расширение не быть это выходить за рамка данный статья так что для дальнейший ознакомление мочь проходить
 по этот ссылочка https www khronos org registry vulkan specs 1 1 extensions html ptor _ indexing помнить как мы
 при создание инстанс в качество id указывать порядковый номер объект так вот он то мы теперь и пригождаться чтобы брать
 из массив нужный буфер для это мы понадобиться встроенный переменная gl _ InstanceCustomIndexNV который как раз и содержать тот самый
 значение вот так быть выглядеть наш код текстурирование const vec3 barycentrics vec3 1 0f HitAttribs x HitAttribs y HitAttribs x
 HitAttribs y const uint matID MatIDsArray nonuniformEXT gl _ InstanceCustomIndexNV MatIDs gl _ PrimitiveID const uvec4 face FacesArray nonuniformEXT gl
 _ InstanceCustomIndexNV Faces gl _ PrimitiveID VertexAttribute v0 AttribsArray nonuniformEXT gl _ InstanceCustomIndexNV VertexAttribs int face x VertexAttribute v1 AttribsArray
 nonuniformEXT gl _ InstanceCustomIndexNV VertexAttribs int face y VertexAttribute v2 AttribsArray nonuniformEXT gl _ InstanceCustomIndexNV VertexAttribs int face z const
 vec2 uv BaryLerp v0 uv xy v1 uv xy v2 uv xy barycentrics const vec3 texel textureLod TexturesArray nonuniformEXT matID
 uv 0 0f rgb как видеть все оказываться совсем не сложный и очень даже гибко запускать наш приложение и увидеть
 следующий картинка уже намного хорошо но что то не хватать ах да освещение часть 3 да быть свет давать добавлять
 простой освещение классика компьютерный график диффузный модель освещение ламберт согласно этот модель освещение рассеиваться равномерно по полусфера а освещенность диктоваться
 только плотность световой поток который обратно пропорциональный угол поток свет к поверхность или просто говорить все любимый мистер N dot
 L и тут начинать проявляться достоинство рейтрейсинг перед растеризация тень точка находиться в тень если она не видеть напрямую источник
 свет и это очень легко сделать с помощь рейтрейсинг достаточно лишь пускать луч в направление источник свет и посмотреть не
 попадаться ли мы что по путь если находить пересечение значит источник свет закрывать и мы в тень если же пересечение
 не быть значит мы мочь считать освещение для это при нахождение первичный пересечение мы нужно построить новый луч и вызывать
 traceNV еще раз для проверка видимость источник свет делать это можно и в Hit шейдер но рекомендоваться весь вызов traceNV
 производить в Raygen шейдер так как это позволять планировщик scheduler работать с максимальный эффективность еще один оптимизация использовать RayPayload как
 можно меньший размер а также специализированный Hit и Miss шейдер для теневой луч мы в качество RayPayload понадобиться всего один
 значение быть ли пересечение или нет соответственно в Hit шейдер мы быть отмечать что пересечение быть и в Miss шейдер
 что не быть давать дополнять наш код Raygen шейдер const vec3 hitColor PrimaryRay colorAndDist rgb const float hitDistance PrimaryRay colorAndDist
 w const vec3 hitNormal PrimaryRay normal xyz float lighting 1 0f if we hit something if hitDistance 0 0f const
 vec3 hitPos origin direction hitDistance const vec3 toLight normalize Params sunPosAndAmbient xyz const vec3 shadowRayOrigin hitPos hitNormal 0 01f const
 uint shadowRayFlags gl _ RayFlagsOpaqueNV gl _ RayFlagsTerminateOnFirstHitNV const uint shadowRecordOffset 1 const uint shadowMissIndex 1 traceNV Scene rayFlags cullMask
 shadowRecordOffset stbRecordStride shadowMissIndex shadowRayOrigin 0 0f toLight tmax SWS _ LOC _ SHADOW _ RAY if ShadowRay distance 0 0f
 lighting Params sunPosAndAmbient w else lighting max Params sunPosAndAmbient w dot hitNormal toLight замечать что для теневой луч мы указывать
 флаг gl _ RayFlagsTerminateOnFirstHitNV такой образ мы останавливать трассировка при первый же пересечение без поиск близкий ведь мы важный сам
 факт наличие пересечение такой образ мы проверять быть ли первичный пересечение или мы ударяться в небо если пересечение быть то
 восстанавливать координата точка пересечение ведь мы знать расстояние до точка пересечение от начальный точка луч получать направление на источник свет
 и вызывать traceNV указывать в качество шейдер наш специализированный теневой шейдер а также расположение PayLoad для теневой луч замечать что
 для задание отправной точка наш луч мы немного смещать она вдоль нормаль это сделать для избежание нежелательный самозатенение также для
 это можно использовать значение tmin отличный от ноль после это мы проверять быть ли пересечение и если не быть то
 считать освещение по модель ламберт если же пересечение быть то в качество освещение взять константный значение окружающий свет ambient light
 не смотря на простота этот модель благодаря наличие тень мы получать довольно симпатичный картинка часть 4 зеркало как вы уже
 мочь замечать рейтрейсинг это простой но в тот же время очень мощный инструмент с помощь простой механизм запуск луч и
 проверка результат пересечение можно реализовывать множество фич реализовать который с помощь растеризация или сложный или и вовсе невозможный давать рассматривать
 например отражение современный растерный рендеры научаться многий трюк для построение приемлемый отражение но весь они далекий от реалистичность и делать
 довольно много допущение с помощь рейтрейсинг мы мочь получать отражение очень легко достаточно простой отражать приходить луч и отслеживать его
 пересечение давать попробовать для начало определяться что отражать свойство у мы быть обладать чайник ведь он легко мочь быть хромированный
 для это мы в Hit шейдер быть записывать в RayPayload флаг означать попадать ли мы в чайник или нет так
 как я создавать сцена я знать что порядковый номер чайник 2 теперь все что мы нужно сделать в Raygen шейдер
 это проверять попадать ли мы в чайник и вместо теневой луч выпускать еще один первичный луч отражать направление текущий луч
 и использовать цвет в точка пересечение в качество отражение const float isTeapot PrimaryRay normal w if teapot let s reflect
 if isTeapot 0 0f const vec3 hitPos origin direction hitDistance hitNormal 0 01f const vec3 reflectedDir reflect direction hitNormal traceNV
 Scene rayFlags cullMask primaryRecordOffset stbRecordStride primaryMissIndex hitPos 0 0f reflectedDir tmax SWS _ LOC _ PRIMARY _ RAY мы использовать
 тот же RayPayload и тот же шейдер что и для первичный луч ведь мы по суть просто продолжать трассировка первичный
 луч теперь мы мочь наслаждаться вид хромированный чайник как вы наверное мочь замечать отражение на наш чайник какой то странный
 на отражение пол нет тень а также боковой и верхний ручка чайник отражаться текстурированный это происходить потому что после нахождение
 пересечение отраженный луч мы просто забирать получаться цвет и на этот останавливаться во первый мы как минимум нужно рассчитать освещение
 в точка пересечение а во второй если мы снова попадать в зеркальный поверхность то нужно отражать луч и продолжать трассировка
 попробовать поставлять два зеркало напротив друг друг и вы увидеть бесконечный отражение мы себя конечно же бесконечный отражение позволять не
 мочь но как минимум несколько уровень отражение вполне мочь осиливать часть 5 зацикливаться весь мы знать что рекурсия это плохо
 но рекурсия на GPU еще худо и хоть Vulkan Raytracing и предоставлять мы возможность для организация рекурсивный трассировка производительность ради
 стоить она по возможность избегать в наш случай вполне можно обходиться и обычный цикл на каждый итерация мы трассировать луч
 проверять куда попадать и решать если попадать в небо прерывать цикл если попадать в чайник строить отраженный луч и продолжать
 если попадать оставаться часть сцена считать освещение и прерывать цикл императивный путь я подбирать максимальный количество итерация равный 10 это
 позволять иметь достаточный количество переотражение чтобы создавать правдоподобный картинка при это сохранять хороший производительность изменять наш шейдер в соответствие с
 излагать алгоритм vec3 finalColor vec3 0 0f for int i 0 i SWS _ MAX _ RECURSION i traceNV Scene
 rayFlags cullMask primaryRecordOffset stbRecordStride primaryMissIndex origin tmin direction tmax SWS _ LOC _ PRIMARY _ RAY const vec3 hitColor PrimaryRay
 colorAndDist rgb const float hitDistance PrimaryRay colorAndDist w if hit background quit if hitDistance 0 0f finalColor hitColor break else
 const vec3 hitNormal PrimaryRay normal xyz const float isTeapot PrimaryRay normal w const vec3 hitPos origin direction hitDistance if isTeapot
 0 0f our teapot is mirror so continue origin hitPos hitNormal 0 01f direction reflect direction hitNormal else we hit
 diffuse primitive simple lambertian const vec3 toLight normalize Params sunPosAndAmbient xyz const vec3 shadowRayOrigin hitPos hitNormal 0 01f traceNV Scene
 rayFlags cullMask shadowRecordOffset stbRecordStride shadowMissIndex shadowRayOrigin 0 0f toLight tmax SWS _ LOC _ SHADOW _ RAY const float lighting
 ShadowRay distance 0 0f Params sunPosAndAmbient w max Params sunPosAndAmbient w dot hitNormal toLight finalColor hitColor lighting break результат правдоподобный
 отражение часть 6 стекло и финал наш рейтрейсер начинать обретать черта взрослый трассировщик теперь иметь на рука универсальный цикл трассировка
 мы мочь расширять функционал добавлять новый материал и более реалистичный модель освещение довольно небольшой изменение можно получать полноценный трассировщик путь
 path tracer для расчет реалистичный изображение давать напоследок добавлять еще один фич рейтрейсинг преломление вещь практически нереализуемый стандартный растеризация но
 благодаря наш цикл трассировка мы мочь легко получать реалистичный многоуровневый преломление давать сделать наш кролик стеклянный для этот вводить константа
 порядковый номер объект наш сцена и в шейдер пересечение быть записывать в RayPayload номер объект с который пересекаться const float
 objId float gl _ InstanceCustomIndexNV PrimaryRay normalAndObjId vec4 normal objId подбирать индекс преломление для наш кролик я выбирать обычный стекло
 с индекс преломление равный 1 52 так как функция refract принимать соотношение индекс преломление два среда а в наш случай
 это воздух стекло потому финальный значение равно 1 0 1 52 const float kBunnyRefractionIndex 1 0f 1 52f теперь добавлять
 в наш цикл проверка на попадание в кролик if objectId OBJECT _ ID _ TEAPOT our teapot is mirror so
 reflect and continue origin hitPos hitNormal 0 001f direction reflect direction hitNormal else if objectId OBJECT _ ID _ BUNNY
 our bunny is glass so refract and continue const float NdotD dot hitNormal direction const vec3 refrNormal NdotD 0 0f
 hitNormal hitNormal origin hitPos direction 0 001f direction refract direction refrNormal kBunnyRefractionIndex так как преломлять луч заходить внутрь объект мы
 нужно отслеживать это и переворачивать нормаль чтобы получать правильный результат преломление давать полюбоваться наш стеклянный кролик мы с вы проходить
 путь от разноцветный треугольник до сцена с несколько объект текстурированный и реализовать отражать и преломлять поверхность на этот основа уже
 можно строить более или менее серьезный рейтрейсер пастрейсер в следующий статья я постараться рассматривать гибридный рендеринг совмещать растеризация и рейтрейсинг
 исходный код к статья находиться здесь https github com iOrange rtxON tree Version _ 2 _ 2 график raytracing rtx
 Vulkan рейтрейсинг 18 ноябрь 2018 обновление 27 ной 2018 комментарий 60 убирать реклама контакт сообщество участник каталог сайт категория архив
 новость GameDev ru разработка игра 2001 2019   писать   простой   рейтрейсер   использовать   Vulkan   Raytracing   график   статья   программирование  
 игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   FAQ  
 страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект  
 форум   работа   входить   программированиестатьиграфика   писать   простой   рейтрейсер   использовать   Vulkan   Raytracing  
 автор   0r   ngE   все   привет   сегодня   я   рассказывать   вы   как  
 получать   результат   изображать   на   заглавный   картинка   к   этот   статья   использовать  
 Vulkan   Raytracing   часть   0   приветствие   часть   1   кролик   и   чайник  
 часть   2   камера   мотор   часть   2   сталь   и   мрамор   часть  
 3   да   быть   свет   часть   4   зеркало   часть   5   зацикливаться  
 часть   6   стекло   и   финал   часть   0   приветствие   в   прошлый  
 раз   мы   с   вы   рассматривать   что   же   из   себя   представлять  
 Vulkan   Ray   Tracing   и   как   с   он   работать   итог   тот  
 статья   становиться   простой   приложение   создавать   то   не   менее   сцена   пайплайн  
 шейдер   и   выводить   на   экран   результат   трассировка   луч   по   этот  
 сцена   и   хоть   наш   треугольник   и   получаться   на   порядок   реалистичный  
 растеризованный   все   же   хотеться   бы   увидеть   рейтрейсинг   во   весь   его  
 краса   ведь   не   зря   мы   потратить   деньги   на   RTX   видеокарта  
 именно   это   и   быть   посвящать   данный   статья   хотеться   бы   сразу  
 отмечать   цель   статья   показывать   как   использовать   Vulkan   для   построение   полноценный  
 рейтрейсер   показывать   основной   архитектурный   момент   и   давать   несколько   совет   по  
 написание   эффективный   шейдер   для   рейтрейсинг   часть   1   кролик   и   чайник  
 первый   дело   мы   понадобиться   сам   сцена   я   взять   на   себя  
 смелость   подготовить   переосмыслять   версия   классический   икона   рейтрейсинг   сцена   тернер   уиттед  
 зеркальный   и   стеклянный   шар   над   кусок   линолеум   в   наш   случай  
 сцена   называться   хромированный   чайник   и   стеклянный   кролик   на   мраморный   пол  
 модель   кролик   Stanford   Bunny   быть   позаимствовать   отсюда   https   casual   effects  
 com   g3d   data10   index   html   mesh3   модель   чайник   использоваться   тот  
 что   встраивать   в   3DS   Max   модель   пол   быть   мастерски   изготавливать  
 автор   статья   собственноручно   текстура   взять   с   сайт   https   texturehaven   com  
 для   загрузка   сцена   использоваться   библиотека   tinyobjloader   для   загрузка   текстура   использоваться  
 все   любимая   stb _ image   также   для   более   удобный   работа   со  
 сцена   и   ее   ресурс   быть   добавлять   вспомогательный   структура   RTAccelerationStructure   RTMesh  
 RTMaterial   RTScene   код   по   больший   часть   оставаться   без   изменение   только  
 вместо   один   Bottom   Level   Acceleration   Structure   BLAS   теперь   у   мы  
 они   несколько   а   соответственно   и   несколько   VkGeometryNV   и   VkGeometryInstance   важно  
 также   отмечать   что   поле   instanceId   каждый   инстанс   мы   теперь   присваивать  
 порядковый   номер   объект   в   сцена   это   помогать   мы   в   будущее  
 обращаться   к   его   атрибут   создавать   для   каждый   объект   сцена   свой  
 BLAS   и   instance   мы   строить   Top   Level   Acceleration   Sctructure   TLAS  
 наш   сцена   готовый   часть   2   камера   мотор   для   наш   треугольник  
 мы   хватать   ортографический   проекция   где   все   луч   идти   параллельно   чтобы  
 видеть   наш   новый   сцена   во   весь   ее   краса   мы   понадобиться  
 перспективный   камера   мы   не   быть   заниматься   моделирование   реальный   линза   а  
 останавливаться   на   простой   камера   обскура   pinhole   camera   в   такой   модель  
 камера   наш   луч   выходить   из   один   точка   позиция   наблюдатель   и  
 расходиться   образовывать   пирамида   формирование   луч   для   каждый   пиксел   наш   экран  
 в   такой   случай   являться   очень   простой   отправной   точка   это   всегда  
 позиция   наблюдатель   а   конечный   точка   проекция   на   дальний   плоскость   отсечение  
 основание   пирамида   я   добавлять   в   состав   фреймворок   класс   Camera   реализовать  
 весь   необходимый   мы   метод   и   позволять   управлять   камера   с   помощь  
 пользовательский   ввод   для   передача   параметр   камера   в   шейдер   использоваться   Uniform  
 Buffer   Object   UBO   следующий   содержание   struct   UniformParams   vec4   camPos   vec4  
 camDir   vec4   camUp   vec4   camSide   vec4   camNearFarFov   в   шейдер   же  
 для   построение   луч   быть   добавлять   функция   CalcRayDir   который   для   заданный  
 пиксел   экран   находить   необходимый   направление   луч   использовать   ориентация   камера   и  
 угол   обзор   теперь   же   если   запускать   наш   приложение   то   мы  
 увидеть   следующий   картина   теперь   вместо   один   цветной   треугольник   у   мы  
 на   экран   несколько   сотня   тысяча   цветной   треугольник   хвала   рейтрейсинг   часть  
 2   сталь   и   мрамор   разноцветный   треугольник   это   конечно   же   хорошо  
 но   как   насчет   текстура   к   счастие   текстурирование   треугольник   мало   чем  
 отличаться   от   таковой   в   растеризация   мы   все   так   же   нужный  
 текстурный   координата   каждый   вершина   треугольник   их   интерполировать   значение   для   интересовать  
 мы   пиксел   а   также   сам   текстура   и   сэмплер   sampler   для  
 интерполяция   текстурный   координата   а   также   любой   вершинный   атрибут   мы   и  
 пригождаться   тот   самый   барицентрический   координата   который   мы   и   выводить   до  
 сей   пора   но   где   же   мы   взять   вершинный   атрибут   для  
 растеризация   мы   складывать   вершинный   атрибут   в   вершинный   буфер   и   далее  
 конвейер   все   делать   за   мы   но   в   случай   рейтрейсинг   нужно  
 заниматься   это   сам   хороший   новость   в   то   что   это   совсем  
 не   сложный   для   передача   атрибут   в   шейдер   мы   пригождаться   Shader  
 Storage   Buffer   Object   SSBO   или   StructuredBuffer   в   термин   DirectX   складывать  
 вершинный   атрибут   в   SSBO   и   передавать   в   шейдер   вроде   ничто  
 сложный   но   как   узнавать   какой   именно   вершина   мы   нужный   для  
 начало   мы   нужно   узнавать   в   какой   именно   треугольник   мы   попадать  
 и   помогать   мы   в   это   gl _ PrimitiveID   который   содержать   порядковый  
 номер   треугольник   в   данный   объект   уже   хорошо   но   часто   все  
 наш   геометрия   индексировать   чтобы   избегать   дублирование   данные   а   значит   мы  
 понадобиться   также   индекс   который   мы   передавать   через   SSBO   итак   у  
 мы   быть   номер   треугольник   по   который   мы   мочь   прочитывать   индекс  
 с   помощь   который   мы   читать   вершинный   атрибут   проинтерполировать   который   мы  
 наконец   мочь   обращаться   к   текстура   но   как   мы   узнавать   к  
 какой   именно   для   это   мы   пригождаться   еще   один   SSBO   буфер  
 хранить   в   себя   индекс   текстура   для   каждый   треугольник   объект   для  
 чтение   из   он   мы   пригождаться   знакомый   уже   мы   gl _ PrimitiveID  
 итак   давать   записывать   какой   в   итог   буфер   мы   понадобиться   MaterialsIDs  
 SSBO   индекс   материал   для   каждый   треугольник   FacesBuffer   SSBO   индекс   вершина  
 AttribsBuffer   SSBO   вершинный   атрибут   Texture   sampler2D   текстура   но   ведь   у  
 мы   несколько   объект   в   сцена   как   быть   с   это   к  
 счастие   для   это   существовать   расширение   VK _ EXT _ descriptor _ indexing   добавлять  
 много   вкусности   и   послабление   для   дескриптор   но   самый   главное   для  
 мы   возможность   при   создание   разметка   набор   дескриптор   descriptor   set   layout  
 указывать   что   этот   самый   дескриптор   неопределенный   количество   такой   образ   мы  
 мочь   в   рантайм   решать   размерность   массив   передавать   ресурс   что   просто  
 идеально   для   наш   ситуация   разбирать   подробно   я   этот   расширение   не  
 быть   это   выходить   за   рамка   данный   статья   так   что   для  
 дальнейший   ознакомление   мочь   проходить   по   этот   ссылочка   https   www   khronos  
 org   registry   vulkan   specs   1   1   extensions   html   ptor _ indexing  
 помнить   как   мы   при   создание   инстанс   в   качество   id   указывать  
 порядковый   номер   объект   так   вот   он   то   мы   теперь   и  
 пригождаться   чтобы   брать   из   массив   нужный   буфер   для   это   мы  
 понадобиться   встроенный   переменная   gl _ InstanceCustomIndexNV   который   как   раз   и   содержать  
 тот   самый   значение   вот   так   быть   выглядеть   наш   код   текстурирование  
 const   vec3   barycentrics   vec3   1   0f   HitAttribs   x   HitAttribs   y  
 HitAttribs   x   HitAttribs   y   const   uint   matID   MatIDsArray   nonuniformEXT   gl _
 InstanceCustomIndexNV   MatIDs   gl _ PrimitiveID   const   uvec4   face   FacesArray   nonuniformEXT   gl _
 InstanceCustomIndexNV   Faces   gl _ PrimitiveID   VertexAttribute   v0   AttribsArray   nonuniformEXT   gl _ InstanceCustomIndexNV  
 VertexAttribs   int   face   x   VertexAttribute   v1   AttribsArray   nonuniformEXT   gl _ InstanceCustomIndexNV  
 VertexAttribs   int   face   y   VertexAttribute   v2   AttribsArray   nonuniformEXT   gl _ InstanceCustomIndexNV  
 VertexAttribs   int   face   z   const   vec2   uv   BaryLerp   v0   uv  
 xy   v1   uv   xy   v2   uv   xy   barycentrics   const   vec3  
 texel   textureLod   TexturesArray   nonuniformEXT   matID   uv   0   0f   rgb   как  
 видеть   все   оказываться   совсем   не   сложный   и   очень   даже   гибко  
 запускать   наш   приложение   и   увидеть   следующий   картинка   уже   намного   хорошо  
 но   что   то   не   хватать   ах   да   освещение   часть   3  
 да   быть   свет   давать   добавлять   простой   освещение   классика   компьютерный   график  
 диффузный   модель   освещение   ламберт   согласно   этот   модель   освещение   рассеиваться   равномерно  
 по   полусфера   а   освещенность   диктоваться   только   плотность   световой   поток   который  
 обратно   пропорциональный   угол   поток   свет   к   поверхность   или   просто   говорить  
 все   любимый   мистер   N   dot   L   и   тут   начинать   проявляться  
 достоинство   рейтрейсинг   перед   растеризация   тень   точка   находиться   в   тень   если  
 она   не   видеть   напрямую   источник   свет   и   это   очень   легко  
 сделать   с   помощь   рейтрейсинг   достаточно   лишь   пускать   луч   в   направление  
 источник   свет   и   посмотреть   не   попадаться   ли   мы   что   по  
 путь   если   находить   пересечение   значит   источник   свет   закрывать   и   мы  
 в   тень   если   же   пересечение   не   быть   значит   мы   мочь  
 считать   освещение   для   это   при   нахождение   первичный   пересечение   мы   нужно  
 построить   новый   луч   и   вызывать   traceNV   еще   раз   для   проверка  
 видимость   источник   свет   делать   это   можно   и   в   Hit   шейдер  
 но   рекомендоваться   весь   вызов   traceNV   производить   в   Raygen   шейдер   так  
 как   это   позволять   планировщик   scheduler   работать   с   максимальный   эффективность   еще  
 один   оптимизация   использовать   RayPayload   как   можно   меньший   размер   а   также  
 специализированный   Hit   и   Miss   шейдер   для   теневой   луч   мы   в  
 качество   RayPayload   понадобиться   всего   один   значение   быть   ли   пересечение   или  
 нет   соответственно   в   Hit   шейдер   мы   быть   отмечать   что   пересечение  
 быть   и   в   Miss   шейдер   что   не   быть   давать   дополнять  
 наш   код   Raygen   шейдер   const   vec3   hitColor   PrimaryRay   colorAndDist   rgb  
 const   float   hitDistance   PrimaryRay   colorAndDist   w   const   vec3   hitNormal   PrimaryRay  
 normal   xyz   float   lighting   1   0f   if   we   hit   something  
 if   hitDistance   0   0f   const   vec3   hitPos   origin   direction   hitDistance  
 const   vec3   toLight   normalize   Params   sunPosAndAmbient   xyz   const   vec3   shadowRayOrigin  
 hitPos   hitNormal   0   01f   const   uint   shadowRayFlags   gl _ RayFlagsOpaqueNV   gl _
 RayFlagsTerminateOnFirstHitNV   const   uint   shadowRecordOffset   1   const   uint   shadowMissIndex   1   traceNV  
 Scene   rayFlags   cullMask   shadowRecordOffset   stbRecordStride   shadowMissIndex   shadowRayOrigin   0   0f   toLight  
 tmax   SWS _ LOC _ SHADOW _ RAY   if   ShadowRay   distance   0   0f  
 lighting   Params   sunPosAndAmbient   w   else   lighting   max   Params   sunPosAndAmbient   w  
 dot   hitNormal   toLight   замечать   что   для   теневой   луч   мы   указывать  
 флаг   gl _ RayFlagsTerminateOnFirstHitNV   такой   образ   мы   останавливать   трассировка   при   первый  
 же   пересечение   без   поиск   близкий   ведь   мы   важный   сам   факт  
 наличие   пересечение   такой   образ   мы   проверять   быть   ли   первичный   пересечение  
 или   мы   ударяться   в   небо   если   пересечение   быть   то   восстанавливать  
 координата   точка   пересечение   ведь   мы   знать   расстояние   до   точка   пересечение  
 от   начальный   точка   луч   получать   направление   на   источник   свет   и  
 вызывать   traceNV   указывать   в   качество   шейдер   наш   специализированный   теневой   шейдер  
 а   также   расположение   PayLoad   для   теневой   луч   замечать   что   для  
 задание   отправной   точка   наш   луч   мы   немного   смещать   она   вдоль  
 нормаль   это   сделать   для   избежание   нежелательный   самозатенение   также   для   это  
 можно   использовать   значение   tmin   отличный   от   ноль   после   это   мы  
 проверять   быть   ли   пересечение   и   если   не   быть   то   считать  
 освещение   по   модель   ламберт   если   же   пересечение   быть   то   в  
 качество   освещение   взять   константный   значение   окружающий   свет   ambient   light   не  
 смотря   на   простота   этот   модель   благодаря   наличие   тень   мы   получать  
 довольно   симпатичный   картинка   часть   4   зеркало   как   вы   уже   мочь  
 замечать   рейтрейсинг   это   простой   но   в   тот   же   время   очень  
 мощный   инструмент   с   помощь   простой   механизм   запуск   луч   и   проверка  
 результат   пересечение   можно   реализовывать   множество   фич   реализовать   который   с   помощь  
 растеризация   или   сложный   или   и   вовсе   невозможный   давать   рассматривать   например  
 отражение   современный   растерный   рендеры   научаться   многий   трюк   для   построение   приемлемый  
 отражение   но   весь   они   далекий   от   реалистичность   и   делать   довольно  
 много   допущение   с   помощь   рейтрейсинг   мы   мочь   получать   отражение   очень  
 легко   достаточно   простой   отражать   приходить   луч   и   отслеживать   его   пересечение  
 давать   попробовать   для   начало   определяться   что   отражать   свойство   у   мы  
 быть   обладать   чайник   ведь   он   легко   мочь   быть   хромированный   для  
 это   мы   в   Hit   шейдер   быть   записывать   в   RayPayload   флаг  
 означать   попадать   ли   мы   в   чайник   или   нет   так   как  
 я   создавать   сцена   я   знать   что   порядковый   номер   чайник   2  
 теперь   все   что   мы   нужно   сделать   в   Raygen   шейдер   это  
 проверять   попадать   ли   мы   в   чайник   и   вместо   теневой   луч  
 выпускать   еще   один   первичный   луч   отражать   направление   текущий   луч   и  
 использовать   цвет   в   точка   пересечение   в   качество   отражение   const   float  
 isTeapot   PrimaryRay   normal   w   if   teapot   let   s   reflect   if  
 isTeapot   0   0f   const   vec3   hitPos   origin   direction   hitDistance   hitNormal  
 0   01f   const   vec3   reflectedDir   reflect   direction   hitNormal   traceNV   Scene  
 rayFlags   cullMask   primaryRecordOffset   stbRecordStride   primaryMissIndex   hitPos   0   0f   reflectedDir   tmax  
 SWS _ LOC _ PRIMARY _ RAY   мы   использовать   тот   же   RayPayload   и  
 тот   же   шейдер   что   и   для   первичный   луч   ведь   мы  
 по   суть   просто   продолжать   трассировка   первичный   луч   теперь   мы   мочь  
 наслаждаться   вид   хромированный   чайник   как   вы   наверное   мочь   замечать   отражение  
 на   наш   чайник   какой   то   странный   на   отражение   пол   нет  
 тень   а   также   боковой   и   верхний   ручка   чайник   отражаться   текстурированный  
 это   происходить   потому   что   после   нахождение   пересечение   отраженный   луч   мы  
 просто   забирать   получаться   цвет   и   на   этот   останавливаться   во   первый  
 мы   как   минимум   нужно   рассчитать   освещение   в   точка   пересечение   а  
 во   второй   если   мы   снова   попадать   в   зеркальный   поверхность   то  
 нужно   отражать   луч   и   продолжать   трассировка   попробовать   поставлять   два   зеркало  
 напротив   друг   друг   и   вы   увидеть   бесконечный   отражение   мы   себя  
 конечно   же   бесконечный   отражение   позволять   не   мочь   но   как   минимум  
 несколько   уровень   отражение   вполне   мочь   осиливать   часть   5   зацикливаться   весь  
 мы   знать   что   рекурсия   это   плохо   но   рекурсия   на   GPU  
 еще   худо   и   хоть   Vulkan   Raytracing   и   предоставлять   мы   возможность  
 для   организация   рекурсивный   трассировка   производительность   ради   стоить   она   по   возможность  
 избегать   в   наш   случай   вполне   можно   обходиться   и   обычный   цикл  
 на   каждый   итерация   мы   трассировать   луч   проверять   куда   попадать   и  
 решать   если   попадать   в   небо   прерывать   цикл   если   попадать   в  
 чайник   строить   отраженный   луч   и   продолжать   если   попадать   оставаться   часть  
 сцена   считать   освещение   и   прерывать   цикл   императивный   путь   я   подбирать  
 максимальный   количество   итерация   равный   10   это   позволять   иметь   достаточный   количество  
 переотражение   чтобы   создавать   правдоподобный   картинка   при   это   сохранять   хороший   производительность  
 изменять   наш   шейдер   в   соответствие   с   излагать   алгоритм   vec3   finalColor  
 vec3   0   0f   for   int   i   0   i   SWS _ MAX _
 RECURSION   i   traceNV   Scene   rayFlags   cullMask   primaryRecordOffset   stbRecordStride   primaryMissIndex   origin  
 tmin   direction   tmax   SWS _ LOC _ PRIMARY _ RAY   const   vec3   hitColor  
 PrimaryRay   colorAndDist   rgb   const   float   hitDistance   PrimaryRay   colorAndDist   w   if  
 hit   background   quit   if   hitDistance   0   0f   finalColor   hitColor   break  
 else   const   vec3   hitNormal   PrimaryRay   normal   xyz   const   float   isTeapot  
 PrimaryRay   normal   w   const   vec3   hitPos   origin   direction   hitDistance   if  
 isTeapot   0   0f   our   teapot   is   mirror   so   continue   origin  
 hitPos   hitNormal   0   01f   direction   reflect   direction   hitNormal   else   we  
 hit   diffuse   primitive   simple   lambertian   const   vec3   toLight   normalize   Params  
 sunPosAndAmbient   xyz   const   vec3   shadowRayOrigin   hitPos   hitNormal   0   01f   traceNV  
 Scene   rayFlags   cullMask   shadowRecordOffset   stbRecordStride   shadowMissIndex   shadowRayOrigin   0   0f   toLight  
 tmax   SWS _ LOC _ SHADOW _ RAY   const   float   lighting   ShadowRay   distance  
 0   0f   Params   sunPosAndAmbient   w   max   Params   sunPosAndAmbient   w   dot  
 hitNormal   toLight   finalColor   hitColor   lighting   break   результат   правдоподобный   отражение   часть  
 6   стекло   и   финал   наш   рейтрейсер   начинать   обретать   черта   взрослый  
 трассировщик   теперь   иметь   на   рука   универсальный   цикл   трассировка   мы   мочь  
 расширять   функционал   добавлять   новый   материал   и   более   реалистичный   модель   освещение  
 довольно   небольшой   изменение   можно   получать   полноценный   трассировщик   путь   path   tracer  
 для   расчет   реалистичный   изображение   давать   напоследок   добавлять   еще   один   фич  
 рейтрейсинг   преломление   вещь   практически   нереализуемый   стандартный   растеризация   но   благодаря   наш  
 цикл   трассировка   мы   мочь   легко   получать   реалистичный   многоуровневый   преломление   давать  
 сделать   наш   кролик   стеклянный   для   этот   вводить   константа   порядковый   номер  
 объект   наш   сцена   и   в   шейдер   пересечение   быть   записывать   в  
 RayPayload   номер   объект   с   который   пересекаться   const   float   objId   float  
 gl _ InstanceCustomIndexNV   PrimaryRay   normalAndObjId   vec4   normal   objId   подбирать   индекс   преломление  
 для   наш   кролик   я   выбирать   обычный   стекло   с   индекс   преломление  
 равный   1   52   так   как   функция   refract   принимать   соотношение   индекс  
 преломление   два   среда   а   в   наш   случай   это   воздух   стекло  
 потому   финальный   значение   равно   1   0   1   52   const   float  
 kBunnyRefractionIndex   1   0f   1   52f   теперь   добавлять   в   наш   цикл  
 проверка   на   попадание   в   кролик   if   objectId   OBJECT _ ID _ TEAPOT  
 our   teapot   is   mirror   so   reflect   and   continue   origin   hitPos  
 hitNormal   0   001f   direction   reflect   direction   hitNormal   else   if   objectId  
 OBJECT _ ID _ BUNNY   our   bunny   is   glass   so   refract   and  
 continue   const   float   NdotD   dot   hitNormal   direction   const   vec3   refrNormal  
 NdotD   0   0f   hitNormal   hitNormal   origin   hitPos   direction   0   001f  
 direction   refract   direction   refrNormal   kBunnyRefractionIndex   так   как   преломлять   луч   заходить  
 внутрь   объект   мы   нужно   отслеживать   это   и   переворачивать   нормаль   чтобы  
 получать   правильный   результат   преломление   давать   полюбоваться   наш   стеклянный   кролик   мы  
 с   вы   проходить   путь   от   разноцветный   треугольник   до   сцена   с  
 несколько   объект   текстурированный   и   реализовать   отражать   и   преломлять   поверхность   на  
 этот   основа   уже   можно   строить   более   или   менее   серьезный   рейтрейсер  
 пастрейсер   в   следующий   статья   я   постараться   рассматривать   гибридный   рендеринг   совмещать  
 растеризация   и   рейтрейсинг   исходный   код   к   статья   находиться   здесь   https  
 github   com   iOrange   rtxON   tree   Version _ 2 _ 2   график   raytracing  
 rtx   Vulkan   рейтрейсинг   18   ноябрь   2018   обновление   27   ной   2018  
 комментарий   60   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория  
 архив   новость   GameDev   ru   разработка   игра   2001   2019   писать   простой   рейтрейсер   использовать   Vulkan   Raytracing   график   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   FAQ   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиграфика   писать   простой   рейтрейсер   использовать   Vulkan   Raytracing   автор   0r   ngE   все   привет   сегодня   я   рассказывать   вы   как   получать   результат   изображать   на   заглавный   картинка   к   этот   статья   использовать   Vulkan   Raytracing   часть   0   приветствие   часть   1   кролик   и   чайник   часть   2   камера   мотор   часть   2   сталь   и   мрамор   часть   3   да   быть   свет   часть   4   зеркало   часть   5   зацикливаться   часть   6   стекло   и   финал   часть   0   приветствие   в   прошлый   раз   мы   с   вы   рассматривать   что   же   из   себя   представлять   Vulkan   Ray   Tracing   и   как   с   он   работать   итог   тот   статья   становиться   простой   приложение   создавать   то   не   менее   сцена   пайплайн   шейдер   и   выводить   на   экран   результат   трассировка   луч   по   этот   сцена   и   хоть   наш   треугольник   и   получаться   на   порядок   реалистичный   растеризованный   все   же   хотеться   бы   увидеть   рейтрейсинг   во   весь   его   краса   ведь   не   зря   мы   потратить   деньги   на   RTX   видеокарта   именно   это   и   быть   посвящать   данный   статья   хотеться   бы   сразу   отмечать   цель   статья   показывать   как   использовать   Vulkan   для   построение   полноценный   рейтрейсер   показывать   основной   архитектурный   момент   и   давать   несколько   совет   по   написание   эффективный   шейдер   для   рейтрейсинг   часть   1   кролик   и   чайник   первый   дело   мы   понадобиться   сам   сцена   я   взять   на   себя   смелость   подготовить   переосмыслять   версия   классический   икона   рейтрейсинг   сцена   тернер   уиттед   зеркальный   и   стеклянный   шар   над   кусок   линолеум   в   наш   случай   сцена   называться   хромированный   чайник   и   стеклянный   кролик   на   мраморный   пол   модель   кролик   Stanford   Bunny   быть   позаимствовать   отсюда   https   casual   effects   com   g3d   data10   index   html   mesh3   модель   чайник   использоваться   тот   что   встраивать   в   3DS   Max   модель   пол   быть   мастерски   изготавливать   автор   статья   собственноручно   текстура   взять   с   сайт   https   texturehaven   com   для   загрузка   сцена   использоваться   библиотека   tinyobjloader   для   загрузка   текстура   использоваться   все   любимая   stb _ image   также   для   более   удобный   работа   со   сцена   и   ее   ресурс   быть   добавлять   вспомогательный   структура   RTAccelerationStructure   RTMesh   RTMaterial   RTScene   код   по   больший   часть   оставаться   без   изменение   только   вместо   один   Bottom   Level   Acceleration   Structure   BLAS   теперь   у   мы   они   несколько   а   соответственно   и   несколько   VkGeometryNV   и   VkGeometryInstance   важно   также   отмечать   что   поле   instanceId   каждый   инстанс   мы   теперь   присваивать   порядковый   номер   объект   в   сцена   это   помогать   мы   в   будущее   обращаться   к   его   атрибут   создавать   для   каждый   объект   сцена   свой   BLAS   и   instance   мы   строить   Top   Level   Acceleration   Sctructure   TLAS   наш   сцена   готовый   часть   2   камера   мотор   для   наш   треугольник   мы   хватать   ортографический   проекция   где   все   луч   идти   параллельно   чтобы   видеть   наш   новый   сцена   во   весь   ее   краса   мы   понадобиться   перспективный   камера   мы   не   быть   заниматься   моделирование   реальный   линза   а   останавливаться   на   простой   камера   обскура   pinhole   camera   в   такой   модель   камера   наш   луч   выходить   из   один   точка   позиция   наблюдатель   и   расходиться   образовывать   пирамида   формирование   луч   для   каждый   пиксел   наш   экран   в   такой   случай   являться   очень   простой   отправной   точка   это   всегда   позиция   наблюдатель   а   конечный   точка   проекция   на   дальний   плоскость   отсечение   основание   пирамида   я   добавлять   в   состав   фреймворок   класс   Camera   реализовать   весь   необходимый   мы   метод   и   позволять   управлять   камера   с   помощь   пользовательский   ввод   для   передача   параметр   камера   в   шейдер   использоваться   Uniform   Buffer   Object   UBO   следующий   содержание   struct   UniformParams   vec4   camPos   vec4   camDir   vec4   camUp   vec4   camSide   vec4   camNearFarFov   в   шейдер   же   для   построение   луч   быть   добавлять   функция   CalcRayDir   который   для   заданный   пиксел   экран   находить   необходимый   направление   луч   использовать   ориентация   камера   и   угол   обзор   теперь   же   если   запускать   наш   приложение   то   мы   увидеть   следующий   картина   теперь   вместо   один   цветной   треугольник   у   мы   на   экран   несколько   сотня   тысяча   цветной   треугольник   хвала   рейтрейсинг   часть   2   сталь   и   мрамор   разноцветный   треугольник   это   конечно   же   хорошо   но   как   насчет   текстура   к   счастие   текстурирование   треугольник   мало   чем   отличаться   от   таковой   в   растеризация   мы   все   так   же   нужный   текстурный   координата   каждый   вершина   треугольник   их   интерполировать   значение   для   интересовать   мы   пиксел   а   также   сам   текстура   и   сэмплер   sampler   для   интерполяция   текстурный   координата   а   также   любой   вершинный   атрибут   мы   и   пригождаться   тот   самый   барицентрический   координата   который   мы   и   выводить   до   сей   пора   но   где   же   мы   взять   вершинный   атрибут   для   растеризация   мы   складывать   вершинный   атрибут   в   вершинный   буфер   и   далее   конвейер   все   делать   за   мы   но   в   случай   рейтрейсинг   нужно   заниматься   это   сам   хороший   новость   в   то   что   это   совсем   не   сложный   для   передача   атрибут   в   шейдер   мы   пригождаться   Shader   Storage   Buffer   Object   SSBO   или   StructuredBuffer   в   термин   DirectX   складывать   вершинный   атрибут   в   SSBO   и   передавать   в   шейдер   вроде   ничто   сложный   но   как   узнавать   какой   именно   вершина   мы   нужный   для   начало   мы   нужно   узнавать   в   какой   именно   треугольник   мы   попадать   и   помогать   мы   в   это   gl _ PrimitiveID   который   содержать   порядковый   номер   треугольник   в   данный   объект   уже   хорошо   но   часто   все   наш   геометрия   индексировать   чтобы   избегать   дублирование   данные   а   значит   мы   понадобиться   также   индекс   который   мы   передавать   через   SSBO   итак   у   мы   быть   номер   треугольник   по   который   мы   мочь   прочитывать   индекс   с   помощь   который   мы   читать   вершинный   атрибут   проинтерполировать   который   мы   наконец   мочь   обращаться   к   текстура   но   как   мы   узнавать   к   какой   именно   для   это   мы   пригождаться   еще   один   SSBO   буфер   хранить   в   себя   индекс   текстура   для   каждый   треугольник   объект   для   чтение   из   он   мы   пригождаться   знакомый   уже   мы   gl _ PrimitiveID   итак   давать   записывать   какой   в   итог   буфер   мы   понадобиться   MaterialsIDs   SSBO   индекс   материал   для   каждый   треугольник   FacesBuffer   SSBO   индекс   вершина   AttribsBuffer   SSBO   вершинный   атрибут   Texture   sampler2D   текстура   но   ведь   у   мы   несколько   объект   в   сцена   как   быть   с   это   к   счастие   для   это   существовать   расширение   VK _ EXT _ descriptor _ indexing   добавлять   много   вкусности   и   послабление   для   дескриптор   но   самый   главное   для   мы   возможность   при   создание   разметка   набор   дескриптор   descriptor   set   layout   указывать   что   этот   самый   дескриптор   неопределенный   количество   такой   образ   мы   мочь   в   рантайм   решать   размерность   массив   передавать   ресурс   что   просто   идеально   для   наш   ситуация   разбирать   подробно   я   этот   расширение   не   быть   это   выходить   за   рамка   данный   статья   так   что   для   дальнейший   ознакомление   мочь   проходить   по   этот   ссылочка   https   www   khronos   org   registry   vulkan   specs   1   1   extensions   html   ptor _ indexing   помнить   как   мы   при   создание   инстанс   в   качество   id   указывать   порядковый   номер   объект   так   вот   он   то   мы   теперь   и   пригождаться   чтобы   брать   из   массив   нужный   буфер   для   это   мы   понадобиться   встроенный   переменная   gl _ InstanceCustomIndexNV   который   как   раз   и   содержать   тот   самый   значение   вот   так   быть   выглядеть   наш   код   текстурирование   const   vec3   barycentrics   vec3   1   0f   HitAttribs   x   HitAttribs   y   HitAttribs   x   HitAttribs   y   const   uint   matID   MatIDsArray   nonuniformEXT   gl _ InstanceCustomIndexNV   MatIDs   gl _ PrimitiveID   const   uvec4   face   FacesArray   nonuniformEXT   gl _ InstanceCustomIndexNV   Faces   gl _ PrimitiveID   VertexAttribute   v0   AttribsArray   nonuniformEXT   gl _ InstanceCustomIndexNV   VertexAttribs   int   face   x   VertexAttribute   v1   AttribsArray   nonuniformEXT   gl _ InstanceCustomIndexNV   VertexAttribs   int   face   y   VertexAttribute   v2   AttribsArray   nonuniformEXT   gl _ InstanceCustomIndexNV   VertexAttribs   int   face   z   const   vec2   uv   BaryLerp   v0   uv   xy   v1   uv   xy   v2   uv   xy   barycentrics   const   vec3   texel   textureLod   TexturesArray   nonuniformEXT   matID   uv   0   0f   rgb   как   видеть   все   оказываться   совсем   не   сложный   и   очень   даже   гибко   запускать   наш   приложение   и   увидеть   следующий   картинка   уже   намного   хорошо   но   что   то   не   хватать   ах   да   освещение   часть   3   да   быть   свет   давать   добавлять   простой   освещение   классика   компьютерный   график   диффузный   модель   освещение   ламберт   согласно   этот   модель   освещение   рассеиваться   равномерно   по   полусфера   а   освещенность   диктоваться   только   плотность   световой   поток   который   обратно   пропорциональный   угол   поток   свет   к   поверхность   или   просто   говорить   все   любимый   мистер   N   dot   L   и   тут   начинать   проявляться   достоинство   рейтрейсинг   перед   растеризация   тень   точка   находиться   в   тень   если   она   не   видеть   напрямую   источник   свет   и   это   очень   легко   сделать   с   помощь   рейтрейсинг   достаточно   лишь   пускать   луч   в   направление   источник   свет   и   посмотреть   не   попадаться   ли   мы   что   по   путь   если   находить   пересечение   значит   источник   свет   закрывать   и   мы   в   тень   если   же   пересечение   не   быть   значит   мы   мочь   считать   освещение   для   это   при   нахождение   первичный   пересечение   мы   нужно   построить   новый   луч   и   вызывать   traceNV   еще   раз   для   проверка   видимость   источник   свет   делать   это   можно   и   в   Hit   шейдер   но   рекомендоваться   весь   вызов   traceNV   производить   в   Raygen   шейдер   так   как   это   позволять   планировщик   scheduler   работать   с   максимальный   эффективность   еще   один   оптимизация   использовать   RayPayload   как   можно   меньший   размер   а   также   специализированный   Hit   и   Miss   шейдер   для   теневой   луч   мы   в   качество   RayPayload   понадобиться   всего   один   значение   быть   ли   пересечение   или   нет   соответственно   в   Hit   шейдер   мы   быть   отмечать   что   пересечение   быть   и   в   Miss   шейдер   что   не   быть   давать   дополнять   наш   код   Raygen   шейдер   const   vec3   hitColor   PrimaryRay   colorAndDist   rgb   const   float   hitDistance   PrimaryRay   colorAndDist   w   const   vec3   hitNormal   PrimaryRay   normal   xyz   float   lighting   1   0f   if   we   hit   something   if   hitDistance   0   0f   const   vec3   hitPos   origin   direction   hitDistance   const   vec3   toLight   normalize   Params   sunPosAndAmbient   xyz   const   vec3   shadowRayOrigin   hitPos   hitNormal   0   01f   const   uint   shadowRayFlags   gl _ RayFlagsOpaqueNV   gl _ RayFlagsTerminateOnFirstHitNV   const   uint   shadowRecordOffset   1   const   uint   shadowMissIndex   1   traceNV   Scene   rayFlags   cullMask   shadowRecordOffset   stbRecordStride   shadowMissIndex   shadowRayOrigin   0   0f   toLight   tmax   SWS _ LOC _ SHADOW _ RAY   if   ShadowRay   distance   0   0f   lighting   Params   sunPosAndAmbient   w   else   lighting   max   Params   sunPosAndAmbient   w   dot   hitNormal   toLight   замечать   что   для   теневой   луч   мы   указывать   флаг   gl _ RayFlagsTerminateOnFirstHitNV   такой   образ   мы   останавливать   трассировка   при   первый   же   пересечение   без   поиск   близкий   ведь   мы   важный   сам   факт   наличие   пересечение   такой   образ   мы   проверять   быть   ли   первичный   пересечение   или   мы   ударяться   в   небо   если   пересечение   быть   то   восстанавливать   координата   точка   пересечение   ведь   мы   знать   расстояние   до   точка   пересечение   от   начальный   точка   луч   получать   направление   на   источник   свет   и   вызывать   traceNV   указывать   в   качество   шейдер   наш   специализированный   теневой   шейдер   а   также   расположение   PayLoad   для   теневой   луч   замечать   что   для   задание   отправной   точка   наш   луч   мы   немного   смещать   она   вдоль   нормаль   это   сделать   для   избежание   нежелательный   самозатенение   также   для   это   можно   использовать   значение   tmin   отличный   от   ноль   после   это   мы   проверять   быть   ли   пересечение   и   если   не   быть   то   считать   освещение   по   модель   ламберт   если   же   пересечение   быть   то   в   качество   освещение   взять   константный   значение   окружающий   свет   ambient   light   не   смотря   на   простота   этот   модель   благодаря   наличие   тень   мы   получать   довольно   симпатичный   картинка   часть   4   зеркало   как   вы   уже   мочь   замечать   рейтрейсинг   это   простой   но   в   тот   же   время   очень   мощный   инструмент   с   помощь   простой   механизм   запуск   луч   и   проверка   результат   пересечение   можно   реализовывать   множество   фич   реализовать   который   с   помощь   растеризация   или   сложный   или   и   вовсе   невозможный   давать   рассматривать   например   отражение   современный   растерный   рендеры   научаться   многий   трюк   для   построение   приемлемый   отражение   но   весь   они   далекий   от   реалистичность   и   делать   довольно   много   допущение   с   помощь   рейтрейсинг   мы   мочь   получать   отражение   очень   легко   достаточно   простой   отражать   приходить   луч   и   отслеживать   его   пересечение   давать   попробовать   для   начало   определяться   что   отражать   свойство   у   мы   быть   обладать   чайник   ведь   он   легко   мочь   быть   хромированный   для   это   мы   в   Hit   шейдер   быть   записывать   в   RayPayload   флаг   означать   попадать   ли   мы   в   чайник   или   нет   так   как   я   создавать   сцена   я   знать   что   порядковый   номер   чайник   2   теперь   все   что   мы   нужно   сделать   в   Raygen   шейдер   это   проверять   попадать   ли   мы   в   чайник   и   вместо   теневой   луч   выпускать   еще   один   первичный   луч   отражать   направление   текущий   луч   и   использовать   цвет   в   точка   пересечение   в   качество   отражение   const   float   isTeapot   PrimaryRay   normal   w   if   teapot   let   s   reflect   if   isTeapot   0   0f   const   vec3   hitPos   origin   direction   hitDistance   hitNormal   0   01f   const   vec3   reflectedDir   reflect   direction   hitNormal   traceNV   Scene   rayFlags   cullMask   primaryRecordOffset   stbRecordStride   primaryMissIndex   hitPos   0   0f   reflectedDir   tmax   SWS _ LOC _ PRIMARY _ RAY   мы   использовать   тот   же   RayPayload   и   тот   же   шейдер   что   и   для   первичный   луч   ведь   мы   по   суть   просто   продолжать   трассировка   первичный   луч   теперь   мы   мочь   наслаждаться   вид   хромированный   чайник   как   вы   наверное   мочь   замечать   отражение   на   наш   чайник   какой   то   странный   на   отражение   пол   нет   тень   а   также   боковой   и   верхний   ручка   чайник   отражаться   текстурированный   это   происходить   потому   что   после   нахождение   пересечение   отраженный   луч   мы   просто   забирать   получаться   цвет   и   на   этот   останавливаться   во   первый   мы   как   минимум   нужно   рассчитать   освещение   в   точка   пересечение   а   во   второй   если   мы   снова   попадать   в   зеркальный   поверхность   то   нужно   отражать   луч   и   продолжать   трассировка   попробовать   поставлять   два   зеркало   напротив   друг   друг   и   вы   увидеть   бесконечный   отражение   мы   себя   конечно   же   бесконечный   отражение   позволять   не   мочь   но   как   минимум   несколько   уровень   отражение   вполне   мочь   осиливать   часть   5   зацикливаться   весь   мы   знать   что   рекурсия   это   плохо   но   рекурсия   на   GPU   еще   худо   и   хоть   Vulkan   Raytracing   и   предоставлять   мы   возможность   для   организация   рекурсивный   трассировка   производительность   ради   стоить   она   по   возможность   избегать   в   наш   случай   вполне   можно   обходиться   и   обычный   цикл   на   каждый   итерация   мы   трассировать   луч   проверять   куда   попадать   и   решать   если   попадать   в   небо   прерывать   цикл   если   попадать   в   чайник   строить   отраженный   луч   и   продолжать   если   попадать   оставаться   часть   сцена   считать   освещение   и   прерывать   цикл   императивный   путь   я   подбирать   максимальный   количество   итерация   равный   10   это   позволять   иметь   достаточный   количество   переотражение   чтобы   создавать   правдоподобный   картинка   при   это   сохранять   хороший   производительность   изменять   наш   шейдер   в   соответствие   с   излагать   алгоритм   vec3   finalColor   vec3   0   0f   for   int   i   0   i   SWS _ MAX _ RECURSION   i   traceNV   Scene   rayFlags   cullMask   primaryRecordOffset   stbRecordStride   primaryMissIndex   origin   tmin   direction   tmax   SWS _ LOC _ PRIMARY _ RAY   const   vec3   hitColor   PrimaryRay   colorAndDist   rgb   const   float   hitDistance   PrimaryRay   colorAndDist   w   if   hit   background   quit   if   hitDistance   0   0f   finalColor   hitColor   break   else   const   vec3   hitNormal   PrimaryRay   normal   xyz   const   float   isTeapot   PrimaryRay   normal   w   const   vec3   hitPos   origin   direction   hitDistance   if   isTeapot   0   0f   our   teapot   is   mirror   so   continue   origin   hitPos   hitNormal   0   01f   direction   reflect   direction   hitNormal   else   we   hit   diffuse   primitive   simple   lambertian   const   vec3   toLight   normalize   Params   sunPosAndAmbient   xyz   const   vec3   shadowRayOrigin   hitPos   hitNormal   0   01f   traceNV   Scene   rayFlags   cullMask   shadowRecordOffset   stbRecordStride   shadowMissIndex   shadowRayOrigin   0   0f   toLight   tmax   SWS _ LOC _ SHADOW _ RAY   const   float   lighting   ShadowRay   distance   0   0f   Params   sunPosAndAmbient   w   max   Params   sunPosAndAmbient   w   dot   hitNormal   toLight   finalColor   hitColor   lighting   break   результат   правдоподобный   отражение   часть   6   стекло   и   финал   наш   рейтрейсер   начинать   обретать   черта   взрослый   трассировщик   теперь   иметь   на   рука   универсальный   цикл   трассировка   мы   мочь   расширять   функционал   добавлять   новый   материал   и   более   реалистичный   модель   освещение   довольно   небольшой   изменение   можно   получать   полноценный   трассировщик   путь   path   tracer   для   расчет   реалистичный   изображение   давать   напоследок   добавлять   еще   один   фич   рейтрейсинг   преломление   вещь   практически   нереализуемый   стандартный   растеризация   но   благодаря   наш   цикл   трассировка   мы   мочь   легко   получать   реалистичный   многоуровневый   преломление   давать   сделать   наш   кролик   стеклянный   для   этот   вводить   константа   порядковый   номер   объект   наш   сцена   и   в   шейдер   пересечение   быть   записывать   в   RayPayload   номер   объект   с   который   пересекаться   const   float   objId   float   gl _ InstanceCustomIndexNV   PrimaryRay   normalAndObjId   vec4   normal   objId   подбирать   индекс   преломление   для   наш   кролик   я   выбирать   обычный   стекло   с   индекс   преломление   равный   1   52   так   как   функция   refract   принимать   соотношение   индекс   преломление   два   среда   а   в   наш   случай   это   воздух   стекло   потому   финальный   значение   равно   1   0   1   52   const   float   kBunnyRefractionIndex   1   0f   1   52f   теперь   добавлять   в   наш   цикл   проверка   на   попадание   в   кролик   if   objectId   OBJECT _ ID _ TEAPOT   our   teapot   is   mirror   so   reflect   and   continue   origin   hitPos   hitNormal   0   001f   direction   reflect   direction   hitNormal   else   if   objectId   OBJECT _ ID _ BUNNY   our   bunny   is   glass   so   refract   and   continue   const   float   NdotD   dot   hitNormal   direction   const   vec3   refrNormal   NdotD   0   0f   hitNormal   hitNormal   origin   hitPos   direction   0   001f   direction   refract   direction   refrNormal   kBunnyRefractionIndex   так   как   преломлять   луч   заходить   внутрь   объект   мы   нужно   отслеживать   это   и   переворачивать   нормаль   чтобы   получать   правильный   результат   преломление   давать   полюбоваться   наш   стеклянный   кролик   мы   с   вы   проходить   путь   от   разноцветный   треугольник   до   сцена   с   несколько   объект   текстурированный   и   реализовать   отражать   и   преломлять   поверхность   на   этот   основа   уже   можно   строить   более   или   менее   серьезный   рейтрейсер   пастрейсер   в   следующий   статья   я   постараться   рассматривать   гибридный   рендеринг   совмещать   растеризация   и   рейтрейсинг   исходный   код   к   статья   находиться   здесь   https   github   com   iOrange   rtxON   tree   Version _ 2 _ 2   график   raytracing   rtx   Vulkan   рейтрейсинг   18   ноябрь   2018   обновление   27   ной   2018   комментарий   60   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   GameDev   ru   разработка   игра   2001   2019   писать   простой   рейтрейсер   использовать   Vulkan   Raytracing   график   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   FAQ   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиграфика   писать   простой   рейтрейсер   использовать   Vulkan   Raytracing   автор   0r   ngE   все   привет   сегодня   я   рассказывать   вы   как   получать   результат   изображать   на   заглавный   картинка   к   этот   статья   использовать   Vulkan   Raytracing   часть   0   приветствие   часть   1   кролик   и   чайник   часть   2   камера   мотор   часть   2   сталь   и   мрамор   часть   3   да   быть   свет   часть   4   зеркало   часть   5   зацикливаться   часть   6   стекло   и   финал   часть   0   приветствие   в   прошлый   раз   мы   с   вы   рассматривать   что   же   из   себя   представлять   Vulkan   Ray   Tracing   и   как   с   он   работать   итог   тот   статья   становиться   простой   приложение   создавать   то   не   менее   сцена   пайплайн   шейдер   и   выводить   на   экран   результат   трассировка   луч   по   этот   сцена   и   хоть   наш   треугольник   и   получаться   на   порядок   реалистичный   растеризованный   все   же   хотеться   бы   увидеть   рейтрейсинг   во   весь   его   краса   ведь   не   зря   мы   потратить   деньги   на   RTX   видеокарта   именно   это   и   быть   посвящать   данный   статья   хотеться   бы   сразу   отмечать   цель   статья   показывать   как   использовать   Vulkan   для   построение   полноценный   рейтрейсер   показывать   основной   архитектурный   момент   и   давать   несколько   совет   по   написание   эффективный   шейдер   для   рейтрейсинг   часть   1   кролик   и   чайник   первый   дело   мы   понадобиться   сам   сцена   я   взять   на   себя   смелость   подготовить   переосмыслять   версия   классический   икона   рейтрейсинг   сцена   тернер   уиттед   зеркальный   и   стеклянный   шар   над   кусок   линолеум   в   наш   случай   сцена   называться   хромированный   чайник   и   стеклянный   кролик   на   мраморный   пол   модель   кролик   Stanford   Bunny   быть   позаимствовать   отсюда   https   casual   effects   com   g3d   data10   index   html   mesh3   модель   чайник   использоваться   тот   что   встраивать   в   3DS   Max   модель   пол   быть   мастерски   изготавливать   автор   статья   собственноручно   текстура   взять   с   сайт   https   texturehaven   com   для   загрузка   сцена   использоваться   библиотека   tinyobjloader   для   загрузка   текстура   использоваться   все   любимая   stb _ image   также   для   более   удобный   работа   со   сцена   и   ее   ресурс   быть   добавлять   вспомогательный   структура   RTAccelerationStructure   RTMesh   RTMaterial   RTScene   код   по   больший   часть   оставаться   без   изменение   только   вместо   один   Bottom   Level   Acceleration   Structure   BLAS   теперь   у   мы   они   несколько   а   соответственно   и   несколько   VkGeometryNV   и   VkGeometryInstance   важно   также   отмечать   что   поле   instanceId   каждый   инстанс   мы   теперь   присваивать   порядковый   номер   объект   в   сцена   это   помогать   мы   в   будущее   обращаться   к   его   атрибут   создавать   для   каждый   объект   сцена   свой   BLAS   и   instance   мы   строить   Top   Level   Acceleration   Sctructure   TLAS   наш   сцена   готовый   часть   2   камера   мотор   для   наш   треугольник   мы   хватать   ортографический   проекция   где   все   луч   идти   параллельно   чтобы   видеть   наш   новый   сцена   во   весь   ее   краса   мы   понадобиться   перспективный   камера   мы   не   быть   заниматься   моделирование   реальный   линза   а   останавливаться   на   простой   камера   обскура   pinhole   camera   в   такой   модель   камера   наш   луч   выходить   из   один   точка   позиция   наблюдатель   и   расходиться   образовывать   пирамида   формирование   луч   для   каждый   пиксел   наш   экран   в   такой   случай   являться   очень   простой   отправной   точка   это   всегда   позиция   наблюдатель   а   конечный   точка   проекция   на   дальний   плоскость   отсечение   основание   пирамида   я   добавлять   в   состав   фреймворок   класс   Camera   реализовать   весь   необходимый   мы   метод   и   позволять   управлять   камера   с   помощь   пользовательский   ввод   для   передача   параметр   камера   в   шейдер   использоваться   Uniform   Buffer   Object   UBO   следующий   содержание   struct   UniformParams   vec4   camPos   vec4   camDir   vec4   camUp   vec4   camSide   vec4   camNearFarFov   в   шейдер   же   для   построение   луч   быть   добавлять   функция   CalcRayDir   который   для   заданный   пиксел   экран   находить   необходимый   направление   луч   использовать   ориентация   камера   и   угол   обзор   теперь   же   если   запускать   наш   приложение   то   мы   увидеть   следующий   картина   теперь   вместо   один   цветной   треугольник   у   мы   на   экран   несколько   сотня   тысяча   цветной   треугольник   хвала   рейтрейсинг   часть   2   сталь   и   мрамор   разноцветный   треугольник   это   конечно   же   хорошо   но   как   насчет   текстура   к   счастие   текстурирование   треугольник   мало   чем   отличаться   от   таковой   в   растеризация   мы   все   так   же   нужный   текстурный   координата   каждый   вершина   треугольник   их   интерполировать   значение   для   интересовать   мы   пиксел   а   также   сам   текстура   и   сэмплер   sampler   для   интерполяция   текстурный   координата   а   также   любой   вершинный   атрибут   мы   и   пригождаться   тот   самый   барицентрический   координата   который   мы   и   выводить   до   сей   пора   но   где   же   мы   взять   вершинный   атрибут   для   растеризация   мы   складывать   вершинный   атрибут   в   вершинный   буфер   и   далее   конвейер   все   делать   за   мы   но   в   случай   рейтрейсинг   нужно   заниматься   это   сам   хороший   новость   в   то   что   это   совсем   не   сложный   для   передача   атрибут   в   шейдер   мы   пригождаться   Shader   Storage   Buffer   Object   SSBO   или   StructuredBuffer   в   термин   DirectX   складывать   вершинный   атрибут   в   SSBO   и   передавать   в   шейдер   вроде   ничто   сложный   но   как   узнавать   какой   именно   вершина   мы   нужный   для   начало   мы   нужно   узнавать   в   какой   именно   треугольник   мы   попадать   и   помогать   мы   в   это   gl _ PrimitiveID   который   содержать   порядковый   номер   треугольник   в   данный   объект   уже   хорошо   но   часто   все   наш   геометрия   индексировать   чтобы   избегать   дублирование   данные   а   значит   мы   понадобиться   также   индекс   который   мы   передавать   через   SSBO   итак   у   мы   быть   номер   треугольник   по   который   мы   мочь   прочитывать   индекс   с   помощь   который   мы   читать   вершинный   атрибут   проинтерполировать   который   мы   наконец   мочь   обращаться   к   текстура   но   как   мы   узнавать   к   какой   именно   для   это   мы   пригождаться   еще   один   SSBO   буфер   хранить   в   себя   индекс   текстура   для   каждый   треугольник   объект   для   чтение   из   он   мы   пригождаться   знакомый   уже   мы   gl _ PrimitiveID   итак   давать   записывать   какой   в   итог   буфер   мы   понадобиться   MaterialsIDs   SSBO   индекс   материал   для   каждый   треугольник   FacesBuffer   SSBO   индекс   вершина   AttribsBuffer   SSBO   вершинный   атрибут   Texture   sampler2D   текстура   но   ведь   у   мы   несколько   объект   в   сцена   как   быть   с   это   к   счастие   для   это   существовать   расширение   VK _ EXT _ descriptor _ indexing   добавлять   много   вкусности   и   послабление   для   дескриптор   но   самый   главное   для   мы   возможность   при   создание   разметка   набор   дескриптор   descriptor   set   layout   указывать   что   этот   самый   дескриптор   неопределенный   количество   такой   образ   мы   мочь   в   рантайм   решать   размерность   массив   передавать   ресурс   что   просто   идеально   для   наш   ситуация   разбирать   подробно   я   этот   расширение   не   быть   это   выходить   за   рамка   данный   статья   так   что   для   дальнейший   ознакомление   мочь   проходить   по   этот   ссылочка   https   www   khronos   org   registry   vulkan   specs   1   1   extensions   html   ptor _ indexing   помнить   как   мы   при   создание   инстанс   в   качество   id   указывать   порядковый   номер   объект   так   вот   он   то   мы   теперь   и   пригождаться   чтобы   брать   из   массив   нужный   буфер   для   это   мы   понадобиться   встроенный   переменная   gl _ InstanceCustomIndexNV   который   как   раз   и   содержать   тот   самый   значение   вот   так   быть   выглядеть   наш   код   текстурирование   const   vec3   barycentrics   vec3   1   0f   HitAttribs   x   HitAttribs   y   HitAttribs   x   HitAttribs   y   const   uint   matID   MatIDsArray   nonuniformEXT   gl _ InstanceCustomIndexNV   MatIDs   gl _ PrimitiveID   const   uvec4   face   FacesArray   nonuniformEXT   gl _ InstanceCustomIndexNV   Faces   gl _ PrimitiveID   VertexAttribute   v0   AttribsArray   nonuniformEXT   gl _ InstanceCustomIndexNV   VertexAttribs   int   face   x   VertexAttribute   v1   AttribsArray   nonuniformEXT   gl _ InstanceCustomIndexNV   VertexAttribs   int   face   y   VertexAttribute   v2   AttribsArray   nonuniformEXT   gl _ InstanceCustomIndexNV   VertexAttribs   int   face   z   const   vec2   uv   BaryLerp   v0   uv   xy   v1   uv   xy   v2   uv   xy   barycentrics   const   vec3   texel   textureLod   TexturesArray   nonuniformEXT   matID   uv   0   0f   rgb   как   видеть   все   оказываться   совсем   не   сложный   и   очень   даже   гибко   запускать   наш   приложение   и   увидеть   следующий   картинка   уже   намного   хорошо   но   что   то   не   хватать   ах   да   освещение   часть   3   да   быть   свет   давать   добавлять   простой   освещение   классика   компьютерный   график   диффузный   модель   освещение   ламберт   согласно   этот   модель   освещение   рассеиваться   равномерно   по   полусфера   а   освещенность   диктоваться   только   плотность   световой   поток   который   обратно   пропорциональный   угол   поток   свет   к   поверхность   или   просто   говорить   все   любимый   мистер   N   dot   L   и   тут   начинать   проявляться   достоинство   рейтрейсинг   перед   растеризация   тень   точка   находиться   в   тень   если   она   не   видеть   напрямую   источник   свет   и   это   очень   легко   сделать   с   помощь   рейтрейсинг   достаточно   лишь   пускать   луч   в   направление   источник   свет   и   посмотреть   не   попадаться   ли   мы   что   по   путь   если   находить   пересечение   значит   источник   свет   закрывать   и   мы   в   тень   если   же   пересечение   не   быть   значит   мы   мочь   считать   освещение   для   это   при   нахождение   первичный   пересечение   мы   нужно   построить   новый   луч   и   вызывать   traceNV   еще   раз   для   проверка   видимость   источник   свет   делать   это   можно   и   в   Hit   шейдер   но   рекомендоваться   весь   вызов   traceNV   производить   в   Raygen   шейдер   так   как   это   позволять   планировщик   scheduler   работать   с   максимальный   эффективность   еще   один   оптимизация   использовать   RayPayload   как   можно   меньший   размер   а   также   специализированный   Hit   и   Miss   шейдер   для   теневой   луч   мы   в   качество   RayPayload   понадобиться   всего   один   значение   быть   ли   пересечение   или   нет   соответственно   в   Hit   шейдер   мы   быть   отмечать   что   пересечение   быть   и   в   Miss   шейдер   что   не   быть   давать   дополнять   наш   код   Raygen   шейдер   const   vec3   hitColor   PrimaryRay   colorAndDist   rgb   const   float   hitDistance   PrimaryRay   colorAndDist   w   const   vec3   hitNormal   PrimaryRay   normal   xyz   float   lighting   1   0f   if   we   hit   something   if   hitDistance   0   0f   const   vec3   hitPos   origin   direction   hitDistance   const   vec3   toLight   normalize   Params   sunPosAndAmbient   xyz   const   vec3   shadowRayOrigin   hitPos   hitNormal   0   01f   const   uint   shadowRayFlags   gl _ RayFlagsOpaqueNV   gl _ RayFlagsTerminateOnFirstHitNV   const   uint   shadowRecordOffset   1   const   uint   shadowMissIndex   1   traceNV   Scene   rayFlags   cullMask   shadowRecordOffset   stbRecordStride   shadowMissIndex   shadowRayOrigin   0   0f   toLight   tmax   SWS _ LOC _ SHADOW _ RAY   if   ShadowRay   distance   0   0f   lighting   Params   sunPosAndAmbient   w   else   lighting   max   Params   sunPosAndAmbient   w   dot   hitNormal   toLight   замечать   что   для   теневой   луч   мы   указывать   флаг   gl _ RayFlagsTerminateOnFirstHitNV   такой   образ   мы   останавливать   трассировка   при   первый   же   пересечение   без   поиск   близкий   ведь   мы   важный   сам   факт   наличие   пересечение   такой   образ   мы   проверять   быть   ли   первичный   пересечение   или   мы   ударяться   в   небо   если   пересечение   быть   то   восстанавливать   координата   точка   пересечение   ведь   мы   знать   расстояние   до   точка   пересечение   от   начальный   точка   луч   получать   направление   на   источник   свет   и   вызывать   traceNV   указывать   в   качество   шейдер   наш   специализированный   теневой   шейдер   а   также   расположение   PayLoad   для   теневой   луч   замечать   что   для   задание   отправной   точка   наш   луч   мы   немного   смещать   она   вдоль   нормаль   это   сделать   для   избежание   нежелательный   самозатенение   также   для   это   можно   использовать   значение   tmin   отличный   от   ноль   после   это   мы   проверять   быть   ли   пересечение   и   если   не   быть   то   считать   освещение   по   модель   ламберт   если   же   пересечение   быть   то   в   качество   освещение   взять   константный   значение   окружающий   свет   ambient   light   не   смотря   на   простота   этот   модель   благодаря   наличие   тень   мы   получать   довольно   симпатичный   картинка   часть   4   зеркало   как   вы   уже   мочь   замечать   рейтрейсинг   это   простой   но   в   тот   же   время   очень   мощный   инструмент   с   помощь   простой   механизм   запуск   луч   и   проверка   результат   пересечение   можно   реализовывать   множество   фич   реализовать   который   с   помощь   растеризация   или   сложный   или   и   вовсе   невозможный   давать   рассматривать   например   отражение   современный   растерный   рендеры   научаться   многий   трюк   для   построение   приемлемый   отражение   но   весь   они   далекий   от   реалистичность   и   делать   довольно   много   допущение   с   помощь   рейтрейсинг   мы   мочь   получать   отражение   очень   легко   достаточно   простой   отражать   приходить   луч   и   отслеживать   его   пересечение   давать   попробовать   для   начало   определяться   что   отражать   свойство   у   мы   быть   обладать   чайник   ведь   он   легко   мочь   быть   хромированный   для   это   мы   в   Hit   шейдер   быть   записывать   в   RayPayload   флаг   означать   попадать   ли   мы   в   чайник   или   нет   так   как   я   создавать   сцена   я   знать   что   порядковый   номер   чайник   2   теперь   все   что   мы   нужно   сделать   в   Raygen   шейдер   это   проверять   попадать   ли   мы   в   чайник   и   вместо   теневой   луч   выпускать   еще   один   первичный   луч   отражать   направление   текущий   луч   и   использовать   цвет   в   точка   пересечение   в   качество   отражение   const   float   isTeapot   PrimaryRay   normal   w   if   teapot   let   s   reflect   if   isTeapot   0   0f   const   vec3   hitPos   origin   direction   hitDistance   hitNormal   0   01f   const   vec3   reflectedDir   reflect   direction   hitNormal   traceNV   Scene   rayFlags   cullMask   primaryRecordOffset   stbRecordStride   primaryMissIndex   hitPos   0   0f   reflectedDir   tmax   SWS _ LOC _ PRIMARY _ RAY   мы   использовать   тот   же   RayPayload   и   тот   же   шейдер   что   и   для   первичный   луч   ведь   мы   по   суть   просто   продолжать   трассировка   первичный   луч   теперь   мы   мочь   наслаждаться   вид   хромированный   чайник   как   вы   наверное   мочь   замечать   отражение   на   наш   чайник   какой   то   странный   на   отражение   пол   нет   тень   а   также   боковой   и   верхний   ручка   чайник   отражаться   текстурированный   это   происходить   потому   что   после   нахождение   пересечение   отраженный   луч   мы   просто   забирать   получаться   цвет   и   на   этот   останавливаться   во   первый   мы   как   минимум   нужно   рассчитать   освещение   в   точка   пересечение   а   во   второй   если   мы   снова   попадать   в   зеркальный   поверхность   то   нужно   отражать   луч   и   продолжать   трассировка   попробовать   поставлять   два   зеркало   напротив   друг   друг   и   вы   увидеть   бесконечный   отражение   мы   себя   конечно   же   бесконечный   отражение   позволять   не   мочь   но   как   минимум   несколько   уровень   отражение   вполне   мочь   осиливать   часть   5   зацикливаться   весь   мы   знать   что   рекурсия   это   плохо   но   рекурсия   на   GPU   еще   худо   и   хоть   Vulkan   Raytracing   и   предоставлять   мы   возможность   для   организация   рекурсивный   трассировка   производительность   ради   стоить   она   по   возможность   избегать   в   наш   случай   вполне   можно   обходиться   и   обычный   цикл   на   каждый   итерация   мы   трассировать   луч   проверять   куда   попадать   и   решать   если   попадать   в   небо   прерывать   цикл   если   попадать   в   чайник   строить   отраженный   луч   и   продолжать   если   попадать   оставаться   часть   сцена   считать   освещение   и   прерывать   цикл   императивный   путь   я   подбирать   максимальный   количество   итерация   равный   10   это   позволять   иметь   достаточный   количество   переотражение   чтобы   создавать   правдоподобный   картинка   при   это   сохранять   хороший   производительность   изменять   наш   шейдер   в   соответствие   с   излагать   алгоритм   vec3   finalColor   vec3   0   0f   for   int   i   0   i   SWS _ MAX _ RECURSION   i   traceNV   Scene   rayFlags   cullMask   primaryRecordOffset   stbRecordStride   primaryMissIndex   origin   tmin   direction   tmax   SWS _ LOC _ PRIMARY _ RAY   const   vec3   hitColor   PrimaryRay   colorAndDist   rgb   const   float   hitDistance   PrimaryRay   colorAndDist   w   if   hit   background   quit   if   hitDistance   0   0f   finalColor   hitColor   break   else   const   vec3   hitNormal   PrimaryRay   normal   xyz   const   float   isTeapot   PrimaryRay   normal   w   const   vec3   hitPos   origin   direction   hitDistance   if   isTeapot   0   0f   our   teapot   is   mirror   so   continue   origin   hitPos   hitNormal   0   01f   direction   reflect   direction   hitNormal   else   we   hit   diffuse   primitive   simple   lambertian   const   vec3   toLight   normalize   Params   sunPosAndAmbient   xyz   const   vec3   shadowRayOrigin   hitPos   hitNormal   0   01f   traceNV   Scene   rayFlags   cullMask   shadowRecordOffset   stbRecordStride   shadowMissIndex   shadowRayOrigin   0   0f   toLight   tmax   SWS _ LOC _ SHADOW _ RAY   const   float   lighting   ShadowRay   distance   0   0f   Params   sunPosAndAmbient   w   max   Params   sunPosAndAmbient   w   dot   hitNormal   toLight   finalColor   hitColor   lighting   break   результат   правдоподобный   отражение   часть   6   стекло   и   финал   наш   рейтрейсер   начинать   обретать   черта   взрослый   трассировщик   теперь   иметь   на   рука   универсальный   цикл   трассировка   мы   мочь   расширять   функционал   добавлять   новый   материал   и   более   реалистичный   модель   освещение   довольно   небольшой   изменение   можно   получать   полноценный   трассировщик   путь   path   tracer   для   расчет   реалистичный   изображение   давать   напоследок   добавлять   еще   один   фич   рейтрейсинг   преломление   вещь   практически   нереализуемый   стандартный   растеризация   но   благодаря   наш   цикл   трассировка   мы   мочь   легко   получать   реалистичный   многоуровневый   преломление   давать   сделать   наш   кролик   стеклянный   для   этот   вводить   константа   порядковый   номер   объект   наш   сцена   и   в   шейдер   пересечение   быть   записывать   в   RayPayload   номер   объект   с   который   пересекаться   const   float   objId   float   gl _ InstanceCustomIndexNV   PrimaryRay   normalAndObjId   vec4   normal   objId   подбирать   индекс   преломление   для   наш   кролик   я   выбирать   обычный   стекло   с   индекс   преломление   равный   1   52   так   как   функция   refract   принимать   соотношение   индекс   преломление   два   среда   а   в   наш   случай   это   воздух   стекло   потому   финальный   значение   равно   1   0   1   52   const   float   kBunnyRefractionIndex   1   0f   1   52f   теперь   добавлять   в   наш   цикл   проверка   на   попадание   в   кролик   if   objectId   OBJECT _ ID _ TEAPOT   our   teapot   is   mirror   so   reflect   and   continue   origin   hitPos   hitNormal   0   001f   direction   reflect   direction   hitNormal   else   if   objectId   OBJECT _ ID _ BUNNY   our   bunny   is   glass   so   refract   and   continue   const   float   NdotD   dot   hitNormal   direction   const   vec3   refrNormal   NdotD   0   0f   hitNormal   hitNormal   origin   hitPos   direction   0   001f   direction   refract   direction   refrNormal   kBunnyRefractionIndex   так   как   преломлять   луч   заходить   внутрь   объект   мы   нужно   отслеживать   это   и   переворачивать   нормаль   чтобы   получать   правильный   результат   преломление   давать   полюбоваться   наш   стеклянный   кролик   мы   с   вы   проходить   путь   от   разноцветный   треугольник   до   сцена   с   несколько   объект   текстурированный   и   реализовать   отражать   и   преломлять   поверхность   на   этот   основа   уже   можно   строить   более   или   менее   серьезный   рейтрейсер   пастрейсер   в   следующий   статья   я   постараться   рассматривать   гибридный   рендеринг   совмещать   растеризация   и   рейтрейсинг   исходный   код   к   статья   находиться   здесь   https   github   com   iOrange   rtxON   tree   Version _ 2 _ 2   график   raytracing   rtx   Vulkan   рейтрейсинг   18   ноябрь   2018   обновление   27   ной   2018   комментарий   60   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   GameDev   ru   разработка   игра   2001   2019