   введение   в   Vulkan   Raytracing   график   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   FAQ   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиграфика   введение   в   Vulkan   Raytracing   автор   0r   ngE   в   какой   время   мы   жить   казаться   еще   недавно   мы   час   ждать   пока   CPU   просчитывать   знаменитый   изображение   за   авторство   тернер   уиттед   а   сегодня   мы   доступный   потребительский   модель   видеокарта   с   аппаратный   поддержка   рейтрейсинг   любой   программист   трехмерный   график   сказать   что   он   мечтать   об   это   дно   когда   мы   наконец   мочь   трассироваться   в   мировой   пространство   в   реальный   время   часть   0   подводка   часть   1   вводный   Acceleration   structures   Shader   Binding   Table   vkCmdTraceRaysNVX   и   Raytracing   pipeline   часть   2   код   часть   0   подводка   что   же   давать   разбираться   что   для   это   мы   нужно   и   как   начинать   использовать   вверять   мы   технология   на   момент   написание   статья   специализированный   аппаратный   решение   для   рейтрейсинг   на   GPU   быть   только   у   компания   Nvidia   имя   она   RTX   компания   AMD   делать   ставка   на   свой   открывать   фреймворк   Radeon   Rays   который   по   суть   являться   набор   готовый   вычислительный   шейдер   compute   shaders   в   данный   статья   мы   далее   быть   рассматривать   решение   от   компания   Nvidia   поддерживаться   аппаратный   рейтрейсинг   видеокарта   на   база   архитектура   Volta   и   Turing   со   сторона   графический   апи   аппаратный   рейтрейсинг   поддерживаться   DirectX   12   DirectX   Raytracing   DXR   и   Vulkan   посредством   расширение   VK _ NVX _ raytracing   важно   отмечать   что   оба   этот   апи   мало   что   отличаться   т   к   оба   быть   спроектировать   компания   Nvidia   это   значит   что   весь   рассматривать   в   статья   быть   справедливый   для   оба   апи   автор   статья   останавливать   свой   выбор   на   Vulkan   и   то   2   причина   банальный   автор   знакомый   с   Vulkan   и   не   особо   знакомый   с   DirectX   12   технический   DXR   на   момент   написание   статья   требовать   определенный   сборка   WIndows   10   что   вносить   некий   дискомфорт   часть   1   вводный   для   работа   с   рейтрейсинг   быть   добавлять   следующий   элемент   и   понятие   Acceleration   structures   специальный   объект   инкапсулировать   в   себя   внутренний   представление   геометрия   для   трассировка   мочь   представлять   себя   это   как   некий   дерево   описывать   объем   BVH   для   ускорение   поиск   пересечение   луч   и   геометрия   таблица   привязка   шейдер   Shader   Binding   Table   SBT   структура   данные   позволять   вы   передавать   апи   несколько   шейдер   для   трассировка   и   или   отдельный   ее   этап   и   затем   динамически   в   самый   шейдер   вызывать   шейдер   из   этот   таблица   новый   команда   запуск   трассировка   vkCmdTraceRaysNVX   очень   похожий   на   команда   запуск   вычислительный   шейдер   vkCmdDispatch   новый   конвейер   pipeline   для   трассировка   уметь   работать   с   таблица   шейдер   давать   короче   рассматривать   по   отдельность   весь   этот   нововведение   Acceleration   structures   итак   первый   дело   посмотреть   что   же   такой   acceleration   structure   AS   и   как   с   они   работать   чтобы   как   можно   быстро   находить   пересечение   с   геометрия   мы   нужный   некий   структура   данные   иметь   пространственный   информация   о   геометрия   и   позволять   быстро   отбрасывать   тот   часть   сцена   который   заведомо   не   пересекаться   с   луч   как   простой   пример   можно   представлять   себя   иерархия   из   ограничивать   объем   BVH   представлять   параллелепипед   такой   образ   тестировать   луч   на   пересечение   с   параллелепипед   мы   мочь   сокращать   тест   пересечение   с   геометрия   до   небольшой   набор   примитив   не   перебирать   весь   сцена   оба   наш   апи   предоставлять   2   уровень   AS   BLAS   и   TLAS   BLAS   это   Bottom   Level   Acceleration   Structure   ускорять   структура   нижний   уровень   который   и   содержать   собственно   говорить   геометрия   TLAS   Top   Level   Acceleration   Structure   ускорять   структура   верхний   уровень   это   уже   структура   содержать   в   себя   один   или   несколько   структура   нижний   уровень   а   также   информация   об   их   трансформация   размещаться   BLAS   внутри   TLAS   посредством   инстанцирование   instancing   благодаря   что   можно   дублировать   BLAS   указывать   инстанс   ссылка   на   BLAS   и   отдельный   трансформация   Shader   Binding   Table   что   же   такой   Shader   Binding   Table   SBT   и   с   что   он   есть   для   начало   давать   рассматривать   какой   новый   шейдерный   стадия   shader   stages   у   мы   добавляться   Raygen   шейдер   отвечать   за   генерация   луч   и   вызов   трассировка   функция   traceNVX   в   GLSL   обязательный   Intersection   шейдер   реализовать   проверка   пересечение   луч   и   геометрия   позволять   реализовать   рейтрейсинг   пользовательский   примитив   например   геометрия   заданный   сплайн   необязательный   по   умолчание   быть   использовать   реализация   пересечение   луч   с   треугольник   Any   hit   и   Closest   hit   шейдер   вызываться   при   позитивный   результат   проверка   на   пересечение   с   примитив   так   как   примитив   не   всегда   быть   отсортировывать   вдоль   луч   мочь   быть   зарегистрировать   несколько   пересечение   Any   hit   шейдер   быть   вызывать   для   все   из   они   в   тот   время   как   Closest   hit   шейдер   быть   вызывать   в   самый   конец   когда   после   нахождение   весь   возможный   пересечение   быть   выбирать   близкий   Any   hit   не   обязательный   Closest   hit   обязательный   Miss   шейдер   выполняться   если   пересечение   не   быть   находить   в   предел   tmin   tmax   можно   использовать   для   возврат   цвет   небо   например   необязательный   как   видеть   быть   добавлять   целый   5   дополнительный   шейдерный   стадия   с   помощь   который   можно   реализовать   практически   весь   существующий   метод   трассировка   этот   шейдер   разбиваться   на   3   функциональный   подмножество   Raygen   сюда   входить   одноименный   шейдер   этот   шейдер   мочь   быть   только   один   на   каждый   старт   трассировка   вызов   vkCmdTraceRaysNVX   Intersection   сюда   входить   шейдер   Intersection   Any   hit   и   Closest   hit   Miss   в   этот   подмножество   только   один   шейдер   Miss   теперь   мочь   разбираться   для   что   мы   SBT   давать   представлять   себя   простой   рейтрейсер   который   считать   только   прямой   освещение   direct   lighting   в   простой   случай   он   мочь   выглядеть   так   for   each   pixel   on   screen   generate   ray   trace   ray   if   wasHit   ray   lighting   0   for   each   light   generate   secondaryRay   trace   secondaryRay   If   not   wasHit   secondaryRay   lighting   calcLighting   light   ray   color   lighting   resultImage   pixel   ray   color   здесь   мы   видеть   применение   Raygen   шейдер   для   генерация   луч   Closest   hit   и   Miss   шейдер   для   получение   цвет   в   точка   пересечение   или   небо   в   случай   промах   Closest   hit   шейдер   может   содержать   относительно   сложный   код   для   чтение   необходимый   информация   и   расчет   цвет   в   точка   пересечение   Miss   шейдер   к   пример   мочь   рассчитывать   цвет   из   карта   окружение   это   шейдер   для   так   называть   основной   луч   primary   rays   в   случай   нахождение   пересечение   с   геометрия   мы   генерировать   вторичный   луч   secondary   rays   для   проверка   видимость   источник   свет   в   точка   пересечение   если   источник   свет   не   видный   значит   мы   в   тень   для   хороший   производительность   мы   мочь   использовать   более   простой   шейдер   Closest   hit   и   Miss   который   мочь   просто   выставлять   флаг   быть   ли   пересечение   или   нет   именно   для   это   функция   traceNVX   в   шейдер   принимать   в   качество   параметр   индекс   группа   внутри   подмножество   сам   же   шейдер   собирать   в   группа   лежать   в   таблица   SBT   запутанно   поначалу   мочь   быть   сейчас   попробовать   объяснять   приводить   SBT   для   наш   пример   сверху   итак   у   мы   5   шейдер   1   Raygen   2   Closest   hit   и   еще   2   Miss   как   мы   уже   знать   они   принадлежать   к   разный   подмножество   давать   собирать   группа   для   наш   шейдер   и   сформировывать   SBT   первый   у   мы   идти   Raygen   шейдер   он   быть   в   первый   группа   0   далее   идти   2   Closest   hit   шейдер   они   занимать   группа   1   и   2   соответственно   оставаться   2   Miss   шейдер   занимать   группа   3   и   4   чтобы   быть   еще   наглядно   давать   мы   добавлять   Any   hit   шейдер   для   вторичный   луч   ведь   мы   не   обязательно   находить   близкий   пересечение   важный   сам   факт   блокировка   источник   свет   этот   шейдер   входить   в   группа   2   ибо   он   принадлежать   к   подмножество   Intersection   шейдер   как   и   Closest   hit   как   видно   из   схематический   изображение   для   то   чтобы   функция   traceNVX   вызывать   шейдер   для   первичный   луч   мы   надо   указывать   индекс   соответствующий   группа   внутри   соответствующий   подмножество   шейдер   для   обработка   пересечение   для   первичный   луч   находиться   в   группа   1   который   в   свой   очередь   лежать   первый   в   свой   подмножество   а   значит   она   индекс   0   то   же   справедливо   и   для   группа   3   в   который   находиться   шейдер   промах   для   первичный   луч   для   вторичный   луч   мы   соответственно   нужный   группа   2   и   4   индекс   который   1   и   1   как   вы   уже   мочь   видеть   из   пример   каждый   Intersection   группа   мочь   содержать   от   один   до   3   шейдер   Intersection   Closest   hit   и   Any   hit   данный   механизм   позволять   иметь   набор   специализированный   шейдер   для   разный   этап   ваш   рейтрейсер   и   какой   из   они   в   какой   случай   использовать   решать   вы   сам   что   очень   удобно   vkCmdTraceRaysNVX   и   Raytracing   pipeline   мы   с   вы   разбираться   с   самый   сложный   и   запутанный   часть   оставаться   лишь   бегло   рассматривать   оставаться   2   элемент   vkCmdTraceRaysNVX   очень   похожий   по   свой   суть   на   vkCmdDispatch   разница   в   то   что   vkCmdTraceRaysNVX   запускать   исполнение   по   двухмерный   сетка   и   без   разбиение   на   группа   во   всякий   случай   не   явно   а   также   в   качество   параметр   принимать   стартовый   смещение   для   каждый   группа   шейдер   в   буфер   содержать   SBT   Raytracing   pipeline   хранить   в   себя   соотношение   шейдер   и   их   группа   то   быть   если   SBT   это   буфер   в   который   лежать   шейдер   то   Raytracing   pipeline   этот   описание   какой   из   шейдер   в   этот   буфер   к   какой   группа   относиться   часть   2   код   переходить   непосредственно   к   код   пора   применять   получать   знание   на   практика   сразу   хотеть   оговариваться   данный   статья   посвящать   только   рассмотрение   новый   функционал   рейтрейсинг   и   рассчитать   на   человек   знакомый   с   Vulkan   шейдер   и   программирование   график   в   целое   перед   продолжение   рекомендовать   проходить   боевой   крещение   Vulkan   ом   с   помощь   замечательный   урок   https   vulkan   tutorial   com   начинать   со   своеобразный   Hello   World   в   мир   график   разноцветный   треугольник   давать   рассматривать   основной   этап   создавать   сцена   сгенерировать   геометрия   треугольник   создавать   для   он   BLAS   создавать   инстанс   с   единичный   матрица   трансформация   создавать   TLAS   на   основа   наш   инстанс   загружать   шейдер   и   создавать   Raytracing   pipeline   указывать   какой   шейдер   в   какой   группа   располагаться   создавать   SBT   и   загружать   в   он   информация   о   шейдер   из   Raytracing   pipeline   создавать   необходимый   набор   дескриптор   descriptor   set   для   два   наш   ресурс   наш   TLAS   по   который   мы   быть   трассироваться   а   также   результирующий   изображение   result   image   в   который   мы   быть   записывать   посчитать   цвет   для   каждый   пиксел   после   это   все   что   мы   оставаться   это   заполнять   командный   буфер   command   buffer   указывать   pipeline   descriptor   set   и   вызывать   vkCmdTraceRaysNVX   что   же   звучать   просто   давать   кодить   начинать   с   создание   сцена   с   треугольник   для   это   мы   понадобиться   вершина   и   индекс   const   float   vertices   9   0   25f   0   25f   0   0f   0   75f   0   25f   0   0f   0   50f   0   75f   0   0f   const   uint32 _ t   indices   3   0   1   2   загружать   они   в   соответствующий   вершинный   и   индексный   буфер   это   очень   удобный   ибо   при   указание   геометрия   для   построение   AS   вы   мочь   использовать   тот   же   буфер   что   и   для   отрисовка   растеризация   далеко   мы   необходимо   заполнять   соответствующий   поле   новый   структура   VkGeometryNVX   указывать   вершинный   и   индексный   буфер   количество   и   размер   вершина   а   также   формат   вершина   и   индекс   весь   этот   параметр   совершенно   такой   же   как   и   для   отрисовка   растеризация   временно   откладывать   наш   геометрия   до   момент   построение   AS   для   создание   AS   мы   как   это   принимать   в   Vulkan   нужно   выделять   под   она   память   сначала   создавать   новый   объект   AS   функция   vkCreateAccelerationStructureNVX   здесь   мы   мочь   указывать   какой   тип   AS   мы   хотеть   создавать   верхний   или   нижний   уровень   чтобы   узнавать   сколько   и   какой   память   мы   нужно   выделять   вводить   новый   функция   vkGetAccelerationStructureMemoryRequirementsNVX   далее   мы   привязывать   выделять   память   к   AS   функция   vkBindAccelerationStructureMemoryNVX   наш   AS   готовый   к   постройка   для   построение   AS   драйвер   понадобиться   временный   память   для   работа   и   ее   выделять   мы   должный   тоже   сам   как   и   везде   в   Vulkan   собственно   чтобы   узнавать   требование   к   этот   буфер   мы   понадобиться   функция   vkGetAccelerationStructureScratchMemoryRequirementsNVX   так   как   построение   AS   происходить   на   GPU   мы   понадобиться   командный   буфер   теперь   иметь   все   это   на   рука   мы   мочь   строить   наш   AS   vkCmdBuildAccelerationStructureNVX   commandBuffer   VK _ ACCELERATION _ STRUCTURE _ TYPE _ BOTTOM _ LEVEL _ NVX   0   VK _ NULL _ HANDLE   0   1   geometry   0   VK _ FALSE   mScene   bottomLevelAS   0   accelerationStructure   VK _ NULL _ HANDLE   scratchBuffer   GetBuffer   0   vkCmdPipelineBarrier   commandBuffer   VK _ PIPELINE _ STAGE _ RAYTRACING _ BIT _ NVX   VK _ PIPELINE _ STAGE _ RAYTRACING _ BIT _ NVX   0   1   memoryBarrier   0   0   0   0   обращать   внимание   что   здесь   мы   явно   указывать   наш   ранее   создавать   геометрия   и   количество   в   наш   случай   это   все   1   треугольник   теперь   надо   построить   AS   верхний   уровень   TLAS   как   мы   уже   знать   TLAS   по   суть   являться   контейнер   для   один   или   множество   BLAS   который   размещаться   в   немой   посредством   инстансинг   для   это   мы   нужно   заполнять   структура   VkGeometryInstance   для   каждый   экземпляр   BLAS   указывать   соответствующий   AS   и   матрица   трансформация   получаться   массив   инстанс   нужно   загружать   в   буфер   теперь   мы   нужно   повторять   весь   тот   же   самый   шаг   что   и   для   построение   BLAS   отличие   быть   в   параметр   вызывать   функция   так   при   вызов   vkCreateAccelerationStructureNVX   мы   указывать   что   хотеть   создавать   AS   верхний   уровень   а   при   вызов   vkCmdBuildAccelerationStructureNVX   вместо   геометрия   надо   указывать   буфер   с   инстанс   следующий   шаг   быть   загрузка   шейдер   и   создание   конвейер   raytracing   pipeline   для   наш   пример   мы   понадобиться   3   шейдер   ray _ gen   glsl   ray _ chit   glsl   и   ray _ miss   glsl   для   каждый   из   они   мы   понадобиться   свой   стадия   vulkanhelpers   Shader   rayGenShader   rayChitShader   rayMissShader   rayGenShader   LoadFromFile   sShadersFolder   ray _ gen   bin   c _ str   rayChitShader   LoadFromFile   sShadersFolder   ray _ chit   bin   c _ str   rayMissShader   LoadFromFile   sShadersFolder   ray _ miss   bin   c _ str   std   vector   VkPipelineShaderStageCreateInfo   shaderStages   rayGenShader   GetShaderStage   VK _ SHADER _ STAGE _ RAYGEN _ BIT _ NVX   rayChitShader   GetShaderStage   VK _ SHADER _ STAGE _ CLOSEST _ HIT _ BIT _ NVX   rayMissShader   GetShaderStage   VK _ SHADER _ STAGE _ MISS _ BIT _ NVX   далее   мы   нужно   быть   указывать   номер   группа   для   каждый   из   они   в   наш   случай   весь   просто   весь   3   группа   с   номер   0   1   и   2   соответственно   также   здесь   мы   создавать   набор   описатель   шейдерный   ресурс   descriptor   set   этот   ресурс   у   мы   2   это   наш   TLAS   представлять   сцена   для   трассировка   и   изображение   image   для   результат   трассировка   теперь   заполнять   структура   VkRaytracingPipelineCreateInfoNVX   указывать   наш   шейдерный   стадия   и   номер   их   группа   а   также   наш   descriptor   set   и   вызов   функция   vkCreateRaytracingPipelinesNVX   создавать   конвейер   для   трассировка   последний   шаг   быть   создание   таблица   привязка   шейдер   SBT   как   уже   говориться   ранее   SBT   это   всего   лишь   буфер   в   который   лежать   группа   шейдер   точно   ссылка   на   они   соответственно   мы   нужно   создавать   буфер   размер   количество _ группа   размер   группа   размер   группа   можно   узнавать   запрашивать   устройство   device   заполнять   мы   структура   VkPhysicalDeviceRaytracingPropertiesNVX   создавать   буфер   заполнять   его   группа   шейдер   который   мы   указывать   при   создание   конвейер   для   это   мы   понадобиться   функция   vkGetRaytracingShaderHandlesNVX   void   mem   mShaderBindingTable   Map   shaderBindingTableSize   vkGetRaytracingShaderHandlesNVX   mDevice   mRTPipeline   0   numGroups   shaderBindingTableSize   mem   mShaderBindingTable   Unmap   итак   у   мы   все   готовый   для   запуск   трассировка   для   это   существовать   команда   vkCmdTraceRaysNVX   в   качество   параметр   она   принимать   буфер   SBT   а   также   смещение   до   начальный   группа   каждый   из   подмножество   шейдер   void   vkCmdTraceRaysNVX   VkCommandBuffer   commandBuffer   VkBuffer   raygenShaderBindingTableBuffer   VkDeviceSize   raygenShaderBindingOffset   VkBuffer   missShaderBindingTableBuffer   VkDeviceSize   missShaderBindingOffset   VkDeviceSize   missShaderBindingStride   VkBuffer   hitShaderBindingTableBuffer   VkDeviceSize   hitShaderBindingOffset   VkDeviceSize   hitShaderBindingStride   uint32 _ t   width   uint32 _ t   height   как   видеть   мы   мочь   использовать   разный   буфер   для   разный   группа   в   наш   случай   SBT   буфер   один   Raygen   шейдер   у   мы   располагаться   в   нулевой   группа   и   потому   его   смещение   offset   равный   0   Miss   шейдер   у   мы   располагаться   во   второй   группа   и   потому   его   смещение   2   размер _ группа   Hit   shader   у   мы   находиться   в   первый   группа   и   его   смещение   размер _ группа   последний   два   параметр   идти   ширина   и   высота   экран   Raygen   шейдер   быть   вызывать   один   раз   для   каждый   пиксел   итого   width   height   раз   мы   оставаться   разбираться   с   код   шейдер   и   мочь   запускать   наш   замечательный   приложение   ray _ gen   glsl   version   460   extension   GL _ NVX _ raytracing   require   layout   set   0   binding   0   uniform   accelerationStructureNVX   Scene   layout   set   0   binding   1   rgba8   uniform   image2D   ResultImage   layout   location   0   rayPayloadNVX   vec3   ResultColor   void   main   const   vec2   uv   vec2   gl _ LaunchIDNVX   xy   vec2   gl _ LaunchSizeNVX   xy   1   const   vec3   origin   vec3   uv   x   1   0f   uv   y   1   0f   const   vec3   direction   vec3   0   0f   0   0f   1   0f   const   uint   rayFlags   gl _ RayFlagsNoneNVX   const   uint   cullMask   0xFF   const   uint   sbtRecordOffset   0   const   uint   sbtRecordStride   0   const   uint   missIndex   0   const   float   tmin   0   0f   const   float   tmax   10   0f   const   int   payloadLocation   0   traceNVX   Scene   rayFlags   cullMask   sbtRecordOffset   sbtRecordStride   missIndex   origin   tmin   direction   tmax   payloadLocation   imageStore   ResultImage   ivec2   gl _ LaunchIDNVX   xy   vec4   ResultColor   1   0f   строка   extension   GL _ NVX _ raytracing   require   говорить   компилятор   что   мы   хотеть   использовать   расширение   для   рейтрейсинг   также   вы   мочь   замечать   несколько   новый   тип   и   глобальный   переменный   новый   тип   ресурс   accelerationStructureNVX   позволять   передавать   шейдер   наш   TLAS   представлять   сцена   по   который   быть   вестись   трассировка   rayPayloadNVX   являться   объявление   данный   луч   который   быть   передаваться   далеко   в   шейдер   пересечение   и   промах   в   наш   случай   это   простой   vec3   для   цвет   const   vec2   uv   vec2   gl _ LaunchIDNVX   xy   vec2   gl _ LaunchSizeNVX   xy   1   здесь   мы   вычислять   нормализовать   координата   пиксел   на   наш   экран   gl _ LaunchIDNVX   содержать   в   себя   индекс   текущий   поток   исполнение   подобно   gl _ GlobalInvocationID   в   compute   шейдер   gl _ LaunchSizeNVX   содержать   в   себя   тот   самый   width   и   height   что   мы   передавать   в   vkCmdTraceRaysNVX   поделить   один   на   другой   мы   получать   нормализовать   координата   в   экранный   пространство   это   нужный   мы   ибо   именно   в   они   мы   задавать   координата   вершина   наш   треугольник   мы   использовать   этот   координата   для   получение   отправной   точка   наш   луч   const   vec3   origin   vec3   uv   x   1   0f   uv   y   1   0f   мы   переворачивать   Y   потому   как   в   координатный   система   экран   Vulkan   ось   Y   направлять   вниз   если   это   не   сделать   то   наш   изображение   быть   выглядеть   вверх   нога   также   мы   немного   отодвигаться   назад   указывать   1   как   Z   координата   чтобы   треугольник   быть   перед   мы   const   vec3   direction   vec3   0   0f   0   0f   1   0f   направление   луч   ставить   прямо   вперед   вдоль   ось   Z   const   uint   rayFlags   gl _ RayFlagsNoneNVX   const   uint   cullMask   0xFF   const   uint   sbtRecordOffset   0   const   uint   sbtRecordStride   0   const   uint   missIndex   0   const   float   tmin   0   0f   const   float   tmax   10   0f   const   int   payloadLocation   0   флаг   луч   и   маска   отсечение   мы   пока   оставлять   стандартный   и   вернуться   к   они   когда   быть   делать   более   продвинутый   трассировка   параметр   sbtRecordOffset   и   sbtRecordStride   нужный   для   задание   индекс   и   размер   группа   шейдер   пересечение   в   наш   SBT   как   определяться   этот   индекс   мы   с   вы   разбирать   ранее   параметр   missIndex   определять   индекс   группа   miss   шейдер   параметр   tmin   и   tmax   задавать   отрезок   на   луч   внутри   который   быть   происходить   поиск   пересечение   мочь   представлять   это   себя   как   znear   и   zfar   плоскость   отсечение   и   наконец   payloadLocation   определять   расположение   данный   луч   это   позволять   иметь   несколько   набор   данные   луч   для   разный   шейдер   и   указывать   функция   трассировка   какой   набор   в   какой   случай   использовать   в   наш   случай   у   мы   только   один   набор   ResultColor   и   его   location   равный   0   после   вызов   функция   traceNVX   в   данный   луч   в   наш   случай   это   ResultColor   быть   лежать   тот   значение   который   туда   записывать   шейдер   пересечение   или   промах   imageStore   ResultImage   ivec2   gl _ LaunchIDNVX   xy   vec4   ResultColor   1   0f   в   наш   случай   мы   просто   записывать   получаться   цвет   в   результирующий   изображение   использовать   gl _ LaunchIDNVX   в   качество   координата   пиксел   ray _ chit   glsl   version   460   extension   GL _ NVX _ raytracing   require   layout   location   0   rayPayloadInNVX   vec3   ResultColor   layout   location   1   hitAttributeNVX   vec2   HitAttribs   void   main   const   vec3   barycentrics   vec3   1   0f   HitAttribs   x   HitAttribs   y   HitAttribs   x   HitAttribs   y   ResultColor   vec3   barycentrics   здесь   мы   видеть   уже   новый   идентификатор   rayPayloadInNVX   который   указывать   на   входной   данные   луч   Location   они   должный   совпадать   с   таковой   указанный   при   вызов   функция   traceNVX   hitAttributeNVX   позволять   шейдер   принимать   данные   о   пересечение   который   определять   шейдер   поиск   пересечение   intersection   shader   стандартный   встроенный   шейдер   пересечение   с   треугольник   передавать   только   барицентрический   координата   точка   пересечение   с   треугольник   использовать   их   можно   получать   любой   интересовать   мы   данный   просто   интерполировать   значение   вершина   треугольник   в   наш   случай   мы   же   просто   записывать   барицентрический   координата   в   выходной   цвет   ray _ miss   glsl   version   460   extension   GL _ NVX _ raytracing   require   layout   location   0   rayPayloadInNVX   vec3   ResultColor   void   main   ResultColor   vec3   0   412f   0   796f   1   0f   данный   шейдер   похожий   на   сильно   упрощенный   копия   шейдер   пересечение   в   который   мы   ничто   не   считать   а   просто   возвращать   константный   цвет   такой   образ   мы   задавать   цвет   фон   наш   треугольник   скомпилировать   этот   шейдер   можно   утилита   glslangValidator   входить   в   состав   Vulkan   SDK   после   успешный   компиляция   приложение   и   шейдер   мы   наконец   мочь   полюбоваться   наш   треугольник   неземной   красота   соглашаться   никакой   растеризация   не   позволять   получать   такой   натуральный   и   физически   корректный   треугольник   что   же   поздравлять   теперь   вы   тоже   официально   RTX   ON   исходный   код   проект   https   github   com   iOrange   rtxON   tree   happy _ triangle _ fixed   график   raytracing   rtx   Vulkan   рейтрейсинг   4   ноябрь   2018   обновление   12   ной   2018   комментарий   182   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   GameDev   ru   разработка   игра   2001   2019