   стоимость   OpenGL   команда   график   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   FAQ   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиграфика   стоимость   OpenGL   команда   автор   анатолий   герлиц   в   современный   проект   для   получение   красивый   картинка   отрисовываться   тысяча   различный   объект   персонаж   строение   ландшафт   природа   эффект   и   т   д   разумеется   быть   разный   способ   отображать   на   экран   геометрия   в   этот   статья   мы   рассматривать   как   сделать   это   эффективно   посчитать   и   сравнивать   стоимость   различный   API   вызов   для   отрисовка   геометрия   рассматривать   стоимость   API   вызов   смена   различный   стейт   по   отдельность   фрейм   буфер   вершинный   буфер   шейдер   константа   текстура   различный   тип   инстансинг   геометрия   сравнивать   по   скорость   несколько   практический   пример   как   стоять   оптимизировать   рендер   отрисовка   геометрия   в   проект   в   данный   статья   быть   рассматривать   только   OpenGL   возможно   в   следующий   статья   рассматривать   и   другой   API   не   быть   детально   рассказывать   про   параметр   и   вариация   каждый   API   вызов   для   это   быть   справочник   конфигурация   компьютер   на   который   производиться   расчет   Intel   Core   i5   4460   3   2GHz   Radeon   R9   380   операционный   система   Windows   10   немного   об   измерение   производительность   наиболее   правильный   подход   к   измерение   производительность   являться   замирать   время   всего   кадр   даже   если   в   замер   попадать   несколько   лишний   вещь   вроде   очистка   буфер   установка   шейдер   и   fbo   полный   уравнение   выглядеть   так   средний _ время _ тесто   время _ после _ N _ итерация   время _ когда _ начинать _ первый _ итерация   количество _ итерация _ тесто   во   весь   вычисление   время   в   милисекунда   ms   выполнять   тест   несколько   раз   и   вычислять   средний   время   количество   итерация   должно   быть   достаточно   большой   500   1000   иначе   получать   большой   разброс   в   замер   от   запуск   к   запуск   измерять   производительность   инстансинг   мы   должный   убеждаться   что   не   упираться   в   GPU   поэтому   в   отчет   также   писаться   время   потратить   на   GPU   мы   интересовать   только   время   потратить   на   CPU   как   правило   время   тесто   масштабироваться   линейно   в   зависимость   от   количество   смена   стейт   разумеется   производительность   и   стоимость   API   вызов   зависеть   от   железо   производитель   модель   драйвер   операционный   система   но   мы   мочь   оценивать   относительный   стоимость   API   вызов   вырабатывать   направление   в   который   стоять   оптимизировать   программа   и   оценивать   потенциальный   выигрыш   в   производительность   от   различный   оптимизация   смена   стейтовый   дип   смена   FBO   смена   шейдер   смена   параметр   шейдер   смена   вершинный   буфер   смена   текстура   сравнительный   оценка   стоимость   стейт   инстансинг   текстурный   инстансинг   инстансинг   через   вершинный   буфер   Uniform   buffer   instancing   Texture   buffer   instancing   SSBO   buffer   instancing   Uniform   buffer   TBO   SSBO   Uniforms   instancing   Multi   draw   indirect   сравнение   тип   инстансинг   о   скорость   рекомендация   по   оптимизация   и   вывод   смена   стейт   итак   мы   хотеть   видеть   на   экран   богатый   картинка   много   уникальный   объект   с   большой   количество   деталь   для   это   движок   перебирать   весь   видимый   объект   в   кадр   устанавливать   их   параметр   вершинный   буфер   шейдер   параметр   материал   текстура   и   посылать   на   рендер   весь   этот   действие   выполняться   специальный   API   команда   рассматривать   они   проводить   несколько   тест   чтобы   понимать   как   оптимальный   организовывать   отрисовка   геометрия   разбираться   со   стоимость   различный   OpenGL   вызов   дип   DIP   Draw   Indexed   Primitive   смена   FBO   Frame   Buffer   Object   шейдер   вершинный   буфер   текстура   константа   параметр   передавать   в   шейдер   дип   DIP   Draw   Indexed   Primitive   команда   для   отрисовка   геометрия   часто   все   треугольник   нужно   конечно   сперва   подготовить   и   указывать   какой   геометрия   собираться   отображать   с   какой   шейдер   а   также   устанавливать   параметр   но   именно   этот   команда   выполнять   отрисовка   геометрия   на   экран   в   стоимость   dip   а   обычно   включать   весь   сопутствовать   смена   стейт   а   не   сам   конмада   разумеется   весь   зависеть   от   количество   смена   стейт   для   начало   рассматривать   простой   случай   стоимость   1к   простой   дип   без   смена   стейт   void   simple _ dips   glBindVertexArray   ws _ complex _ geometry _ vao _ id   какой   геометрия   быть   выводить   simple _ geometry _ shader   bind   с   какой   шейдер   материал   много   простой   dip   ов   for   int   i   0   i   CURRENT _ NUM _ INSTANCES   i   glDrawRangeElements   GL _ TRIANGLES   i   BOX _ NUM _ VERTS   i   1   BOX _ NUM _ VERTS   BOX _ NUM _ INDICES   GL _ UNSIGNED _ INT   GLvoid   i   BOX _ NUM _ INDICES   sizeof   int   simple   dip   для   1000   дип   получать   0   41   ms   здесь   и   далее   в   указываться   стоимость   проводить   тесто   стоимость   API   вызов   быть   посчитать   поздно   в   отдельно   таблица   смена   FBO   FBO   Frame   Buffer   Object   объект   который   позволять   выводить   изображение   не   на   экран   а   в   другой   поверхность   который   в   последствие   можно   использовать   как   текстура   для   обработка   в   шейдер   менять   FBO   приходиться   не   так   часто   как   другой   элемент   но   в   тоже   время   смена   обходиться   достаточно   дорого   для   CPU   void   fbo _ change _ test   очищать   fbo   glViewport   0   0   window _ width   window _ height   glClearColor   0   0f   255   0f   0   0f   255   0f   0   0f   255   0f   0   0   for   int   i   0   i   NUM _ DIFFERENT _ FBOS   i   glBindFramebuffer   GL _ FRAMEBUFFER   fbo _ buffer   i   NUM _ DIFFERENT _ FBOS   glClear   GL _ COLOR _ BUFFER _ BIT   GL _ DEPTH _ BUFFER _ BIT   подготовить   дип   glBindVertexArray   ws _ complex _ geometry _ vao _ id   какой   геометрия   быть   выводить   simple _ geometry _ shader   bind   с   какой   шейдер   материал   устанавливать   fbo   отрисовывать   1   объект   повторять   N   раз   for   int   i   0   i   NUM _ FBO _ CHANGES   i   glBindFramebuffer   GL _ FRAMEBUFFER   fbo _ buffer   i   NUM _ DIFFERENT _ FBOS   устанавливать   fbo   glDrawRangeElements   GL _ TRIANGLES   i   BOX _ NUM _ VERTS   i   1   BOX _ NUM _ VERTS   BOX _ NUM _ INDICES   GL _ UNSIGNED _ INT   GLvoid   i   BOX _ NUM _ INDICES   sizeof   int   дип   рендерим   объект   glBindFramebuffer   GL _ FRAMEBUFFER   0   восстанавливать   рендер   на   экран   для   200   смена   fbo   получать   1   97   ms   менять   FBO   приходиться   как   правило   для   пост   эффект   и   различный   проход   вспомогательный   процедура   отражение   рендеры   в   кубмап   рендеры   виртуальный   текстура   и   т   д   многий   вещь   вроде   виртуальный   текстура   можно   организовывать   в   атлас   чтобы   устанавливать   FBO   только   1   раз   и   менять   например   только   вьюпорт   рендеры   в   кубмап   можно   заменять   на   dual   paraboloid   техника   либо   другой   где   требоваться   мало   смена   FBO   дело   конечно   не   только   в   смена   FBO   но   и   в   количество   проход   рендер   сцена   объект   смена   материал   и   т   д   в   общий   случай   чем   мало   переключение   стейт   тем   хорошо   смена   шейдер   шейдер   как   правило   представлять   какой   либо   материал   сцена   либо   какой   то   эффект   техника   чем   много   материал   тип   поверхность   объект   тем   много   шейдер   некоторый   материал   мочь   различаться   незначительно   такой   следовать   объединять   в   один   и   переключение   между   они   делать   условие   ветвление   в   шейдер   количество   различный   материал   напрямую   влиять   на   количество   дип   в   кадр   void   shaders _ change _ test   glBindVertexArray   ws _ complex _ geometry _ vao _ id   for   int   i   0   i   CURRENT _ NUM _ INSTANCES   i   simple _ color _ shader   i   NUM _ DIFFERENT _ SIMPLE _ SHADERS   bind   устанавливать   шейдер   glDrawRangeElements   GL _ TRIANGLES   i   BOX _ NUM _ VERTS   i   1   BOX _ NUM _ VERTS   BOX _ NUM _ INDICES   GL _ UNSIGNED _ INT   GLvoid   i   BOX _ NUM _ INDICES   sizeof   int   дип   рендерим   объект   для   1000   смена   шейдер   получать   2   90   ms   в   установка   шейдер   также   входить   установка   мировой   матрица   иначе   у   мы   ничто   не   отрендериваться   стоимость   установка   параметр   шейдер   мы   посчитать   далеко   смена   параметр   шейдер   часто   материал   делать   универсальный   со   множество   опция   чтобы   получать   разновидность   материал   это   легкий   способ   сделать   картинка   разнообразный   каждый   персонаж   объект   уникальный   соответственно   нужно   как   то   передавать   шейдер   этот   параметр   делаться   это   специальный   команда   glUniform   uniforms _ changes _ test _ shader   bind   glBindVertexArray   ws _ complex _ geometry _ vao _ id   for   int   i   0   i   CURRENT _ NUM _ INSTANCES   i   устанавливать   параметр   для   этот   объект   for   int   j   0   j   NUM _ UNIFORM _ CHANGES _ PER _ DIP   j   glUniform4fv   ColorShader _ uniformLocation   j   1   randomColors   i   NUM _ UNIFORM _ CHANGES _ PER _ DIP   j   MAX _ RANDOM _ COLORS   x   glDrawRangeElements   GL _ TRIANGLES   i   BOX _ NUM _ VERTS   i   1   BOX _ NUM _ VERTS   BOX _ NUM _ INDICES   GL _ UNSIGNED _ INT   GLvoid   i   BOX _ NUM _ INDICES   sizeof   int   дип   рендерим   объект   по   отдельность   выставлять   параметр   конечно   накладно   и   часто   упаковывать   данные   весь   объект   в   1   буфер   пересылать   на   GPU   первый   команда   весь   набор   данные   оставаться   только   для   каждый   объект   указывать   по   какой   смещение   его   данные   находиться   в   этот   большой   массив   устанавливать   буфер   в   который   быть   записывать   данные   объект   glBindBuffer   GL _ SHADER _ STORAGE _ BUFFER   instances _ uniforms _ ssbo   мапим   чтобы   передавать   данные   с   оперативный   память   на   gpu   float   gpu _ data   float   glMapBufferRange   GL _ SHADER _ STORAGE _ BUFFER   0   CURRENT _ NUM _ INSTANCES   NUM _ UNIFORM _ CHANGES _ PER _ DIP   sizeof   vec4   GL _ MAP _ WRITE _ BIT   GL _ MAP _ UNSYNCHRONIZED _ BIT   собственно   копирование   данные   memcpy   gpu _ data   all _ instances _ uniform _ data   0   CURRENT _ NUM _ INSTANCES   NUM _ UNIFORM _ CHANGES _ PER _ DIP   sizeof   vec4   говорить   что   заканчивать   пересылка   данные   glUnmapBuffer   GL _ SHADER _ STORAGE _ BUFFER   привязывать   наш   буфер   с   данные   к   шейдер   glBindBufferBase   GL _ SHADER _ STORAGE _ BUFFER   0   instances _ uniforms _ ssbo   glBindBuffer   GL _ SHADER _ STORAGE _ BUFFER   0   подготовка   дип   uniforms _ changes _ ssbo _ shader   bind   glBindVertexArray   ws _ complex _ geometry _ vao _ id   находить   в   шейдер   переменная   в   который   быть   передавать   смещение   инстанс   данные   для   каждый   объект   static   int   uniformsInstancing _ data _ varLocation   glGetUniformLocation   uniforms _ changes _ ssbo _ shader   programm _ id   instance _ data _ location   for   int   i   0   i   CURRENT _ NUM _ INSTANCES   i   устанавливать   параметр   шейдер   записывать   в   переменный   по   какой   смещение   находиться   инстанс   данные   этот   объект   glUniform1i   uniformsInstancing _ data _ varLocation   i   NUM _ UNIFORM _ CHANGES _ PER _ DIP   glDrawRangeElements   GL _ TRIANGLES   i   BOX _ NUM _ VERTS   i   1   BOX _ NUM _ VERTS   BOX _ NUM _ INDICES   GL _ UNSIGNED _ INT   GLvoid   i   BOX _ NUM _ INDICES   sizeof   int   дип   рендерим   объект   тест   на   смена   параметр   шейдер   через   glUniform4fv   занимать   1   27   ms   для   1000   инстанс   тот   же   тест   с   использование   SSBO   0   8   ms   при   запись   данные   инстанс   на   GPU   использование   glMapBuffer   GL _ SHADER _ STORAGE _ BUFFER   GL _ WRITE _ ONLY   вызывать   синхронизация   CPU   и   GPU   следовать   использовать   glMapBufferRange   с   флаг   GL _ MAP _ UNSYNCHRONIZED _ BIT   чтобы   не   вызывать   синхронизация   но   при   это   нужно   гарантировать   что   переписывать   данные   не   использоваться   на   сторона   GPU   иначе   быть   артефакт   мы   мочь   переписывать   данный   в   тот   момент   когда   GPU   они   читать   чтобы   полностью   решать   этот   проблема   следовать   использовать   тройной   буферизация   в   тот   время   когда   текущий   буфер   использоваться   для   запись   данные   2   другой   мочь   использоваться   GPU   быть   более   оптимальный   способ   мапинг   буфер   с   флаг   GL _ MAP _ PERSISTENT _ BIT   и   GL _ MAP _ COHERENT _ BIT   смена   вершинный   буфер   в   сцена   много   объект   с   разный   геометрия   который   часто   располагать   в   разный   вершинный   буфер   чтобы   отрендерять   другой   объект   с   другой   геометрия   даже   с   тот   же   материал   нужно   сменить   вершинный   буфер   быть   техника   который   позволять   эффективно   рендерять   различный   геометрия   с   один   материал   за   1   дип   MultiDrawIndirect   Dynamic   vertex   pulling   такой   геометрия   должный   находиться   в   1   вершинный   буфер   в   общий   просто   выгодно   объединять   несколько   разный   объект   в   1   буфер   чтобы   делать   маленький   переключение   void   vbo _ change _ test   simple _ geometry _ shader   bind   for   int   i   0   i   CURRENT _ NUM _ INSTANCES   i   менять   вершинный   буфер   vbo   glBindVertexArray   separate _ geometry _ vao _ id   i   NUM _ SIMPLE _ VERTEX _ BUFFERS   glDrawRangeElements   GL _ TRIANGLES   i   BOX _ NUM _ VERTS   i   1   BOX _ NUM _ VERTS   BOX _ NUM _ INDICES   GL _ UNSIGNED _ INT   GLvoid   i   BOX _ NUM _ INDICES   sizeof   int   дип   рендерим   объект   для   1000   смена   VBO   получать   0   95   ms   смена   текстура   текстура   придавать   поверхность   детальный   вид   можно   добиваться   очень   большой   разнообразие   в   картинка   просто   менять   текстура   смешивать   между   себя   разный   в   один   и   тот   же   материал   текстура   приходиться   менять   часто   но   можно   слагать   они   в   так   называть   текстурный   массив   устанавливать   он   только   1   раз   для   несколько   дип   и   обращаться   к   они   по   индекс   в   шейдер   одинаковый   геометрия   с   разный   текстура   можно   отрендерять   за   1   дип   через   инстансинг   void   textures _ change _ test   glBindVertexArray   ws _ complex _ geometry _ vao _ id   int   counter   0   переключаться   между   2   тесто   if   test _ type   ARRAY _ OF _ TEXTURES _ TEST   array _ of _ textures _ shader   bind   for   int   i   0   i   CURRENT _ NUM _ INSTANCES   i   устанавливать   текстура   для   данный   объект   дип   for   int   j   0   j   NUM _ TEXTURES _ IN _ COMPLEX _ MATERIAL   j   glActiveTexture   GL _ TEXTURE0   j   glBindTexture   GL _ TEXTURE _ 2D   array _ of _ textures   counter   TEX _ ARRAY _ SIZE   glBindSampler   j   Sampler _ linear   counter   glDrawRangeElements   GL _ TRIANGLES   i   BOX _ NUM _ VERTS   i   1   BOX _ NUM _ VERTS   BOX _ NUM _ INDICES   GL _ UNSIGNED _ INT   GLvoid   i   BOX _ NUM _ INDICES   sizeof   int   дип   рендерим   объект   else   if   test _ type   TEXTURES _ ARRAY _ TEST   устанавливать   текстурный   массив   для   весь   дип   сразу   glActiveTexture   GL _ TEXTURE0   glBindTexture   GL _ TEXTURE _ 2D _ ARRAY   texture _ array _ id   glBindSampler   0   Sampler _ linear   переменный   в   шейдер   в   который   передавать   индекс   текстура   использовать   дынный   объект   static   int   textureArray _ usedTex _ varLocation   glGetUniformLocation   textureArray _ shader   programm _ id   used _ textures _ i   textureArray _ shader   bind   float   used _ textures _ i   6   for   int   i   0   i   CURRENT _ NUM _ INSTANCES   i   заполнять   данные   какой   текстура   использовать   данный   объект   for   int   j   0   j   6   j   used _ textures _ i   j   counter   TEX _ ARRAY _ SIZE   counter   glUniform1fv   textureArray _ usedTex _ varLocation   6   used _ textures _ i   0   передавать   параметр   в   шейдер   glDrawRangeElements   GL _ TRIANGLES   i   BOX _ NUM _ VERTS   i   1   BOX _ NUM _ VERTS   BOX _ NUM _ INDICES   GL _ UNSIGNED _ INT   GLvoid   i   BOX _ NUM _ INDICES   sizeof   int   дип   рендерим   объект   смена   текстура   для   1000   объект   занимать   3   27   ms   с   учет   то   что   для   каждый   объект   мы   устанавливать   NUM _ TEXTURES _ IN _ COMPLEX _ MATERIAL   в   наш   случай   6   текстура   нужно   быть   это   учитывать   при   вычисление   стоимость   glBindTexture   использование   массив   текстура   также   для   рендер   1000   объект   занимать   0   87   ms   сравнительный   оценка   стоимость   стейт   низко   приводить   таблица   со   стомость   время   выполнение   весь   проводить   тест   таблица   1   время   выполнение   тест   на   смена   различный   стейт   тип   тест   1000   дип   SIMPLE _ DIPS _ TEST   0   41   FBO _ CHANGE _ TEST   1   97   SHADERS _ CHANGE _ TEST   2   9   UNIFORMS _ SIMPLE _ CHANGE _ TEST   1   27   UNIFORMS _ SSBO _ CHANGE _ TEST   0   8   VBO _ CHANGE _ TEST   0   95   ARRAY _ OF _ TEXTURES _ TEST   3   27   TEXTURES _ ARRAY _ TEST   0   87   исходить   из   результат   тест   можно   примерно   оценивать   стоимость   изменение   каждый   стейт   абсолютный   стоимость   указывать   на   1000   вызов   API   функция   относительный   стоимость   считать   по   отношение   к   стоимость   дип   glDrawRangeElements   таблица   2   стоимость   API   вызов   на   1000   вызов   API   вызов   абсолютный   стоимость   относительный   стоимость   glBindFramebuffer   9   44   2314   glUseProgram   2   49   610   glBindVertexArray   0   54   132   glBindTexture   0   48   116   glDrawRangeElements   0   41   100   glUniform4fv   0   09   21   стоять   конечно   весьма   осторожно   относиться   к   данный   измерение   так   как   они   быть   меняться   в   зависимость   от   версия   драйвер   и   железо   страница   1   2   следующий   instancing   OpenGL   8   февраль   2017   обновление   31   дека   2018   комментарий   74   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   GameDev   ru   разработка   игра   2001   2019