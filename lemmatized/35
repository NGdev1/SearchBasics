   синхронизация   в   Vulkan   график   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   FAQ   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиграфика   синхронизация   в   Vulkan   автор   A   один   из   важный   отличие   Vulkan   от   более   старый   графический   API   это   больший   контроль   над   синхронизация   как   с   CPU   так   и   внутри   GPU   и   как   всегда   многопоточность   и   синхронизация   это   достаточно   сложный   тема   стоять   помнить   что   драйвер   Vulkan   не   обязывать   оптимизировать   вызов   API   поэтому   для   максимальный   производительность   синхронизация   должный   быть   расставлять   наиболее   оптимальный   образ   термин   синхронизация   между   команда   на   Device   порядок   выполнение   команда   на   Device   синхронизация   между   очередь   и   между   батч   синхронизация   между   Host   и   Device   синхронизация   при   вызов   команда   на   Host   термин   для   больший   совместимость   с   оригинальный   документация   многий   термин   не   быть   переводиться   либо   английский   версия   термин   быть   указывать   рядом   в   скобка   Host   тот   кто   использовать   Vulkan   API   обычно   это   код   выполнять   на   процессор   CPU   Device   тот   кто   выполнять   команда   это   драйвер   и   дискретный   или   интегрировать   видеокарта   GPU   но   например   при   софтварный   реализация   это   мочь   быть   и   процессор   CPU   драйвер   здесь   под   это   пониматься   программный   и   аппаратный   часть   скрывать   за   Vulkan   API   в   документация   для   это   использоваться   термин   implementation   очередь   VkQueue   очередь   команда   выполнять   на   Device   Execution   dependency   это   зависимость   от   порядок   выполнение   команда   все   что   начинать   выполняться   быть   завершать   до   начало   выполнение   следующий   операция   Memory   dependency   аналогично   execution   dependency   но   еще   и   весь   запись   в   память   быть   завершать   до   начало   выполнение   следующий   операция   синхронизация   между   команда   на   Device   все   современный   GPU   выполнять   команда   параллельно   вызов   отрисовка   вызов   вычислительный   шейдер   стараться   занимать   весь   свободный   вычислительный   ядро   GPU   единственный   что   мочь   они   помешать   этот   наличие   зависимость   между   команда   синхронизация   GPU   содержать   конвейер   который   разделять   на   этап   на   каждый   этап   выполняться   только   определенный   операция   некоторый   этап   выполняться   последовательно   например   фрагментный   шейдер   fragment   shader   выполняться   всегда   после   вершинный   шейдер   vertex   shader   а   вершинный   шейдер   после   чтение   из   вершинный   буфер   vertex   input   этап   рисование   вычисление   compute   shader   и   копирование   transfer   всегда   запускаться   с   начало   конвейер   top   of   pipe   и   завершаться   в   конец   bottom   of   pipe   в   документация   использоваться   понятие   logically   earlier   и   logically   latest   они   означать   этап   располагать   выше   и   низко   по   схема   от   выбирать   этап   и   не   включать   в   себя   этап   выполнять   параллельно   глава   6   1   2   pipeline   stages   для   установка   зависимость   между   разный   команда   или   между   этап   конвейер   использоваться   команда   vkCmdPipelineBarrier   параметр   srcStageMask   указывать   какой   этап   должный   завершаться   до   то   как   начинать   выполняться   этап   указывать   в   dstStageMask   то   быть   определять   execution   dependency   на   каждый   этап   быть   доступ   только   к   некоторый   вид   кеш   они   хранить   промежуточный   значение   при   запись   либо   сохранять   значение   для   быстрый   чтение   в   некоторый   случай   рассматривать   ниже   кеш   сбрасываться   неявно   здесь   же   рассматривать   явный   сброс   кеш   глава   6   1   3   access   mask   функция   vkCmdPipelineBarrier   принимать   массив   из   VkMemoryBarrier   VkBufferMemoryBarrier   и   VkImageMemoryBarrier   где   srcAccessMask   и   dstAccessMask   определять   memory   dependency   какой   данные   из   кеш   должный   быть   видеть   srcAccessMask   и   где   этот   данные   быть   использоваться   dstAccessMask   VkMemoryBarrier   создавать   global   memory   barrier   который   затрагивать   весь   последующий   этап   конвейер   и   весь   последующий   команда   внутри   очередь   VkQueue   VkBufferMemoryBarrier   и   VkImageMemoryBarrier   позволять   явно   указывать   диапазон   данные   для   который   сбрасываться   кеш   и   давать   возможность   драйвер   выполнять   другой   команда   который   не   зависеть   от   это   диапазон   данные   операция   чтение   мочь   выполняться   параллельно   запись   после   чтение   требовать   только   execution   dependency   то   быть   параметр   srcAccessMask   и   dstAccessMask   указывать   необязательно   запись   после   запись   и   чтение   после   запись   требовать   memory   dependency   параметр   srcAccessMask   обязательно   должный   содержать   флаг   указывать   где   происходить   запись   а   параметр   dstAccessMask   флаг   где   быть   происходить   чтение   VkImageMemoryBarrier   содержать   поле   oldLayout   и   newLayout   который   нужный   для   image   layout   transition   Image   layout   нужный   чтобы   оптимизировать   доступ   к   данные   текстура   для   некоторый   вид   операция   чтение   и   запись   так   например   VK _ IMAGE _ LAYOUT _ SHADER _ READ _ ONLY _ OPTIMAL   оптимизировать   данный   текстура   для   чтение   в   шейдер   а   VK _ IMAGE _ LAYOUT _ COLOR _ ATTACHMENT _ OPTIMAL   позволять   драйвер   сжимать   данные   при   рисование   в   текстура   что   увеличивать   пропускной   способность   память   но   переход   из   сжатый   формат   в   несжатый   формат   например   в   VK _ IMAGE _ LAYOUT _ GENERAL   приводить   к   разжатие   и   потеря   время   VkBufferMemoryBarrier   и   VkImageMemoryBarrier   содержать   поле   srcQuueFamilyIndex   и   dstQueueFamilyIndex   для   операция   queue   family   ownership   transfer   если   передача   между   очередь   не   нужный   то   указываться   флаг   VK _ QUEUE _ FAMILY _ IGNORED   подробно   передача   между   очередь   разбирать   в   пример   с   асинхронный   вычисление   функция   vkCmdPipelineBarrier   не   давать   прямой   контроль   над   механизм   инвалидация   кеш   так   запись   из   кеш   в   глобальный   память   мочь   происходить   и   без   вызов   синхронизация   и   пропустить   в   этот   место   барьер   никак   не   отражаться   на   работа   программа   но   на   другой   GPU   на   другой   драйвер   или   просто   при   другой   обстоятельство   пропустить   барьер   приводить   к   неправильный   работа   программа   слой   валидация   не   отслеживать   насколько   правильно   настраивать   memory   dependencies   это   достаточный   сложный   задача   но   слой   валидация   проверять   image   layout   transition   и   queue   ownership   transfer   что   уже   неплохо   событие   VkEvent   работать   аналогично   барьер   но   разделять   на   два   часть   сигнал   и   ожидание   также   как   и   барьер   событие   работать   только   внутри   один   очередь   и   позволять   более   явно   указывать   зависимость   между   команда   проход   рендер   VkRenderPass   объединять   в   себя   зависимость   для   текстура   в   который   идти   рисование   до   и   после   проход   рендер   а   также   зависимость   между   отдельный   этап   рисование   subpass   зависимость   указываться   через   VkSubpassDependency   по   аналогия   с   барьер   барьер   внутри   проход   рендер   разрешать   но   для   они   существовать   ограничение   нужно   указывать   VkSubpassDependency   где   srcSubpass   и   dstSubpass   равный   и   параметр   барьер   должный   совпадать   с   то   что   быть   указывать   в   VkSubpassDependency   глава   7   render   pass   subpass   self   dependency   команда   vkCmdWriteTimestamp   создавать   execution   barrier   что   мочь   препятствовать   распараллеливание   команда   не   стоить   использовать   этот   команда   слишком   часто   а   точный   время   выполнение   каждый   команда   мочь   показывать   только   специализированный   профайлер   порядок   выполнение   команда   на   Device   в   документация   явно   определять   только   порядок   в   который   команда   записывать   на   сторона   Host   быть   прочитывать   на   сторона   Device   это   submission   order   команда   vkQueueSubmit   в   предел   один   очередь   читаться   на   сторона   Device   в   тот   же   порядок   в   какой   быть   вызывать   на   сторона   Host   каждый   командный   буфер   быть   прочитывать   только   после   прочтение   предыдущий   командный   буфер   в   батч   либо   последний   командный   буфер   предыдущий   батч   команда   внутри   командный   буфер   читаться   в   тот   порядок   в   который   они   быть   записывать   в   буфер   порядок   в   который   выполняться   команда   определяться   только   через   зависимость   создавать   барьер   и   событие   командный   буфер   не   создавать   никакой   дополнительный   синхронизация   при   переход   на   следующий   командный   буфер   происходить   только   смена   состояние   пайпалайн   дескриптор   и   так   далее   на   схема   красный   линия   между   команда   зависимость   для   ресурс   memory   dependency   красный   полоса   глобальный   барьер   global   execution   barrier   для   проход   рендер   VkRenderPass   существовать   дополнительный   правило   каждый   отдельный   подпроход   subpass   мочь   выполняться   параллельно   с   другой   и   в   любой   порядок   если   между   они   не   устанавливать   зависимость   через   VkSubpassDependency   внутри   подпроход   subpass   команда   рисование   выполняться   в   соответствие   с   порядок   генерация   примитив   primitive   order   и   порядок   растеризация   rasterization   order   синхронизация   между   очередь   и   между   батч   зависимость   между   батч   внутри   один   очередь   или   между   разный   очередь   а   также   с   presentation   engine   устанавливаться   через   семафор   VkSemaphore   на   схема   стрелка   указывать   зависимость   создавать   семафор   семафор   мочь   быть   только   в   два   состояние   сигнальный   и   не   сигнальный   если   передаваться   в   функция   vkQueueSubmit   и   vkQueueBindSparse   в   качество   параметр   pSignalSemaphores   то   сразу   переводиться   в   не   сигнальный   состояние   затем   ожидать   завершение   батч   на   сторона   Device   и   переходить   в   сигнальный   состояние   если   передаваться   в   качество   параметр   pWaitSemaphores   то   блокировать   выполнение   батч   пока   семафор   не   переходить   в   сигнальный   состояние   после   это   сбрасывать   семафор   в   не   сигнальный   состояние   команда   vkAcquireNextImageKHR   переводить   семафор   в   сигнальный   состояние   когда   presentation   engine   завершать   работа   с   изображение   и   можно   он   использовать   для   рисование   новый   кадр   несколько   батч   не   мочь   ожидать   сигнал   от   один   и   тот   же   семафор   между   операция   сигнал   семафор   и   ожидание   создаваться   memory   dependency   весь   данные   из   кеш   быть   записывать   в   глобальный   память   и   весь   команда   в   очередь   завершать   выполнение   до   начало   этап   указывать   в   pWaitDstStageMask   глава   6   4   1   semaphore   signaling   глава   6   4   2   semaphore   waiting   функция   vkQueuePresentKHR   дополнительно   гарантировать   что   весь   запись   в   текстура   свопчейн   на   который   указывать   индекс   pImageIndices   быть   видеть   при   вывод   изображение   на   экран   синхронизация   между   Host   и   Device   для   это   быть   явный   примитив   синхронизация   VkFence   а   также   неявный   синхронизация   при   вызов   некоторый   функция   VkFence   передаваться   в   функция   vkQueueSubmit   vkQueueBindSparse   vkAcquireNextImageKHR   при   завершение   выполнение   функция   fence   переводиться   в   сигнальный   состояние   и   находиться   в   он   до   явный   вызов   vkResetFences   дождаться   завершение   команда   можно   вызов   блокировать   функция   vkWaitForFences   команда   vkQueueWaitIdle   vkDeviceWaitIdle   работать   схожий   образ   но   ожидать   завершение   абсолютно   весь   команда   в   очередь   и   на   все   GPU   устройство   соответственно   вызов   vkWaitForFences   vkQueueWaitIdle   vkDeviceWaitIdle   создавать   global   memory   dependency   значит   весь   изменение   на   Device   быть   видеть   для   весь   последующий   команда   на   Device   и   на   Host   VkEvent   мочь   быть   перевести   в   сигнальный   состояние   на   сторона   Host   тогда   блокировка   происходить   на   сторона   Device   при   вызов   vkCmdWaitEvents   где   в   srcStageMask   указывать   VK _ PIPELINE _ STAGE _ HOST _ BIT   это   можно   использовать   в   редкий   случай   когда   необходимо   передавать   данные   на   Device   уже   после   начало   выполнение   командный   буфер   в   этот   случай   нужно   явно   указывать   memory   dependency   между   Host   и   Device   добавлять   VkMemoryBarrier   где   в   srcAccessMask   содержаться   VK _ ACCESS _ HOST _ WRITE _ BIT   команда   vkQueueSubmit   делать   неявный   синхронизация   при   который   весь   изменение   память   на   Host   становиться   видеть   на   Device   что   аналогично   вызывать   vkFlushMappedMemoryRanges   для   весь   изменение   память   глава   6   9   команда   vkFlushMappedMemoryRanges   делать   видимый   на   Device   весь   изменение   память   на   Host   но   только   для   заданный   диапазон   для   память   выделять   на   куча   с   флаг   VK _ MEMORY _ PROPERTY _ COHERENT _ BIT   вызов   этот   функция   не   иметь   эффект   так   как   весь   изменение   сразу   же   отправляться   на   Device   команда   vkInvalidateMappedMemoryRanges   делать   видимый   на   Host   весь   изменение   память   на   Device   но   только   для   заданный   диапазон   синхронизация   при   вызов   команда   на   Host   Vulkan   позволять   обращаться   к   API   из   любой   поток   но   требовать   чтобы   доступ   к   некоторый   данные   осуществляться   последовательно   для   это   подходить   mutex   spinlock   и   другой   примитив   синхронизация   для   архитектура   с   relaxed   memory   ordering   например   ARM   требоваться   инвалидация   кеш   при   использование   std   mutex   это   происходить   автоматически   но   если   вы   использовать   самописный   spinlock   на   атомарный   операция   то   об   это   стоить   помнить   глава   2   6   ссылка   документация   по   vulkan   пример   синхронизация   объяснение   барьер   от   AMD   еще   один   попытка   объяснять   барьер   очень   подробный   разбор   устройство   GPU   работа   драйвер   синхронизация   и   так   далее   стоять   прочитывать   весь   6   часть   объяснять   context   rolls   ограниченный   количество   команда   который   мочь   выполняться   параллельно   vulkan   sync   более   детально   описывать   как   работать   память   кеш   сжатие   текстура   и   так   далее   теперь   знать   о   весь   сложность   синхронизация   стоять   задумываться   а   нужно   ли   вы   это   в   качество   альтернатива   быть   множество   обертка   который   упрощать   использование   графический   api   цена   некоторый   ограничение   функционал   и   небольшой   замедление   на   CPU   Vulkan   EZ   разработка   AMD   автоматизировать   расстановка   пайплайн   барьер   и   сохранять   прямой   доступ   к   vulkan   api   FrameGraph   разрабатывать   автор   статья   абстрагировать   от   Vulkan   заменять   весь   синхронизация   на   зависимость   между   батч   и   зависимость   между   таска   внутри   батч   Falcor   более   высокоуровневый   абстракция   от   Nvidia   поддерживать   DX12   DXR   Vulkan   предназначать   для   прототипирование   Granite   рендеры   граф   автоматизировать   расстановка   барьер   между   рендер   пасс   DiligentEngine   абстракция   над   весь   графический   API   поддерживать   автоматический   и   ручной   расстановка   синхронизация   далее   идти   подробный   разбор   пример   2   синхронизация   между   Host   и   Device   семафор   многопоточность   3   пример   барьер   4   синхронизация   между   этап   конвейер   5   асинхронный   вычисление   страница   1   2   3   4   5   следующий   Vulkan   26   февраль   2019   комментарий   36   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   GameDev   ru   разработка   игра   2001   2019