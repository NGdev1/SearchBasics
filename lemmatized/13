   dynamic   vertex   pulling   в   direct3d11   график   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   faq   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиграфика   dynamic   vertex   pulling   в   direct3d11   автор   bazhenovc   данный   статья   рассказывать   про   то   как   можно   рисовать   миллион   уникальный   объект   в   direct3d11   с   минимальный   оверхед   на   cpu   и   максимально   близкий   к   d3d12   или   amd   mantle   скорость   в   статья   показывать   пример   использование   так   называть   structured   buffers   мотивация   основной   идея   логический   и   физический   буфер   управление   константа   для   каждый   объект   шейдер   и   как   это   вообще   рисовать   а   что   делать   с   текстура   недостаток   и   ограничение   демо   и   исходник   ссылка   и   литература   мотивация   мотивация   очень   простой   в   текущий   проект   резко   становиться   не   хватать   возможность   обычный   инстансинг   не   хватать   становиться   из   за   разнообразие   возможный   дерево   для   который   работать   простой   арифметика   1   9   базовый   вид   дерево   2   3   стадия   рост   для   каждый   дерево   росток   деревце   большой   дерево   3   3   стадия   здоровье   для   каждый   стадия   рост   дерево   здоровый   больной   умирать   4   5   уровень   детализация   lod   для   каждый   стадия   здоровье   каждый   стадия   рост   каждый   дерево   включая   импостер   это   порождать   серьезный   комбинаторный   взрыв   из   за   что   эффективность   инстансинг   сильно   снижаться   ниже   я   предлагать   решение   позволять   обходить   проблема   такой   комбинаторный   взрыв   и   рисовать   весь   этот   дерево   за   1   вызов   отрисовка   draw   call   dip   иметь   при   это   отдельный   набор   константа   для   каждый   объект   и   потенциально   уникальный   меш   для   каждый   же   объект   основной   идея   d3d11   и   opengl   4   0   поддерживать   rw   structuredbuffer   d3d   и   arb _ shader _ storage _ buffer _ object   gl   который   представлять   себя   некий   буфер   со   структурированный   данные   из   который   шейдер   мочь   читать   по   произвольный   индекс   я   предлагать   использовать   2   глобальный   буфер   для   хранение   вершина   индекс   и   в   вершинный   шейдер   считывать   оттуда   вершина   по   vertex   id   такой   образ   можно   передавать   смещение   offset   в   глобальный   буфер   как   константа   и   начинать   читать   вершина   начинать   с   этот   смещение   как   это   все   реализовать   логический   и   физический   буфер   вводить   понятие   логический   буфер   и   физический   буфер   физический   буфер   представлять   себя   область   в   память   gpu   в   который   храниться   абсолютно   весь   вершина   или   индекс   который   необходимый   для   рисование   весь   геометрия   этот   способ   логический   буфер   представлять   себя   структура   данные   состоять   из   смещение   в   физический   буфер   и   размер   один   блок   данные   этот   два   понятие   легко   проиллюстрировать   на   следующий   картинка   в   d3d11   и   с   для   логический   буфер   много   данные   не   нужно   struct   dxlogicalmeshbuffer   final   uint8 _ t   data   nullptr   size _ t   datasize   0   size _ t   dataformatstride   0   size _ t   physicaladdress   0   buffertype   type   vertex   or   index   buffer   проходиться   по   поле   этот   класс   data   указатель   на   данный   буфер   вершина   или   индекс   datasize   размер   массив   данные   в   байт   dataformatstride   размер   один   элемент   массив   в   байт   physicaladdress   смещение   в   физический   буфер   по   который   находиться   данные   этот   буфер   этот   поле   заполняться   при   перестроение   физический   буфер   об   это   ниже   при   создание   логический   буфер   физический   буфер   должный   знать   про   логический   буфер   и   создавать   место   для   хранение   данный   класс   физический   буфер   выглядеть   следующий   образ   struct   dxphysicalmeshbuffer   final   id3d11buffer   physicalbuffer   nullptr   id3d11shaderresourceview   physicalbufferview   nullptr   size _ t   physicaldatasize   0   bool   isdirty   false   typedef   dynamicarray   dxlogicalmeshbuffer   pagearray   pagearray   allpages   dxphysicalmeshbuffer   default   inline   dxphysicalmeshbuffer   if   physicalbuffer   nullptr   physicalbuffer   release   if   physicalbufferview   nullptr   physicalbufferview   release   void   allocate   dxlogicalmeshbuffer   logicalbuffer   void   release   dxlogicalmeshbuffer   logicalbuffer   void   rebuildpages   very   expensive   operation   поле   класс   нужный   для   следующий   physicalbuffer   буфер   где   лежать   вершина   или   индекс   physicalbufferview   shader   resource   view   для   доступ   к   данные   из   шейдер   physicaldatasize   размер   физический   буфер   в   байт   isdirty   флажок   который   показывать   необходимость   обновление   буфер   буфер   необходимо   обновлять   после   каждый   аллокация   деаллокация   логический   буфер   allpages   весь   логический   буфер   аллоцированный   в   этот   физический   буфер   при   каждый   создание   и   удаление   логический   буфер   необходимо   информировать   об   это   физический   буфер   операция   allocate   release   тривиальный   и   в   дополнительный   пояснение   не   нуждаться   void   dxphysicalbuffer   allocate   dxlogicalmeshbuffer   logicalbuffer   allpages   add   logicalbuffer   isdirty   true   void   dxphysicalbuffer   release   dxlogicalmeshbuffer   logicalbuffer   allpages   remove   logicalbuffer   isdirty   true   гораздо   интересно   рассматривать   функция   rebuildpages   этот   функция   должный   создавать   физический   буфер   и   заполнять   он   данные   из   весь   использовать   логический   буфер   в   direct3d11   для   это   нужно   создавать   d3d   шный   буфер   который   можно   отображать   map   в   оперативный   память   обновлять   в   он   данные   привязывать   bind   как   shader   resource   и   использовать   как   structured   buffer   size _ t   vfstride   allpages   0   dataformatstride   todo   right   now   will   not   work   with   different   strides   size _ t   numelements   physicaldatasize   vfstride   if   physicalbuffer   nullptr   physicalbuffer   release   if   physicalbufferview   nullptr   physicalbufferview   release   d3d11 _ buffer _ desc   bufferdesc   bufferdesc   bindflags   d3d11 _ bind _ shader _ resource   bufferdesc   bytewidth   physicaldatasize   bufferdesc   usage   d3d11 _ usage _ dynamic   bufferdesc   miscflags   d3d11 _ resource _ misc _ buffer _ structured   bufferdesc   structurebytestride   vfstride   bufferdesc   cpuaccessflags   d3d11 _ cpu _ access _ write   if   failed   g _ pd3ddevice   createbuffer   bufferdesc   nullptr   physicalbuffer   handleerror   handle   your   error   here   return   обязательно   нужно   прослеживать   что   structurebytestride   совпадать   со   структура   который   пытаться   читать   вершинный   шейдер   также   нужный   возможность   запись   в   буфер   со   сторона   cpu   после   это   нужно   создавать   shader   resource   view   это   тривиальный   операция   d3d11 _ shader _ resource _ view _ desc   viewdesc   std   memset   viewdesc   0   sizeof   viewdesc   viewdesc   format   dxgi _ format _ unknown   viewdesc   viewdimension   d3d11 _ srv _ dimension _ buffer   viewdesc   buffer   elementwidth   numelements   if   failed   g _ pd3ddevice   createshaderresourceview   physicalbuffer   viewdesc   physicalbufferview   todo   error   handling   return   теперь   переходить   непосредственно   к   заполнение   физический   буфер   алгоритм   следующий   1   отображать   map   адресный   пространство   только   что   создавать   физический   буфер   в   оперативный   память   2   проходиться   цикл   по   весь   ассоциировать   логический   буфер   для   каждый   логический   буфер   a   посчитать   смещение   логический   буфер   в   физический   буфер   physicaladdress   b   скопировать   данные   из   логический   буфер   в   отображать   mapped   область   память   физический   буфер   по   нужный   смещение   c   переходить   к   следующий   логический   буфер   3   сделать   unmap   физический   буфер   код   довольно   простой   и   выглядеть   следующий   образ   fill   the   physical   buffer   d3d11 _ mapped _ subresource   mappeddata   std   memset   mappeddata   0   sizeof   mappeddata   if   failed   g _ pimmediatecontext   map   physicalbuffer   0   d3d11 _ map _ write _ discard   0   mappeddata   handleerror   insert   error   handling   here   return   uint8 _ t   dataptr   reinterpret _ cast   uint8 _ t   mappeddata   pdata   size _ t   pageoffset   0   for   size _ t   i   0   i   allpages   getsize   i   dxlogicalmeshbuffer   logicalbuffer   allpages   i   copy   logical   data   to   the   mapped   physical   data   std   memcpy   dataptr   pageoffset   logicalbuffer   data   logicalbuffer   datasize   calculate   physical   address   logicalbuffer   physicaladdress   pageoffset   logicalbuffer   dataformatstride   calculate   offset   pageoffset   logicalbuffer   datasize   g _ pimmediatecontext   unmap   physicalbuffer   0   стоять   замечать   что   перестроение   физический   буфер   очень   дорогой   операция   в   наш   случай   для   вышеуказанный   количество   разный   дерево   она   занимать   300   500   миллисекунда   высокий   стоимость   связанный   с   большой   количество   данные   который   необходимо   пересылать   на   gpu   речь   идти   о   десяток   мегабайт   давать   поэтому   не   рекомендоваться   перестраивать   физический   буфер   на   каждый   чих   полный   функция   rebuildpages   для   справка   хранение   и   рисование   геометрия   такой   способ   подразумевать   также   и   нетривиальный   управление   константа   о   который   сейчас   пойти   речь   управление   константа   для   каждый   объект   традиционный   константный   буфер   в   данный   ситуация   не   подходить   по   очевидный   причина   в   связь   с   это   не   оставаться   другой   выбор   кроме   как   использовать   еще   один   глобальный   буфер   аналогичный   физический   буфер   описывать   выше   помимо   это   туда   необходимо   передавать   информация   про   логический   вершинный   и   индексный   буфер   для   текущий   инстанс   тип   рисовать   геометрия   индексировать   или   нет   и   количество   вершина   создание   такой   буфер   ничто   не   отличаться   от   создание   описывать   высокий   физический   буфер   поэтому   останавливаться   подробно   на   он   не   быть   создание   общий   константный   буфер   скрывать   std   memset   bufferdesc   0   sizeof   bufferdesc   bufferdesc   bindflags   d3d11 _ bind _ shader _ resource   bufferdesc   bytewidth   databuffersize   bufferdesc   usage   d3d11 _ usage _ dynamic   bufferdesc   miscflags   d3d11 _ resource _ misc _ buffer _ structured   bufferdesc   structurebytestride   stride   bufferdesc   cpuaccessflags   d3d11 _ cpu _ access _ write   if   failed   g _ pd3ddevice   createbuffer   bufferdesc   nullptr   databuffer   handleerror   handle   your   error   here   return   d3d11 _ shader _ resource _ view _ desc   viewdesc   std   memset   viewdesc   0   sizeof   viewdesc   viewdesc   format   dxgi _ format _ unknown   viewdesc   viewdimension   d3d11 _ srv _ dimension _ buffer   viewdesc   buffer   elementwidth   numinstances   if   failed   g _ pd3ddevice   createshaderresourceview   databuffer   viewdesc   dataview   handleerror   handle   your   error   here   return   при   заполнение   этот   буфер   первый   4   32   битный   регистр   я   использовать   для   служебный   информация   шейдер   для   считывание   данные   из   физический   буфер   также   для   упрощение   код   пример   я   подразумевать   что   константа   в   шейдер   всегда   иметь   размер   2048   разуметься   в   реальный   жизнь   надо   быть   этот   ограничение   убирать   этот   данные   выглядеть   следующий   образ   struct   internaldata   uint32 _ t   vb   uint32 _ t   ib   uint32 _ t   drawcalltype   uint32 _ t   count   после   этот   4   число   идти   обычный   константа   такой   как   матрица   проекция   который   необходимый   для   рисование   обычный   геометрия   сейчас   небольшой   лирический   отступление   я   напрямую   ничто   не   рисовать   вместо   это   я   использовать   вот   такой   структура   который   представлять   себя   1   вызов   отрисовка   сюда   же   идти   и   константа   и   весь   остальной   необходимый   для   рисование   struct   drawcall   final   enum   type   uint32 _ t   draw   0   drawindexed   1   enum   constantbuffersize   2048   todo   remove   hardcode   enum   maxtextures   8   uint8 _ t   constantbufferdata   constantbuffersize   dxlogicalmeshbuffer   vertexbuffer   dxlogicalmeshbuffer   indexbuffer   uint32 _ t   count   uint32 _ t   startvertex   uint32 _ t   startindex   type   type   для   пример   я   сильно   упрощать   этот   структура   чтобы   не   утомлять   читатель   лишний   подробность   приложение   заполнять   массив   этот   структура   использовать   примерно   следующий   набор   функция   на   который   подробно   останавливаться   также   не   быть   обычный   буфер   команда   что   с   он   взять   то   drawing   api   скрывать   typedef   dynamicarray   drawcall   drawcallarray   drawcallarray   drawcalls   inline   void   setvertexbuffer   bufferhandle   handle   currentdrawcall   vertexbuffer   handle   inline   void   setindexbuffer   bufferhandle   handle   currentdrawcall   indexbuffer   handle   inline   void   setconstants   uint32 _ t   idx   void   constantsdata   size _ t   constantssize   std   memcpy   currentdrawcall   constantbufferdata   idx   drawcall   constantbuffersize   constantsdata   constantssize   currentdrawcall   usedconstantbuffers   1   idx   inline   void   draw   uint32 _ t   count   uint32 _ t   startvertex   currentdrawcall   count   count   currentdrawcall   startvertex   startvertex   currentdrawcall   startindex   0   currentdrawcall   type   drawcall   draw   drawcalls   add   currentdrawcall   std   memset   currentdrawcall   0   sizeof   currentdrawcall   inline   void   drawindexed   uint32 _ t   count   uint32 _ t   startindex   uint32 _ t   startvertex   currentdrawcall   count   count   currentdrawcall   startvertex   startvertex   currentdrawcall   startindex   startindex   currentdrawcall   type   drawcall   drawindexed   drawcalls   add   currentdrawcall   std   memset   currentdrawcall   0   sizeof   currentdrawcall   после   создание   буфер   команда   необходимо   скопировать   в   глобальный   буфер   с   константа   весь   константа   из   буфер   команда   после   что   заполнять   internaldata   и   собственно   нарисовать   весь   этот   безобразие   обновление   константа   тривиальный   просто   проходить   цикл   по   буфер   команда   и   копировать   нужный   данные   в   нужный   место   update   constants   d3d11 _ mapped _ subresource   mappeddata   if   failed   g _ pimmediatecontext   map   psimpl   constantbuffer   databuffer   0   d3d11 _ map _ write _ discard   0   mappeddata   todo   error   handling   return   uint8 _ t   dataptr   reinterpret _ cast   uint8 _ t   mappeddata   pdata   for   size _ t   i   0   i   numinstances   i   size _ t   offset   i   internal   drawcall   constantbuffersize   const   internal   drawcall   call   queue   getdrawcalls   i   std   memcpy   dataptr   offset   call   constantbufferdata   internal   drawcall   constantbuffersize   fill   internal   data   structure   internaldata   idata   reinterpret _ cast   internaldata   dataptr   offset   dxlogicalmeshbuffer   vertexbuffer   static _ cast   dxlogicalmeshbuffer   call   vertexbuffer   value   if   vertexbuffer   nullptr   idata   vb   vertexbuffer   physicaladdress   dxlogicalmeshbuffer   indexbuffer   static _ cast   dxlogicalmeshbuffer   call   indexbuffer   value   if   indexbuffer   nullptr   idata   ib   indexbuffer   physicaladdress   idata   drawcalltype   call   type   idata   count   call   count   g _ pimmediatecontext   unmap   psimpl   constantbuffer   databuffer   0   все   теперь   данный   готовый   для   непосредственный   отрисовка   средство   d3d   шейдер   и   как   это   вообще   рисовать   после   то   как   данные   быть   подготовить   наступать   время   рисование   для   это   просто   выставлять   шейдер   физический   буфер   и   глобальный   константный   буфер   и   делать   drawinstanced   id3d11shaderresourceview   vbibviews   2   g _ physicalvertexbuffer   physicalbufferview   g _ physicalindexbuffer   physicalbufferview   g _ pimmediatecontext   vssetshaderresources   0   2   vbibviews   g _ pimmediatecontext   vssetshaderresources   0   2   1   psimpl   constantbuffer   dataview   g _ pimmediatecontext   hssetshaderresources   0   2   1   psimpl   constantbuffer   dataview   g _ pimmediatecontext   dssetshaderresources   0   2   1   psimpl   constantbuffer   dataview   g _ pimmediatecontext   gssetshaderresources   0   2   1   psimpl   constantbuffer   dataview   g _ pimmediatecontext   pssetshaderresources   0   2   1   psimpl   constantbuffer   dataview   g _ pimmediatecontext   drawinstanced   maxdrawcallvertexcount   numinstances   0   0   почти   готовый   оставаться   объяснять   некоторые   важный   момент   1   drawinstanced   надо   вызывать   с   максимальный   количество   вершина   который   быть   в   буфер   команда   это   необходимый   потому   что   вызов   отрисовка   у   мы   1   и   если   у   меш   разный   количество   вершина   или   индекс   это   нужно   как   то   учитывать   я   предпочитать   всегда   рисовать   большой   количество   вершина   а   лишний   отсекать   отправлять   они   за   clipping   plane   такой   образ   появляться   много   дополнительный   ненужный   нагрузка   на   вершинный   шейдер   поэтому   надо   следить   за   то   чтобы   разница   между   минимальный   и   максимальный   vertex   count   быть   в   разумный   предел   500   600   вершина   нужно   помнить   что   этот   разница   равный   количество   мусорный   вершина   на   каждый   инстанс   и   она   расти   со   скорость   геометрический   прогрессия   в   квадрат   следить   за   художник   2   один   вызов   drawinstanced   достаточно   чтобы   рисовать   как   индексировать   так   и   не   индексировать   геометрия   потому   что   весь   работа   с   вершина   делаться   рука   в   шейдер   3   топология   вроде   trianglestrip   trianglefan   и   они   подобный   не   поддерживаться   по   очевидный   причина   поддерживаться   только   топология   с   изолированный   примитив   trianglelist   pointlist   list   вершинный   шейдер   который   считывать   вершина   с   индекс   и   обрабатывать   они   не   должный   вызывать   особый   сложность   в   первый   очередь   надо   продублировать   в   шейдер   весь   структура   который   использоваться   со   сторона   cpu   структура   вершина   структура   константа   и   т   д   vertex   struct   vertexdata   float3   position   float2   texcoord0   float2   texcoord1   float3   normal   structuredbuffer   vertexdata   g _ vertexbuffer   structuredbuffer   uint   g _ indexbuffer   pipeline   state   define   draw   0   define   draw _ indexed   1   struct   constantdata   uint4   internaldata   float4x4   world   float4x4   view   float4x4   projection   float4   strideoffset   2048   200   16   structuredbuffer   constantdata   g _ constantbuffer   далеко   код   который   считывать   константа   и   служебный   данные   из   буфер   и   обрабатывать   вершина   обращать   внимание   на   то   как   реализовать   индексировать   и   неиндексированный   режим   uint   instanceid   input   instanceid   uint   vertexid   input   vertexid   uint   vbid   g _ constantbuffer   instanceid   internaldata   0   uint   ibid   g _ constantbuffer   instanceid   internaldata   1   uint   drawtype   g _ constantbuffer   instanceid   internaldata   2   uint   drawcount   g _ constantbuffer   instanceid   internaldata   3   vertexdata   vdata   branch   if   drawtype   draw _ indexed   vdata   g _ vertexbuffer   vbid   g _ indexbuffer   ibid   vertexid   else   if   drawtype   draw   vdata   g _ vertexbuffer   vbid   vertexid   flatten   if   vertexid   drawcount   vdata   g _ vertexoutsideclipplane   discard   vertex   by   moving   it   outside   of   the   clip   plane   как   видно   все   очень   простой   и   понятно   для   справка   приводить   полный   код   шейдер   опытный   читатель   мочь   замечать   что   я   ничто   не   сказать   про   текстура   про   это   следующий   часть   а   что   делать   с   текстура   это   самый   серьезный   недостаток   предлагать   метод   при   подобный   подход   хотеться   также   иметь   уникальный   текстура   для   каждый   инстанс   но   в   direct3d11   это   реализовать   очень   нетривиальный   возможный   решение   проблема   1   использовать   текстурный   атлас   недостаток   в   один   атлас   много   текстура   не   влезать   надо   быть   группировать   инстанс   по   3   или   4   штука   количество   текстура   и   рисовать   отдельно   очевидно   что   при   такой   подход   весь   плюс   предлагать   метод   сходить   на   нет   2   использовать   текстурный   массив   texture2darray   sampler2darray   недостаток   в   один   массив   много   текстура   не   влезать   надо   группировать   инстанс   по   512   штука   количество   элемент   в   массив   текстура   и   рисовать   отдельно   очевидно   это   хорошо   чем   текстурный   атлас   но   все   равный   плохо   3   переходить   на   opengl   4   3   где   быть   bindless   texture   недостаток   влезать   весь   текстура   но   быть   один   серьезный   недостаток   под   название   opengl   4   переходить   на   direct3d12   amd   mantle   apple   metal   whatever   недостаток   влезать   весь   текстура   из   за   особенность   архитектура   но   поддерживаться   ограниченный   количество   железо   и   не   у   все   быть   доступ   к   sdk   5   использовать   маленький   текстура   недостаток   ну   тут   думать   все   очевидно   более   скудный   картинка   и   ограничение   для   художник   подробный   рассмотрение   весь   этот   решение   выходить   далеко   за   рамка   этот   статья   поэтому   ограничиваться   следующий   я   предпочитать   использовать   текстурный   массив   на   d3d11   и   в   случай   d3d12   родной   средство   этот   api   разглашать   который   я   не   позволять   nda   недостаток   и   ограничение   основной   часть   ограничение   подробно   расписывать   высоко   поэтому   я   просто   приводить   краткий   содержательный   обзор   иметься   недостаток   1   оверхед   связывать   с   некоторый   количество   мусорный   вершина   который   необходимо   отбрасывать   по   суть   прятать   2   так   называть   оверхед   на   индирекция   доступ   к   вершина   константа   и   индекс   плохо   поддаваться   предсказуемый   кеширование   так   как   адрес   чтение   каждый   раз   разный   и   вычисляться   динамически   индексировать   геометрия   самый   медленный   вариант   потому   что   там   двойной   индирекция   3   подеррживаться   только   несколько   вид   топология   trianglelist   pointlist   и   т   д   4   очень   и   очень   нетривиальный   работа   с   текстура   который   далеко   не   всегда   получаться   решать   для   общий   случай   5   пересоздание   логический   буфер   очень   дорогой   операция   поэтому   если   нужный   активный   стриминг   этот   данные   нужно   переизобретать   алгоритм   выделение   память   на   куча   для   случай   логический   буфер   из   за   это   еще   и   появляться   проблема   фрагментация   видеопамять   6   нетривиальный   работа   с   буфер   и   вершинный   процессинг   требовать   изобретение   специальный   механзим   для   случай   когда   например   необходимо   динамически   генерировать   вершина   из   вычислительный   шейдер   например   посчитать   поверхность   вода   или   симулировать   физика   ткань   на   gpu   7   нужно   постоянно   держать   весь   данные   логический   буфер   в   оперативный   память   этот   слегка   увеличивать   потребление   память   приложение   демо   и   исходник   в   очень   сыр   и   нечитабельный   вид   демка   лежать   на   гитхаб   https   github   com   bazhenovc   sigrlinn   blob   master   demo   demo _ grass   cc   бинарный   версия   пока   что   нет   выкладывать   поздно   демка   16384   уникальный   кубик   1   2ms   intel   hd   4400   демка   4096   инстанс   трава   200к   треугольник   ссылка   и   литература   opengl   insights   iii   bending   the   pipeline   programmable   vertex   pulling   by   daniel   rákos   не   читать   но   говорить   что   тоже   самый   для   opengl   sigrlinn   велосипедный   библиотека   для   абстрагирование   от   графический   апи   который   реализовать   в   тот   число   и   этот   метод   осторожно   код   сырой   и   неюзабельный   не   пытаться   использовать   дома   спасибо   за   внимание   direct3d   directx   шейдер   21   январь   2015   обновление   30   янва   2015   комментарий   42   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   gamedev   ru   разработка   игра   2001   2019