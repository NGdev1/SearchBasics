   Screen   space   ambient   occlusion   с   учет   нормаль   и   расчет   один   отражение   свет   график   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   FAQ   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиграфика   Screen   space   ambient   occlusion   с   учет   нормаль   и   расчет   один   отражение   свет   автор   сергей   резник   в   этот   статья   я   рассказывать   как   я   с   ноль   делать   SSAO   Screen   Space   Ambient   Occlusion   расчет   фоновый   освещение   в   экранный   пространство   с   учет   нормаль   сразу   следовать   отмечать   что   это   наиболее   простой   и   прямолинейный   реализация   в   лоб   не   претендовать   на   оптимальность   или   новизна   статья   быть   полезный   в   первый   очередь   то   кто   иметь   желание   разбираться   как   это   работать   как   то   захотеться   я   поупражняться   с   графика   и   я   решать   сделать   SSAO   с   ноль   опираться   на   мой   опыт   с   трассировка   луч   и   на   получать   ранее   знание   о   то   как   в   целое   это   должно   работать   в   общий   поставлять   задача   написать   к   свой   движок   демка   с   использование   всякий   разный   технология   решать   быть   также   поизучать   deferred   shading   и   screen   space   local   reflections   но   об   это   как   нибудь   в   другой   раз   в   этот   статья   сконцентрироваться   на   SSAO   для   самый   нетерпеливый   вот   результат   показывать   скрывать   1   немного   теория   2   подготовка   3   расчет   SSAO   4   расчет   отражение   свет   5   вывод   6   ништяка   ссылка   по   тема   1   немного   теория   что   мы   говорить   википедия   по   повод   ambient   occlusion   модель   затенение   использовать   в   трехмерный   графика   и   позволять   добавлять   реалистичность   изображение   за   счет   вычисление   интенсивность   свет   доходить   до   точка   поверхность   в   отличие   от   локальный   метод   как   например   затенение   по   фонг   ambient   occlusion   являться   глобальный   метод   то   быть   значение   яркость   каждый   точка   объект   зависеть   от   другой   объект   сцена   в   принцип   это   достаточно   отдаленно   напоминать   глобальный   освещение   получаться   что   мы   нужно   рассчитать   сколько   свет   доходить   до   конкретный   точка   из   полусфера   ориентировать   по   нормаль   в   этот   точка   я   даже   как   смочь   нарисовать   в   фотошоп   картинка   что   мы   тут   видеть   сверху   располагать   камера   который   смотреть   на   наш   сцена   разный   цветок   показывать   точка   на   объект   их   нормаль   и   полусфера   по   который   мы   быть   собирать   затенение   точка   обозначать   фиолеовой   ничто   не   затенять   точка   обозначать   желтый   затенять   совсем   чуть   чуть   точка   обозначать   голубой   затенять   практически   наполовину   а   вот   точка   на   задний   объект   обозначать   оранжевый   по   идея   с   точка   зрение   камера   частично   перекрывать   передний   объект   но   так   как   она   находиться   относительно   далеко   от   объект   то   по   факт   передний   объект   этот   точка   не   затенять   с   этот   мы   приходиться   бороться   отдельно   чтобы   избегать   неприятный   артефакт   в   вид   темный   силуэт   объект   такой   образ   мы   нужно   рассчитать   затенение   для   каждый   точка   учитывать   расстояние   до   объект   который   она   перекрывать   это   и   быть   наш   ambient   occlusion   я   решать   в   отличие   от   традиционный   SSAO   например   то   который   если   я   правильно   помнить   использоваться   в   первый   Crysis   рассчитывать   это   не   в   screen   space   а   во   view   space   минус   этот   подход   в   больший   сложность   вычисление   хотя   тоже   надо   смотреть   проверять   и   сравнивать   плюс   в   более   точный   AO   2   подготовка   итак   для   расчет   ambient   occlusion   мы   понадобиться   два   текстура   глубина   и   нормаль   как   я   уже   сказать   нормаль   быть   во   view   space   как   сохранять   и   восстанавливать   нормаль   ваш   дело   я   например   использовать   хитрый   функция   который   записывать   нормаль   в   два   компонет   подробно   об   это   в   последний   раздел   ништяка   пока   пускай   у   мы   быть   два   функция   в   шейдер   vec2   encodeNormal   in   vec3   n   vec3   decodeNormal   in   vec2   v   вернее   первый   функция   тут   даже   и   не   нужный   потому   что   она   использоваться   при   запись   нормаль   выглядеть   текстура   с   нормаль   быть   примерно   вот   так   показывать   скрывать   текстура   с   глубина   у   мы   быть   хранить   стандартный   глубина   OpenGL   значение   глубина   приводить   к   интервал   1   1   и   возводить   в   64   ю   степень   у   я   выглядеть   как   то   так   показывать   скрывать   но   так   как   мы   быть   использовать   view   space   мы   нужно   быть   восстанавливать   положение   точка   во   view   space   по   глубина   о   то   как   это   сделать   смотреть   в   последний   раздел   ништяка   пока   пускай   у   мы   быть   четыре   функция   в   шейдер   float   restoreViewSpaceDistance   in   float   depth   vec3   restoreViewSpacePosition   in   vec2   texCoords   in   float   depth   float   projectViewSpaceDistance   in   float   z   vec3   projectViewSpacePosition   in   vec3   viewSpace   также   для   то   чтобы   придавать   разнообразие   наш   расчет   AO   мы   понадобиться   текстура   с   шум   самый   обычный   текстура   с   шум   я   даже   показывать   она   здесь   не   быть   в   дополнение   к   этот   текстура   мы   специально   для   она   нужный   быть   текстурный   координата   такой   чтобы   текстура   рисоваться   на   экран   тексель   в   пиксел   по   большой   счет   это   не   обязательный   но   очень   желательно   чтобы   выборка   быть   более   случайный   итого   на   вход   во   фрагментный   шейдер   у   мы   быть   три   текстура   и   два   набор   текстурный   координата   надо   замечать   что   в   мой   движок   для   то   чтобы   поддерживаться   разный   версия   шейдер   сделать   следующий   штука   входить   переменный   во   фрагментный   шейдер   etFragmentIn   в   старый   шейдер   заменяться   на   varying   в   новый   на   in   результат   фрагментный   шейдер   записываться   в   переменный   etFragmentOut   gl _ FragColor   в   старый   шейдер   и   out   vec4   glBindFragDataLocation   в   новый   версия   итого   кусочек   шейдер   у   мы   уже   быть   uniform   sampler2D   texture _ diffuse   uniform   sampler2D   texture _ normal   uniform   sampler2D   texture _ depth   uniform   sampler2D   texture _ noise   etFragmentIn   vec2   TexCoord   etFragmentIn   vec2   NoiseTexCoord   теперь   можно   приступать   непосредственно   к   расчет   наш   затенение   3   расчет   SSAO   общий   идея   таков   в   данный   точка   получать   положение   и   нормаль   затем   сгенерировать   несколько   случайный   направление   на   полусфера   задана   нормаль   и   проверять   затенение   в   они   результат   собирать   и   поделить   на   количество   выборка   такой   образ   мы   хотеть   контролировать   как   минимум   три   параметр   1   количество   выборка   2   минимальный   расстояние   на   который   мы   проверять   затенение   оно   нужный   мы   чтобы   избавляться   от   некоторый   неприятный   артефакт   3   максимальный   расстояние   на   который   мы   проверять   затенение   вот   пара   картинка   для   сравнение   параметр   количество   выборка   чем   много   то   более   плавный   и   красивый   затенение   у   мы   получаться   максимальный   расстояние   чем   оно   много   тем   широкий   и   мягкий   у   мы   затенение   для   тестовый   сцена   Crytek   Sponza   я   использовать   такой   параметр   define   NUM _ SAMPLES   64   define   MIN _ SAMPLE _ SIZE   1   0   define   SAMPLE _ SIZE   32   0   к   сожаление   я   пока   не   приходить   в   голова   как   можно   избавляться   от   этот   параметр   и   вычислять   они   исходить   из   то   что   у   мы   быть   на   экран   быть   рад   если   кто   то   подсказывать   куда   двигаться   в   этот   направление   итак   у   мы   весь   быть   для   то   чтобы   рассчитать   затенение   каждый   точка   на   экран   для   начало   мы   нужно   находить   нормаль   в   этот   точка   и   ее   положение   не   забывать   что   мы   работать   во   view   space   делаться   это   просто   чтение   нормаль   из   текстура   и   восстановление   положение   по   глубина   void   main   vec4   noiseSample   etTexture2D   texture _ noise   NoiseTexCoord   vec3   normalSample   decodeNormal   etTexture2D   texture _ normal   TexCoord   xy   float   depthSample   2   0   etTexture2D   texture _ depth   TexCoord   x   1   0   vec3   viewSpacePosition   restoreViewSpacePosition   2   0   TexCoord   1   0   depthSample   функция   etTexture2D   это   тоже   магия   мой   движок   для   старый   версия   GLSL   она   превращаться   в   texture2D   для   новый   в   texture   теперь   чтобы   не   городить   все   в   тело   функция   main   заводить   специальный   функция   который   рассчитывать   затенение   в   данный   точка   я   пафосный   называть   она   performRaytracingInViewSpace   float   performRaytracingInViewSpace   in   vec3   vp   in   vec3   vn   in   vec4   noise   ну   и   собственно   чтобы   не   томить   остаток   шейдер   for   int   i   0   i   NUM _ SAMPLES   i   environment   performRaytracingInViewSpace   viewSpacePosition   normalSample   noiseSample   noiseSample   etTexture2D   texture _ noise   NoiseTexCoord   noiseSample   yz   etFragmentOut   vec4   environment   float   NUM _ SAMPLES   в   результат   у   мы   быть   затенение   данный   точка   если   нужно   освещение   мы   просто   вычитать   затенение   из   единица   etFragmentOut   vec4   1   0   environment   float   NUM _ SAMPLES   то   быть   здесь   мы   просто   подсовывать   в   этот   функция   начальный   параметр   для   текущий   точка   и   некий   псевдослучайный   величина   который   мы   потом   обновлять   читать   из   текстура   шум   по   новый   координата   такой   образ   весь   секрет   у   мы   в   функция   расчет   затенение   давать   рассматривать   она   близко   здесь   мы   нужно   сгенерировать   случайный   направление   на   полусфера   задана   нормаль   в   точка   я   это   делать   очень   просто   нормализовать   значение   из   текстура   шум   и   если   оно   лежать   в   другой   полуплоскость   от   нужный   мы   нормаль   то   умножать   на   1   выглядеть   это   вот   так   vec3   randomVectorOnHemisphere   in   vec3   normal   in   vec3   noise   vec3   n   normalize   noise   0   5   return   n   sign   dot   n   normal   так   как   мы   нужный   весь   полусфера   и   у   мы   нет   какой   то   предпочитать   направление   то   этот   функция   очень   даже   подходить   если   нужно   делать   выборка   в   некий   конус   в   движок   быть   функция   для   это   мочь   показывать   если   сам   не   находить   теперь   у   мы   быть   случайный   направление   по   который   мы   быть   делать   выборка   мы   сдвигать   точка   в   этот   направление   на   случайный   величина   между   MIN _ SAMPLE _ SIZE   и   SAMPLE _ SIZE   и   проецировать   она   в   screen   space   после   что   получать   некий   новый   текстурный   координата   и   глубина   в   интервал   0   1   далее   мы   смотреть   какой   глубина   у   мы   находиться   по   новый   текстурный   координата   делать   новый   выборка   из   текстура   глубина   затем   проверять   если   новый   глубина   оказываться   больше   чем   тот   который   мы   получать   после   проецирование   значит   новый   точка   лежать   далеко   наш   и   перекрывать   она   не   мочь   перекрытие   нет   возвращать   ноль   из   функция   float   performRaytracingInViewSpace   in   vec3   vp   in   vec3   vn   in   vec4   noise   vec3   randomNormal   randomVectorOnHemisphere   vn   noise   xyz   vec3   projected   projectViewSpacePosition   vp   randomNormal   MIN _ SAMPLE _ SIZE   noise   w   SAMPLE _ SIZE   float   sampledDepth   etTexture2D   texture _ depth   projected   xy   x   if   sampledDepth   projected   z   return   0   0   а   далеко   когда   мы   определять   что   новый   точка   лежать   близко   к   камера   чем   наш   спроецировать   начинаться   магия   затенение   что   у   мы   быть   на   вход   глубина   наш   спроецировать   точка   который   гарантировать   больше   чем   новый   глубина   глубина   который   мы   получать   после   выборка   который   гарантировать   мало   чем   глубина   спроецировать   точка   что   мы   нужно   вычислять   насколько   сильно   объект   на   точка   который   мы   наткнуться   перекрывать   наш   исходный   точка   что   мы   нужно   учитывать   что   близко   новый   точка   к   спроецировать   тем   сильный   перекрытие   если   новый   точка   сильно   далеко   от   спроецировать   то   мало   перекрытие   итого   мы   надо   сравнивать   два   нелинейный   глубина   который   скоро   все   близкий   к   единица   можно   еще   раз   восстанавливать   линейный   глубина   а   можно   сделать   небольшой   хак   и   получать   значение   который   характеризовать   глубина   после   некоторый   эксперимент   я   приходить   к   вывод   что   функция   вид   оценка   1   0   sqrt   1   0   глубина   хорошо   все   подходить   для   получение   такой   оценка   итого   у   мы   быть   два   значение   оценка   глубина   взять   между   они   разница   который   быть   характеризовать   расстояние   один   точка   от   другой   float   depthDifference   inversesqrt   1   0   projected   z   inversesqrt   1   0   sampledDepth   так   как   мы   хотеть   контролировать   степень   затенение   мочь   вводить   некий   коэффециент   для   этот   разность   в   финальный   вариант   получаться   так   float   depthDifference   DEPTH _ DIFFERENCE _ SCALE   inversesqrt   1   0   projected   z   inversesqrt   1   0   sampledDepth   для   тестовый   модель   я   использовать   значение   DEPTH _ DIFFERENCE _ SCALE   равный   3   33333   все   зависеть   от   масштаб   то   что   мы   рисовать   и   на   что   хотеть   вычислять   затенение   теперь   у   мы   быть   расстояние   между   точка   давать   вычислять   степень   затенение   опять   таки   после   многочисленный   эксперимент   я   приходить   к   вывод   что   хорошо   все   описывать   затенение   функция   вид   затенение   1   0   1   0   расстояние2   чтобы   сделать   он   более   мягкий   и   приятный   еще   можно   учитывать   расстояние   на   который   мы   делать   выборка   приводить   к   промежуток   0   1   итоговый   формула   выглядеть   вот   так   float   occlusion   1   0   noise   w   1   0   depthDifference   depthDifference   return   occlusion   вот   как   влиять   масштаб   расстояние   тот   который   DEPTH _ DIFFERENCE _ SCALE   при   уменьшение   расстояние   при   DEPTH _ DIFFERENCE _ SCALE   1   0   за   объект   появляться   темный   ореол   при   увеличение   масштаб   затенение   становиться   практически   незаметный   ну   вот   собственно   и   все   для   каждый   точка   мы   посчитать   затенение   4   расчет   отражение   свет   теперь   когда   у   мы   быть   такой   крутой   функция   расчет   затенение   подумать   можно   ли   как   то   расширять   она   да   мы   практически   не   напрягаться   мочь   рассчитать   первый   отражение   цвет   я   так   понимать   получаться   алгоритм   вроде   screen   space   direction   occlusion   искать   он   в   гугл   все   что   мы   нужно   это   сделать   выборка   из   текстура   с   цвет   по   новый   координата   и   учитывать   влияние   этот   цвет   на   течь   точка   быть   считать   что   влияние   цвет   прямо   пропорционально   то   насколько   новый   точка   перекрывать   наш   исходный   следовательно   теперь   наш   модный   функция   performRaytracingInViewSpace   возвращать   не   float   а   цвет   vec4   а   в   альфа   компонент   быть   хранить   затенение   также   мы   понадобиться   текстура   с   цвет   так   как   у   я   в   демка   использоваться   deferred   shading   то   она   у   я   уже   быть   вы   возможно   приходиться   прикручивать   multiple   render   targets   или   делать   несколько   проход   в   общий   у   мы   на   вход   появляться   еще   один   текстура   uniform   sampler2D   texture _ diffuse   а   функция   теперь   выглядеть   вот   так   vec4   performRaytracingInViewSpace   in   vec3   vp   in   vec3   vn   in   vec4   noise   return   etTexture2D   texture _ diffuse   projected   xy   occlusion   ну   и   в   функция   main   теперь   у   мы   не   float   а   vec4   vec4   environment   vec4   0   0   etFragmentOut   environment   float   NUM _ SAMPLES   в   результат   мы   получать   примерно   вот   такой   картинка   альфа   канал   не   показывать   а   яркость   увеличивать   в   10   раз   для   наглядность   показывать   скрывать   в   этот   текстура   как   видно   храниться   цвет   который   отражаться   от   окружающий   объект   воспользоваться   на   первый   взгляд   различие   немного   но   приглядываться   к   правый   картинка   освещение   намного   мягко   и   на   стенка   быть   небольшой   отсвет   от   штора   в   общий   при   минимальный   затрата   получаться   использовать   интересный   техника   5   вывод   итого   что   у   мы   получаться   1   рассчитать   некий   подобие   глобальный   освещение   не   передирать   исходный   код   шейдер   2   рассчитать   первый   отражение   свет   с   минимальный   затрата   и   изменение   в   алгоритм   3   ну   и   наконец   разбираться   в   то   как   это   работать   6   ништяка   как   и   обещать   в   последний   часть   я   выкладывать   кусок   код   запись   и   восстановление   нормаль   взять   отсюда   vec2   encodeNormal   in   vec3   n   return   vec2   n   xy   sqrt   8   0   n   z   8   0   0   5   vec3   decodeNormal   in   vec2   v   vec2   fenc   4   0   v   2   0   float   f   dot   fenc   fenc   return   vec3   fenc   sqrt   1   0   0   25   f   1   0   0   5   f   восстановление   положение   во   view   space   из   глубина   и   проецирование   обратно   uniform   vec2   clipPlanes   uniform   vec2   texCoordScales   define   NEAR   clipPlanes   x   define   FAR   clipPlanes   y   float   restoreViewSpaceDistance   in   float   depth   return   2   0   NEAR   FAR   depth   FAR   NEAR   FAR   NEAR   vec3   restoreViewSpacePosition   in   vec2   texCoords   in   float   depth   return   vec3   texCoords   texCoordScales   1   0   restoreViewSpaceDistance   depth   float   projectViewSpaceDistance   in   float   z   return   2   0   NEAR   FAR   z   FAR   NEAR   FAR   NEAR   vec3   projectViewSpacePosition   in   vec3   viewSpace   return   0   5   0   5   vec3   viewSpace   xy   texCoordScales   viewSpace   z   projectViewSpaceDistance   viewSpace   z   clipPlanes   этот   расстояние   до   ближний   и   дальний   плоскость   отсечение   то   что   мы   скармливать   в   функция   установка   перспективный   проекция   texCoordScales   компонент   обратный   матриций   проекция   взять   со   знак   минус   texCoordScales   vec2   inverseProjectionMatrix   0   0   inverseProjectionMatrix   1   1   они   необходимый   для   правильный   восстановление   позиция   с   учет   угол   обзор   и   пропорция   вьюпорт   вообще   в   демка   много   что   быть   кроме   затенение   и   отражение   свет   показывать   скрывать   исходник   демка   доступный   внутри   движок   https   github   com   sergeyreznik   et   engine   по   идея   демка   должный   сходу   собираться   в   Xcode   под   мак   и   MSVC   2013   под   винда   ссылка   по   тема   как   я   уже   говорить   в   начало   данный   реализация   являться   самый   простой   и   прямолинейный   вот   ссылка   на   некоторый   другой   техника   который   использоваться   в   игра   Horizon   based   ambient   occlusion   HBAO   http   developer   download   nvidia   com   presentations   2008   SIGGRAPH   AO _ SIG08b   pdf   улучшать   техника   HBAO   http   www   geforce   com   hardware   technology   hbao   plus   technology   оригинальный   статья   по   SSDO   Approximating   Dynamic   Global   Illumination   in   Image   Space   http   people   mpi   inf   mpg   de   ritschel   Papers   SSDO   pdf   Ambient   Occlusion   ao   GLSL   OpenGL   SSAO   17   январь   2015   обновление   13   мара   2015   комментарий   69   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   GameDev   ru   разработка   игра   2001   2019