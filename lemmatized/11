   модель   многопоточность   или   прощать   дедлоки   общий   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   FAQ   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиобщий   модель   многопоточность   или   прощать   дедлоки   автор   дмитрий   литовченко   статья   являться   выборочный   перевод   глава   5   из   книга   Erlang   and   OTP   in   Action   Martin   Logan   Eric   Merritt   Richard   Carlsson   издательство   Manning   от   переводчик   целевой   аудитория   статья   как   матерый   программист   который   угнетать   индустриальный   стандарт   shared   memory   with   locks   и   истосковаться   по   качественный   многопоточность   в   их   любимый   язык   программирование   так   и   новичок   который   до   сей   день   побаиваться   создание   второй   поток   в   свой   игра   а   если   и   создавать   то   моментально   наступать   на   целый   набор   разнообразный   грабли   заточить   или   ржавый   заботливо   разбрасывать   реализация   shared   memory   with   locks   на   их   язык   программирование   на   самый   дело   вопрос   хоть   и   сложный   но   не   все   так   плохой   читать   модель   многопоточность   или   прощать   дедлоки   общий   память   и   локи   STM   Software   Transactional   Memory   поток   данные   будущий   результат   и   обещание   Futures   Promises   асинхронный   обмен   сообщение   модель   многопоточность   или   прощать   дедлоки   этот   статья   иметь   цель   преподавать   основа   модель   многопоточность   при   написание   многопоточный   программа   чтобы   облегчать   понимание   принцип   многопоточность   в   ваш   любимый   язык   программирование   и   упрощать   выбор   в   польза   наиболее   простой   и   надежный   вариант   из   иметься   параллельный   система   начинать   приобретать   популярность   в   последний   год   с   рост   число   ядро   в   персональный   компьютер   и   серверный   платформа   сам   факт   что   вы   в   данный   момент   читать   этот   статья   и   упоминать   высоко   книга   это   подтверждать   самый   большой   проблема   параллельный   система   являться   способ   обмен   поток   общий   состояние   shared   state   как   ваш   поток   обмениваться   друг   с   друг   состояние   на   первый   взгляд   это   казаться   невинный   и   маленький   проблема   однако   хороший   ум   мир   долгий   год   биться   над   она   и   находить   всего   несколько   подходящий   решение   быть   испытывать   множество   разный   подход   и   всего   четыре   из   они   набирать   заметный   процент   популярность   на   рынок   параллельный   решение   с   цель   освещать   этот   подход   и   быть   создавать   данный   статья   мы   рассматривать   общий   память   и   локи   программный   транзакционный   память   STM   software   transactional   memory   поток   данные   будущий   результат   и   обещание   futures   and   promises   асинхронный   сообщение   между   поток   мы   постараться   сравнивать   этот   способ   друг   с   друг   и   выделять   плюс   и   минус   каждый   общий   память   и   локи   это   самый   корявый   способ   хотеть   замечать   общий   память   и   локи   этот   GOTO   наш   время   так   же   как   и   GOTO   прошлый   год   этот   модель   параллельность   использоваться   везде   где   только   можно   и   существовать   на   рынок   в   течение   десяток   год   так   же   как   и   с   GOTO   здесь   иметься   ряд   уловка   и   способ   чтобы   выстреливать   себя   в   нога   этот   способ   параллельный   программирование   успешно   воспитывать   целый   поколение   инженер   с   глубокий   подсознательный   страх   параллельность   в   наш   время   этот   страх   сильно   осложнять   адаптация   программист   к   новый   поколение   многоядерный   система   так   же   как   и   GOTO   следовать   признавать   что   у   общий   память   быть   свой   узкий   ниша   применение   на   низкий   уровень   где   по   другой   вероятно   просто   не   получаться   если   вы   работать   на   такой   уровень   вы   вполне   осознавать   почему   использовать   общий   память   и   плюс   и   минус   этот   способ   для   пример   реализация   бизнес   логика   сетевой   сервер   и   служба   не   являться   этот   узкий   ниша   и   вы   следовать   бы   ознакомляться   с   другой   способ   общий   память   обычно   являться   блок   RAM   память   общий   доступ   доступ   к   который   иметь   несколько   параллельный   поток   или   процесс   несущественный   этот   блок   память   защищать   некоторый   замок   который   гарантировать   что   в   один   момент   время   только   один   процесс   иметь   доступ   к   данный   блок   память   остальной   в   этот   время   либо   ожидать   свой   очередь   либо   пробовать   захватить   замок   и   при   неудача   продолжать   свой   выполнение   откладывать   следующий   попытка   на   будущее   в   простой   случай   процесс   выстраиваться   в   очередь   на   доступ   к   данный   блок   память   в   роль   замок   выступать   иметься   в   ваш   язык   программирование   примитив   Lock   Semaphore   Mutex   и   так   далее   данный   подход   иметь   ощутимый   сложность   это   организация   доступ   к   тяжело   нагружать   блок   данные   который   нужный   все   и   каждый   иметься   возможность   а   во   многий   случай   и   высокий   вероятность   создание   сложный   тупиковый   ситуация   deadlock   когда   пара   или   группа   поток   зависать   в   ожидание   друг   друг   который   разработчик   совсем   непросто   обнаруживать   без   долгий   отладка   не   счесть   история   когда   система   зависать   во   время   взаимный   блокировка   deadlock   после   неделя   или   месяц   а   то   и   год   успешный   работа   такой   подход   к   параллельность   годиться   для   небольшой   программа   с   небольшой   количество   процесс   при   увеличение   количество   процесс   например   рост   число   клиент   сервис   или   рост   популярность   ваш   ММОРПГ   сложность   такой   система   возрастать   в   раз   и   ситуация   быстро   выходить   из   под   контроль   такой   тип   параллельность   использоваться   в   множество   популярный   в   наш   время   язык   программирование   C   C   Java   Perl   Python   в   Python   посредством   единственный   глобальный   лок   использование   общий   память   вездесущий   и   общеупотребимый   подход   к   многопоточность   в   частность   из   за   легкость   и   простота   реализация   который   легко   совмещаться   с   модель   императивный   язык   программирование   к   несчастие   широкий   распространение   этот   метода   негативно   повлиять   на   наш   умение   думать   о   проблема   параллельность   и   использовать   параллельность   в   большой   масштаб   STM   Software   Transactional   Memory   первый   нетрадиционный   способ   обеспечение   обмен   состояние   между   поток   программный   транзакционный   память   сокращенно   STM   Software   Transactional   Memory   один   из   самый   популярный   пример   такой   параллельность   компилятор   GHC   для   язык   Haskell   википедия   содержать   хорошо   подобранный   факт   и   ссылка   по   многий   вопрос   компьютерный   наука   потому   мы   тоже   быть   опираться   на   факт   излагать   в   она   STM   это   механизм   контроль   аналогичный   транзакция   база   данные   для   контроль   доступ   к   общий   память   при   параллельный   вычисление   он   работать   как   альтернатива   синхронизация   на   основа   замок   lock   и   часто   сделать   без   они   в   беззамочный   форма   lock   free   в   этот   контекст   транзакция   это   фрагмент   код   выполнять   операция   чтение   и   запись   из   общий   память   и   этот   ряд   операция   происходить   логически   как   бы   в   один   момент   время   другой   код   не   мочь   вклиниваться   и   выполнять   доступ   к   общий   память   между   они   по   завершение   транзакция   следующий   конкурировать   фрагмент   код   проверять   подходить   ли   данные   в   память   для   запись   результат   его   работа   если   данный   в   память   не   соответствовать   его   ожидание   результат   отбрасываться   и   операция   переделываться   заново   пример   с   бейсбольный   мяч   в   оригинальный   статья   автор   рассылать   бейсбольный   мяч   член   любимый   команда   чтобы   они   оставлять   подпись   на   оно   мы   же   использовать   более   близкий   наш   молодежь   пример   с   обходной   лист   университет   пример   с   обходной   лист   допускать   вы   студент   и   у   вы   на   рука   иметься   обходной   лист   который   надо   пронести   по   весь   факультет   библиотека   ректорат   и   проч   и   собирать   подпись   весь   ответственный   лицо   допускать   что   это   очень   особенный   лист   с   который   я   мочь   снимать   копия   и   передавать   кто   следовать   на   подпись   я   не   давать   они   копия   навсегда   я   просто   передавать   копия   на   подпись   и   забирать   обратно   такой   образ   10   деканат   библиотека   и   ректорат   получать   копия   мой   чистый   обходный   лист   внезапно   деканат   математический   факультет   первый   подписывать   мой   обходной   лист   и   вернуть   я   они   копия   я   заменять   чистый   лист   в   свой   рука   на   этот   подписывать   копия   через   секунда   я   присылать   мой   лист   с   подпись   физический   факультет   я   сравнивать   он   с   лист   в   мой   рука   и   замечать   что   они   различаться   ох   ведь   так   не   годиться   я   выбрасывать   приходить   лист   с   подпись   физик   и   отсылать   они   копия   мой   лист   с   подпись   математик   я   ведь   нужный   весь   подпись   на   один   лист   а   не   раздельно   этот   операция   повторяться   много   раз   по   мера   возвращение   подписывать   копия   мой   лист   до   тот   пора   отбрасывать   несовпадающий   лист   и   отправлять   повторно   мой   копия   до   тот   пора   пока   весь   подпись   не   собирать   на   один   лист   по   суть   я   контролировать   тот   факт   что   у   я   на   рука   всегда   свежий   копия   мой   обходный   лист   STM   иметь   несколько   преимущество   первый   и   самый   главный   преимущество   не   сразу   бросаться   в   глаз   при   просмотр   пример   выше   STM   это   оптимистический   модель   каждый   поток   делать   свой   дело   не   задумываться   о   то   работать   ли   другой   поток   с   тот   же   данные   или   нет   в   конец   манипуляция   если   все   в   порядок   и   ничто   на   принимать   сторона   не   поменяться   результат   отправляться   на   принимать   сторона   если   возникать   конфликт   версия   или   данный   то   результат   отбрасываться   и   операция   проводиться   повторно   уже   с   новый   данные   хороший   свойство   этот   модель   никто   не   ждать   никакой   ресурс   поток   мочь   писать   в   разный   поле   структура   не   заботиться   о   замок   плохой   свойство   работа   иногда   приходиться   переделывать   также   иметься   некоторый   ощутимый   накладной   расход   на   система   транзакция   который   влиять   на   скорость   выполнение   в   некоторый   ситуация   мочь   возникать   перерасход   память   если   N   процесс   работать   над   M   байт   память   понадобиться   N   M   байт   для   хранение   N   копия   этот   данные   в   целое   для   непрограммист   и   для   новичок   этот   подход   к   параллельность   намного   более   понятный   и   простой   чем   традиционный   способ   с   общий   память   и   замок   shared   memory   locks   и   мочь   быть   неплохой   способ   погружаться   в   мир   разработка   параллельный   программа   поток   данные   будущий   результат   и   обещание   Futures   Promises   еще   один   подход   к   параллельный   программирование   это   обещание   результат   futures   promises   пример   такой   подход   мочь   быть   находить   в   Mozart   Oz   в   Java   в   с   библиотека   ASIO   Boost   Asio   Python   библиотека   Twisted   снова   википедия   давать   исчерпывающий   описание   по   данный   тема   и   мы   построить   повествование   на   этот   описание   в   компьютерный   наука   обещание   результат   futures   and   promises   это   родственный   конструкция   использовать   для   синхронизация   в   некоторый   параллельный   язык   программирование   оба   они   ссылаться   на   объект   который   являться   посредник   в   предоставление   результат   который   не   являться   немедленно   доступный   потому   что   его   вычисление   еще   не   завершаться   вернуться   к   наш   обходный   лист   я   снова   надо   подписывать   мой   обходной   лист   на   этот   раз   на   факультет   информационный   технология   я   просто   идти   в   их   деканат   и   передавать   они   мой   обходной   лист   но   поскольку   в   данный   момент   они   немного   занятый   пить   кофе   к   пример   они   давать   я   расписка   в   данный   случай   future   в   который   я   обещать   вернуть   мой   подписывать   обходной   лист   в   аккурат   тот   момент   когда   они   освобождаться   в   шок   я   сидеть   под   деканат   и   читать   этот   расписка   пока   не   выходить   секретарь   деканат   и   не   вручать   я   мой   обходной   лист   с   подпись   деканат   расписка   я   больше   не   нужный   она   можно   выбрасывать   обещание   promise   очень   похожий   на   только   что   описывать   расписка   деканат   future   к   пример   я   приходить   в   ректорат   где   собираться   все   декан   кроме   декан   факультет   ита   чей   подпись   я   и   нужный   у   я   забирать   мой   лист   и   я   вручать   письменный   обещание   что   как   только   он   появляться   он   передавать   мой   лист   на   подпись   в   шок   я   сидеть   под   ректорат   и   смотреть   на   этот   записка   пока   случайный   декан   я   не   выносить   мой   обходной   лист   подписывать   декан   факультет   ита   записка   более   не   нужный   и   она   я   выбрасывать   будущий   результат   future   это   некий   контракт   что   определенный   поток   в   какой   то   момент   время   обязательно   возвращать   я   результат   согласно   данный   контракт   в   отличие   от   это   обещание   promise   этот   обещание   что   в   какой   то   момент   время   какой   то   поток   неважно   какой   исполнять   мой   задача   и   вернуть   я   обещать   результат   по   суть   это   стиль   программирование   основывать   на   поток   данные   и   концептуальный   достаточно   простой   этот   принцип   делать   обмен   данные   в   параллельный   система   простой   и   понятный   и   служить   хороший   основа   для   построение   более   сложный   структура   вроде   канал   данный   однако   хотя   будущий   результат   и   обещание   позволять   обходить   самый   известный   проблема   параллельный   программирование   это   все   еще   общий   память   со   весь   скрытый   проблема   по   суть   будущий   результат   и   обещание   этот   общий   состояние   разный   поток   они   хорошо   обходить   с   самый   крупный   проблема   но   не   полностью   решать   их   следующий   механизм   подходить   к   проблема   с   другой   сторона   что   позволять   он   ловко   решать   весь   известный   проблема   общий   память   в   основной   цена   дополнительный   расход   память   и   время   на   копирование   данный   но   не   быть   забегать   вперед   асинхронный   обмен   сообщение   по   этот   модель   параллельность   работать   язык   Erlang   но   при   желание   несложно   настраивать   подобный   модель   в   любой   другой   язык   главное   понимать   идея   процесс   содержать   свой   состояние   в   себя   и   общаться   друг   с   друг   только   посредством   сообщение   который   не   храниться   в   общий   память   а   копироваться   от   процесс   к   процесс   и   ложиться   в   специальный   личный   для   этот   процесс   почтовый   ящик   такой   коммуникация   являться   полностью   асинхронный   никто   никто   не   ожидать   и   сообщение   обрабатываться   другой   процесс   по   мера   возможность   когда   удобно   он   более   сложный   модель   коммуникация   мочь   быть   построить   на   этот   примитив   такой   модель   совместный   работа   иногда   еще   называться   Actor   Model   вернуться   к   наш   обходный   лист   на   этот   раз   вместо   то   чтобы   ножка   бегать   по   университет   и   подписывать   везде   наш   лист   мы   передавать   наш   лист   в   специальный   бесплатный   служба   который   по   чистый   случайность   специализироваться   на   обходный   лист   мы   размещать   наш   лист   в   конверт   с   подробный   записка   что   с   он   нужно   сделать   и   возвращаться   к   свой   дело   через   два   неделя   в   мой   почтовый   ящик   приходить   ответ   с   мой   обходный   лист   подписывать   весь   инстанция   и   сопроводительный   записка   с   подробность   исполнение   мой   задание   весь   суть   этот   метод   в   тот   чтобы   налаживать   сообщение   между   независимый   процесс   который   посылать   друг   друг   запрос   и   ответ   семантически   этот   сообщение   никак   не   связанный   с   посылать   их   процесс   это   означать   что   если   вы   писать   проект   на   язык   а   вы   совершенно   не   затруднять   связывать   этот   программа   с   другой   написать   на   язык   б   главное   договариваться   о   формат   и   обработка   сообщение   все   о   что   следовать   позаботиться   это   о   поток   сообщение   течь   через   часть   ваш   система   сам   себя   этот   изящный   решение   доставаться   мы   совсем   не   бесплатно   во   многий   случай   передача   сообщение   между   параллельный   процесс   сделать   с   помощь   глубокий   копирование   включая   весь   поле   и   они   под   поле   исходящий   сообщение   проблема   в   то   что   для   большой   структура   цена   копирование   становиться   ощутимый   дополнительный   расход   память   мочь   негативно   повлиять   на   ваш   система   особенно   если   у   вы   жесткий   ограничение   по   память   а   сообщение   иметь   большой   размер   на   практика   вы   приходиться   следить   за   то   чтобы   посылать   и   принимать   сообщение   иметь   по   возможность   небольшой   размер   подобно   будущий   результат   и   обещание   самый   страшный   проблема   параллельный   программирование   взаимный   блокировка   практически   решать   пусть   все   еще   возможный   но   очень   маловероятный   от   переводчик   подобный   можно   реализовывать   в   с   и   любой   другой   язык   с   помощь   любой   подходящий   библиотека   обмен   сообщение   внутри   процесс   лично   рекомендовать   библиотека   ZeroMQ   набор   пример   здесь   она   идеально   подходить   и   для   связь   процесс   как   на   один   машина   так   и   по   сеть   многозадачность   многопоточность   24   август   2012   комментарий   41   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   GameDev   ru   разработка   игра   2001   2019