   моделирование   стеклянный   поверхность   график   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   FAQ   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиграфика   моделирование   стеклянный   поверхность   автор   сергей   резник   с   помощь   современный   графический   адаптер   можно   получать   весь   более   сложный   динамический   сцена   это   означать   что   высококачественный   фотореалистичный   рендеринг   переноситься   из   offline   в   реальный   время   в   частность   один   из   насущный   задача   компьютерный   график   являться   расчет   и   рендеринг   глобальный   освещение   и   сложный   материал   в   этот   статья   я   хотеть   бы   рассказывать   о   моделирование   стеклянный   предмет   введение   стекло   что   же   мы   быть   моделировать   прозрачность   стекло   моделирование   каустика   фильтрация   текстура   с   каустика   два   премломление   при   отрисовка   стекло   рабочий   программа   и   исходник   замечание   введение   стекло   являться   довольно   сложный   для   моделирование   материал   если   поставлять   задача   получать   максимально   реалистичный   изображение   в   данный   статья   мы   вместе   с   вы   разбирать   пошагово   процесс   моделирование   и   рендеринг   стеклянный   предмет   надеяться   прочитывать   данный   статья   читатель   смочь   разбираться   в   технология   моделирование   стекло   и   получать   у   себя   что   то   вроде   это   стекло   что   же   мы   быть   моделировать   итак   что   же   мы   предстоять   сделать   для   то   чтобы   получать   реалистичный   стекло   основной   что   делать   стекло   стекло   это   его   прозрачность   то   быть   стекло   преломлять   и   пропускать   луч   свет   но   при   это   конечно   же   не   стоить   забывать   и   то   что   стекло   также   и   отражать   свет   позволять   видеть   хотя   и   в   искажать   вид   за   счет   преломление   предмет   находиться   за   стеклянный   предмет   по   отношение   к   наблюдатель   также   следовать   с   осторожность   подходить   к   выбор   модель   освещение   стекло   от   правильно   выбирать   модель   освещение   зависеть   очень   многое   так   например   если   выбирать   модель   освещение   кук   торренс   мы   получать   гладкий   полированный   стекло   а   если   выбирать   модель   фонг   то   стекло   уже   не   быть   казаться   полировать   но   в   статья   я   останавливать   свой   выбор   именно   на   модель   освещение   кук   торренс   еще   один   важный   часть   моделирование   стекло   это   каустик   тот   самый   светлый   пятно   который   образовываться   при   концентрация   луч   свет   на   небольшой   площадь   вследствие   их   преломление   отклонение   от   начальный   траектория   на   граница   материал   да   кстати   каустика   относиться   уже   к   моделирование   глобальный   освещение   итак   четыре   компонент   который   делать   стекло   стекло   в   компьютерный   графика   1   прозрачность   2   отражение   3   освещение   4   каустика   ну   что   же   начинать   моделирование   наш   стекло   да   кстати   я   забывать   сказать   что   для   моделирование   я   выбирать   OpenGL   3   2   по   ход   дело   я   конечно   же   быть   объяснять   как   сделать   тот   или   иной   эффект   с   помощь   этот   графический   API   и   где   это   потребоваться   быть   приводить   исходный   код   непосредственно   на   с   а   также   весь   необходимый   шейдер   также   я   полагать   что   читатель   знакомый   с   основа   OpenGL   и   смочь   самостоятельно   проводить   некоторый   подготовка   сделать   простенький   сцена   с   один   точечный   источник   свет   а   также   знакомый   с   технология   использование   Framebuffer   Object   итак   мы   начинать   прозрачность   стекло   собственно   прозрачность   объект   можно   смоделировать   относительно   легко   достаточно   нарисовать   из   центр   моделировать   объект   кубический   карта   а   затем   делать   выборка   из   она   в   правильный   направление   до   относительно   недавний   время   получать   динамический   кубический   карта   в   OpenGL   можно   быть   шесть   раз   отрисовать   сцена   в   каждый   из   грань   кубический   текстура   но   с   появление   в   ядро   OpenGL   3   2   геометрический   шейдер   все   становиться   намного   просто   достаточно   один   раз   нарисовать   сцена   все   остальное   за   мы   сделать   геометрический   шейдер   но   давать   все   же   действовать   по   порядок   итак   представлять   себя   что   у   мы   быть   сцена   а   хорошо   давать   сразу   договариваться   о   то   что   она   у   мы   быть   у   я   в   пример   это   комната   с   расставлять   в   она   случайный   образ   ящик   рисоваться   это   все   очень   просто   но   постепенно   мы   быть   добавлять   в   отрисовка   сцена   новый   пункт   теперь   самый   время   переходить   к   создание   кубический   карта   для   наш   стекло   рассматривать   два   подход   первый   быть   с   шесть   отрисовка   в   грань   кубический   карта   а   второй   с   геометрический   шейдер   далее   и   везде   я   быть   использовать   Framebuffer   Object   для   отрисовка   в   любой   текстура   надеяться   читатель   уже   знакомый   с   этот   технология   и   я   приходиться   только   лишь   добавлять   некоторый   момент   относительно   рендеринг   в   кубический   карта   итак   для   то   чтобы   получать   кубический   карта   с   использование   шесть   проход   отрисовка   мы   быть   необходимо   создавать   сам   кубический   текстура   создавать   Framebuffer   Object   который   быть   отвечать   за   отрисовка   в   создавать   кубический   карта   и   выполнять   отрисовка   сцена   в   она   кубический   карта   создаваться   следующий   образ   void   Ce2Render   buildCubeTexture   Ce2TextureObject   texture   texture   target   GL _ TEXTURE _ CUBE _ MAP   glGenTextures   1   texture   glID   создавать   новый   текстура   bindTexture   0   texture   GL _ TEXTURE _ CUBE _ MAP   биндима   она   как   кубический   карта   glTexParameteri   GL _ TEXTURE _ CUBE _ MAP   GL _ TEXTURE _ MIN _ FILTER   GL _ LINEAR   glTexParameteri   GL _ TEXTURE _ CUBE _ MAP   GL _ TEXTURE _ MAG _ FILTER   GL _ LINEAR   glTexParameteri   GL _ TEXTURE _ CUBE _ MAP   GL _ TEXTURE _ WRAP _ S   GL _ CLAMP _ TO _ EDGE   glTexParameteri   GL _ TEXTURE _ CUBE _ MAP   GL _ TEXTURE _ WRAP _ T   GL _ CLAMP _ TO _ EDGE   glTexParameteri   GL _ TEXTURE _ CUBE _ MAP   GL _ TEXTURE _ WRAP _ R   GL _ CLAMP _ TO _ EDGE   генерировать   весь   шесть   грань   for   int   face   0   face   6   face   TexImage2D   GL _ TEXTURE _ CUBE _ MAP _ POSITIVE _ X   face   0   texture   internalFormat   texture   width   texture   height   texture   format   texture   type   0   texture   name   код   для   создание   объект   Framebuffer   Object   использовать   стандартный   помнить   я   рассчитывать   на   то   что   вы   уже   знакомый   с   он   во   всякий   случай   описывать   создание   FBO   это   не   тот   задача   который   поставлять   в   данный   статья   и   еще   один   важный   момент   настраивать   матрица   преобразование   так   чтобы   камера   охватывать   весь   окружение   360   для   это   мы   нужно   настраивать   матрица   проекция   projection   matrix   так   чтобы   FOV   равняться   90   приводить   фрагмент   исходный   код   который   создавать   матрица   проекция   mat4   Ce2Camera   perspectiveProjection   float   fov   float   aspect   float   zNear   float   zFar   mat4   result   IDENTITY _ MATRIX   float   fHalfFOV   0   5f   fov   float   cotan   cos   fHalfFOV   sin   fHalfFOV   float   dz   zFar   zNear   result   0   0   cotan   aspect   result   1   1   cotan   result   2   2   zFar   zNear   dz   result   3   3   0   0f   result   2   3   1   0f   result   3   2   2   0f   zNear   zFar   dz   return   result   mat4  _ cubemapProjectionMatrix   Ce2Camera   perspectiveProjection   HALF _ PI   1   0   1   0   2048   0   теперь   у   мы   быть   матрица   проекция   но   мы   нужный   еще   шесть   видовой   матрица   с   помощь   который   наш   камера   смотреть   бы   в   разный   сторона   X   Y   Z   получать   этот   матрица   можно   простой   умножение   проективный   матрица   на   матрица   поворот   на   соответствующий   угол   а   можно   просто   что   при   это   давать   тот   же   результат   переставлять   место   конечно   не   случайный   образ   строка   проективный   матица   я   однажды   делать   это   а   теперь   поделиться   с   вы   следующий   код   генерировать   6   матрица   для   отрисовка   в   кубический   карта   из   заданный   позиция   CubemapMatrixArray   Ce2BasicHelper   cubemapMatrix   const   mat4   projectionMatrix   const   vec3   pointOfView   CubemapMatrixArray   result   просто   массив   из   6   ти   матрица   mat4   translation   translationMatrix   pointOfView   строка   проективный   матрица   const   vec4   rX   projectionMatrix   0   const   vec4   rY   projectionMatrix   1   const   vec4   rZ   projectionMatrix   2   const   vec4   rW   projectionMatrix   3   переставлять   хитрый   образ   и   домножать   на   матрица   перемещение   в   заданный   точка   result   0   translation   mat4   rZ   rY   rX   rW   result   1   translation   mat4   rZ   rY   rX   rW   result   2   translation   mat4   rX   rZ   rY   rW   result   3   translation   mat4   rX   rZ   rY   rW   result   4   translation   mat4   rX   rY   rZ   rW   result   5   translation   mat4   rX   rY   rZ   rW   return   result   ну   вот   теперь   у   мы   быть   все   чтобы   нарисовать   в   кубический   карта   ваш   сцена   делаться   это   примерно   следующий   образ  _ reflectionRefractionBuffer   создавать   ранний   Framebuffer   Object  _ reflectionRefractionTexture   создавать   ранее   кубический   карта  _ cubemapMatrices   массив   из   шесть   предрасчитанный   матрица   render   bindFramebuffer  _ reflectionRefractionBuffer   for   int   i   0   i   6   i  _ reflectionRefractionBuffer   setCurrentRenderTarget  _ reflectionRefractionTexture   GL _ TEXTURE _ CUBE _ MAP _ POSITIVE _ X   i   glClear   GL _ DEPTH _ BUFFER _ BIT   метод   который   просто   рисовать   сцена   параметр   положение   камера   и   матрица   renderEnvironment  _ modelCenter  _ cubemapMatrices   i   с   первый   метод   кажется   все   ясный   а   как   же   быть   с   отрисовка   в   кубический   карта   с   использование   геометрический   шейдер   давать   разбираться   с   это   при   такой   подход   мы   понадобиться   Framebuffer   Object   к   который   присоединять   не   обычный   2D   текстура   а   кубический   карта   так   если   для   присоединение   2D   текстура   мы   использовать   метод   glFramebufferTexture2D   то   теперь   мы   необходимо   использовать   метод   glFramebufferTexture   который   позволять   присоединять   к   объект   Framebuffer   Object   любой   текстура   быть   то   1D   2D   3D   текстура   или   же   кубический   карта   теперь   самый   интересный   геометрический   шейдер   суть   он   в   то   что   он   быть   создавать   новый   треугольник   и   проецировать   они   на   каждый   из   шесть   грань   кубический   карта   для   это   быть   использовать   в   геометрический   шейдер   встроенный   переменный   gl _ Layer   который   позволять   выбирать   слой   грань   многослоевой   текстура   кубический   карта   в   который   мы   быть   выводить   примитив   для   то   чтобы   треугольник   корректно   проецироваться   на   грань   кубический   карта   мы   нужно   быть   передавать   в   геометрический   шейдер   шесть   матрица   который   быть   успешно   рассчитать   ранее   теперь   рассматривать   шейдер   который   использоваться   для   отрисовка   окружение   по   порядок   вершинный   шейдер   я   использовать   препроцессор   для   то   чтобы   не   размножать   шейдер   а   скомпоновать   все   в   один   с   четко   определенный   функционал   директива   WITH _ GS   использоваться   для   то   чтобы   определять   использоваться   ли   геометрический   шейдер   или   нет   если   не   использоваться   то   быть   следом   за   вершинный   сразу   идти   фрагментный   шейдер   значит   мы   как   обычно   проецировать   наш   вершина   и   передавать   требовать   значение   нормаль   текстурный   координата   и   т   д   сразу   во   фрагментный   шейдер   если   же   использоваться   геометрический   шейдер   то   мы   необходимо   передавать   в   он   исходный   вершина   и   требовать   значение   а   он   уже   в   свой   очередь   сделать   весь   необходимый   и   передавать   управление   фрагментный   шейдер   итак   вот   он   наш   вершинный   шейдер   ifndef   WITH _ GS   если   мы   использовать   геометрический   шейдер   то   этот   матрица   мы   не   нужный   uniform   mat4   mModelViewProjection   endif   uniform   vec3   vCamera   uniform   vec3   vPrimaryLight   uniform   mat4   mLightProjectionMatrix   uniform   mat4   mTransform   матрица   преобразование   модель   in   vec4   Vertex   in   vec3   Normal   in   vec2   TexCoord0   ifdef   WITH _ GS   данные   для   передача   в   геометрический   шейдер   out   vec3   gs _ vLightWS   out   vec3   gs _ vViewWS   out   vec3   gs _ vNormalWS   out   vec2   gs _ TexCoord   out   vec4   gs _ LightProjectedVertex   else   данные   для   передача   во   фрагментный   шейдер   out   vec3   vLightWS   out   vec3   vViewWS   out   vec3   vNormalWS   out   vec2   TexCoord   out   vec4   LightProjectedVertex   endif   void   main   vec4   vTransformedVertex   mTransform   Vertex   здесь   я   приводить   лишь   основной   ключевой   часть   шейдер   полный   код   см   в   прилагать   исходник   ifdef   WITH _ GS   передавать   исходный   вершина   в   геометрический   шейдер   gl _ Position   vTransformedVertex   else   просто   проецировать   вершина   как   обычно   gl _ Position   mModelViewProjection   vTransformedVertex   endif   теперь   давать   рассматривать   геометрический   шейдер   layout   triangles   in   layout   triangle _ strip   max _ vertices   18   out   на   выход   иметь   18   вершина   по   один   треугольник   на   каждый   из   шесть   грань   матрица   проецирование   на   каждый   из   грань   кубический   карта   uniform   mat4   mModelViewProjection   6   принимать   значение   из   вершинный   шейдер   in   vec3   gs _ vLightWS   in   vec3   gs _ vViewWS   in   vec3   gs _ vNormalWS   in   vec2   gs _ TexCoord   in   vec4   gs _ LightProjectedVertex   значение   передавать   во   фрагментный   шейдер   out   vec3   vLightWS   out   vec3   vViewWS   out   vec3   vNormalWS   out   vec2   TexCoord   out   vec4   LightProjectedVertex   void   main   проходить   цикл   по   весь   шесть   грань   кубический   карта   for   int   layer   0   layer   6   layer   gl _ Layer   layer   указывать   в   какой   грань   сейчас   должный   быть   направлять   вывод   и   далее   проецировать   каждый   из   грань   треугольник   все   это   можно   собирать   в   цикл   for   i   0   i   3   i   но   зачем   мы   еще   один   цикл   в   шейдер   здесь   я   также   приводить   лишь   основной   функционал   полный   код   шейдер   смотреть   в   исходник   gl _ Position   mModelViewProjection   layer   gl _ in   0   gl _ Position   EmitVertex   gl _ Position   mModelViewProjection   layer   gl _ in   1   gl _ Position   EmitVertex   gl _ Position   mModelViewProjection   layer   gl _ in   2   gl _ Position   EmitVertex   EndPrimitive   фрагментный   шейдер   мы   пока   оставлять   без   изменение   а   вот   отрисовка   в   данный   случай   быть   следующий   render   bindFramebuffer  _ reflectionRefractionCubemapBuffer   glClear   GL _ DEPTH _ BUFFER _ BIT   renderEnvironmentToCubeMap  _ modelCenter   полный   код   ф   ции   см   в   исходник   как   видеть   мы   нужный   только   один   отрисовка   вместо   шесть   конечно   возникать   вопрос   а   что   быстро   рисовать   6   раз   в   каждый   из   грань   либо   один   раз   но   с   увеличение   число   треугольник   в   геометрический   шейдер   на   самый   дело   скорость   работа   практически   одинаковый   но   вариант   с   геометрический   шейдер   я   нравиться   много   из   за   меньший   размер   код   и   его   красота   кубический   карта   у   мы   готовый   первый   или   второй   способ   теперь   можно   налагать   она   на   объект   и   посмотреть   что   же   из   это   выходить   предлагать   начинать   с   простой   шейдер   и   постепенно   наращивать   функционал   увеличивать   качество   изображение   для   начало   надо   сказать   что   при   рендеринг   стекло   мы   нужно   забывать   об   освещение   ламберт   это   то   который   dot   light   nomal   так   как   в   этот   раздел   речь   пойти   только   о   правильный   наложение   кубический   карта   то   я   пока   опускать   и   бликовый   освещение   и   переходить   непосредственно   к   дело   итак   у   мы   быть   кубический   карта   отрендеренная   из   центр   объект   в   шейдер   выборка   из   такой   текстура   происходить   следующий   образ   vec4   color   texture   cubemap   direction   где   direction   трехкомпонентный   вектор   по   который   определяться   грань   кубический   карта   и   текстурный   координата   на   этот   грань   предлагать   рассматривать   наложение   кубический   карта   на   сфера   так   как   стеклянный   шарик   быть   практически   у   каждый   и   вы   сам   смочь   использовать   он   как   некий   эталон   давать   для   начало   в   качество   направление   выборка   вектор   direction   использовать   нормаль   на   сфера   такой   образ   можно   проверять   правильно   ли   мы   отрисовать   наш   кубический   карта   при   такой   наложение   мы   увидеть   объект   так   как   бы   мы   они   видеть   из   центр   шар   в   направление   нормаль   надеяться   у   вы   сразу   получаться   правильно   отрисовать   кубический   карта   и   теперь   можно   переходить   к   более   сложный   алгоритм   давать   еще   раз   вспомнить   что   мы   собственно   хотеть   от   кубический   карта   это   отражение   и   преломление   давать   попробовать   налагать   кубический   карта   так   чтобы   сфера   отражать   луч   свет   хорошо   что   в   GLSL   быть   встроенный   функция   reflect   который   принимать   два   параметр   направление   луч   и   нормаль   к   плоскость   от   который   луч   свет   отражаться   разработчик   GLSL   избавлять   мы   от   необходимость   самостоятельный   вычисление   отраженный   вектор   по   формула   R   I   2   dot   N   I   N   где   I   incidence   падать   луч   N   normal   нормаль   итак   рассчитать   отраженный   вектор   и   сделать   выборка   из   кубический   карта   vec3   vReflected   reflect   vViewNormal   vNormalWS   FragColor   texture   environment _ map   vReflected   следовать   замечать   что   вектор   взгляд   должный   быть   нормировать   и   вычисляться   как   vertex   camera   а   не   наоборот   либо   как   в   приводить   код   использовать   знак   перед   вектор   взгляд   думать   это   следовать   пояснять   небольшой   рисунок   итак   сделать   выборка   в   направление   отраженный   вектор   и   увидеть   вот   такой   картинка   теперь   думать   самый   время   исследовать   преломление   луч   свет   как   известно   из   курс   физика   если   не   ошибаться   это   быть   даже   в   школьный   программа   луч   свет   преломляться   на   граница   два   среда   по   закон   снелла   n1sinϑ1   n2sinϑ2   где   n1   2   абсолютный   показатель   преломление   материал   отношение   скорость   свет   в   среда   к   скорость   свет   в   вакуум   ϑ1   2   угол   между   нормаль   и   соответственно   падать   луч   и   преломлять   мы   рассматривать   случай   когда   луч   свет   переходить   из   воздух   n1   1   0   в   стекло   n2   1   4   относительный   показатель   преломление   η   быть   равный   n1   n2   0   7   вот   мы   и   добираться   до   относительный   показатель   преломление   именно   он   использоваться   во   встроенный   функция   GLSL   refract   который   принимать   три   параметр   падать   луч   нормаль   и   показатель   преломление   vec3   vRefracted   refract   vViewNormal   vNormalWS   indexOfRefraction   FragColor   texture   environment _ map   vRefracted   результат   быть   вот   такой   картинка   итак   отражение   и   преломление   у   мы   быть   но   по   отдельность   как   же   они   совмещать   очень   просто   еще   в   1823   год   огюст   френель   вывести   формула   с   помощь   который   можно   рассчитать   доля   отраженный   энергия   в   зависимость   от   показатель   преломление   и   угол   падение   луч   сейчас   существовать   множество   аппроксимация   для   данный   формула   но   я   же   предлагать   использовать   оригинальный   формула   только   мы   она   немножко   сейчас   преобразовывать   вы   же   не   думать   что   я   предлагать   вы   вычислять   синус   и   косинус   итак   что   же   такой   cos   Θ   это   не   что   иной   как   скалярный   произведение   нормировать   вектор   взгляд   на   нормаль   в   данный   точка   единственный   что   хотеться   бы   сказать   вектор   взгляд   в   данный   случай   надо   вычислять   как   camera   vertex   с   косинус   разбираться   а   синус   быть   не   что   иной   как   корень   из   один   минус   квадрат   косинус   если   умножать   и   разделять   весь   выражение   под   степень   на   его   числитель   то   получать   сверху   квадрат   числитель   а   снизу   1   η2   теперь   формула   выглядеть   значительно   простой   кто   интересно   мочь   проделывать   этот   преобразование   вручную   или   в   любой   математический   пакет   такой   образ   на   самый   дело   нет   ничто   страшный   в   этот   формула   в   вычислительный   план   и   мы   мочь   вынести   вычисление   коэффициент   френель   в   отдельный   функция   вид   float   fresnel   float   VdotN   float   eta   float   sqr _ eta   eta   eta   квадрат   показатель   преломление   float   etaCos   eta   VdotN   η   cos   Θ   float   sqr _ etaCos   etaCos   etaCos   в   квадрат   float   one _ minSqrEta   1   0   sqr _ eta   1   η2   float   value   etaCos   sqrt   one _ minSqrEta   sqr _ etaCos   value   value   one _ minSqrEta   возводить   в   квадрат   и   делить   на   1   η2   return   min   1   0   value   value   финальный   возведение   в   квадрат   если   вывести   коэффициент   френель   в   качество   цвет   float   fFresnel   fresnel   dot   vViewNormal   vNormalWS   indexOfRefraction   FragColor   vec4   fFresnel   то   мы   увидеть   следующий   белый   область   соответствовать   больший   отражение   свет   черный   преломлять   луч   в   общий   то   у   мы   быть   все   чтобы   сделать   самый   примитивный   стекло   давать   просто   смешать   получать   ранее   цвет   для   отражение   и   преломлять   свет   с   учет   коэффициент   френель   FragColor   mix   cRefraction   cReflection   fFresnel   конечно   до   финальный   результат   еще   далековато   для   сравнение   сверху   результат   то   что   быть   описывать   выше   снизу   финальный   результат   который   мы   хотеть   добиваться   казаться   бы   разница   не   большой   но   если   вы   взять   стеклянный   шарик   то   увидеть   в   немой   картинка   на   который   быть   похожий   именно   финальный   результат   но   об   это   далеко   страница   1   2   следующий   caustic   glass   OpenGL   photon   mapping   31   июль   2010   обновление   1   авг   2010   комментарий   63   убирать   реклама   цена   на   спермограмма   www   gemotest   ru   analysis   catalog   spermogramma   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   GameDev   ru   разработка   игра   2001   2019