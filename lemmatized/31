   виртуальный   текстура   график   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   FAQ   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиграфика   виртуальный   текстура   автор   александр   самусев   виртуальный   текстура   или   мегатекстура   технология   развитый   джон   кармак   виртуальный   текстура   снимать   ограничение   на   арт   позволять   сделать   игровой   мир   более   уникальный   раскрашивать   неповторяющийся   текстура   в   этот   статья   вы   узнавать   о   структура   виртуальный   текстура   и   о   процесс   работа   с   она   1   предыстория   2   отличие   от   обычный   тайловый   текстура   3   структура   виртуальный   текстура   4   конвейер   4   1   определение   видимый   страница   виртуальный   текстура   4   2   анализ   feedback   буфер   4   3   загрузка   виртуальный   страница   4   4   обновление   текстурный   кеш   4   5   обновление   таблица   переадресация   4   6   рендеринг   сцена   5   фильтрация   текстура   6   заключение   7   литература   по   тема   1   предыстория   корень   виртуальный   текстура   упираться   еще   в   далекий   1998   год   когда   Christopher   C   Tanner   Christopher   J   Migdal   и   Michael   T   Jones   Silicon   Graphics   Computer   Systems   представлять   в   свой   доклад   так   называть   clipmaps   1   технология   clipmaps   находить   свой   применение   на   текстурирование   ландшафт   и   иметь   различный   ограничение   в   частность   ее   нельзя   быть   использовать   для   текстурирование   произвольный   геометрия   поздно   технология   быть   развивать   джон   кармак   John   Carmack   из   id   Software   и   быть   применять   в   игра   Rage   до   это   на   свой   заря   в   качество   эксперимент   использоваться   на   ландшафт   в   QuakeWars   2   так   называть   мегатекстура   или   виртуальный   текстура   в   отличие   от   clipmaps   накладываться   на   произвольный   геометрия   далее   мы   рассматривать   в   что   же   отличие   от   обычный   тайловый   тайлинговый   текстура   2   отличие   от   обычный   тайловый   текстура   виртуальный   текстура   позволять   сделать   игровой   мир   более   уникальный   снимать   ограничение   на   ART   позволять   раскрашивать   его   неповторяющийся   текстура   тоже   самый   можно   конечно   но   сложно   сделать   с   тайловый   текстура   при   это   вы   получать   примерно   тот   же   объем   данные   на   жесткий   диск   и   вдобавок   куча   неприятность   представлять   как   для   это   приходиться   разбивать   геометрия   и   сколько   потребоваться   видеопамять   при   использование   виртуальный   текстура   мы   не   нужно   дополнительно   разбивать   геометрия   а   расход   память   фиксировать   и   ограниченный   размер   текстурный   кеш   о   который   мы   поговорить   чуть   поздно   кроме   то   сниматься   потребность   в   переключение   текстура   при   рендеринг   геометрия   3   структура   виртуальный   текстура   технология   виртуальный   текстурирование   представлять   себя   особый   подход   к   менеджмент   текстура   виртуальный   текстура   состоять   из   несколько   mip   уровень   каждый   из   который   поделить   на   страница   фиксированный   размер   количество   уровень   определяться   размер   виртуальный   текстура   и   мочь   быть   определять   по   следующий   формула   n   log2   VtSize   PageSize   1   1   где   n   количество   mip   уровень   VtSize   размер   виртуальный   текстура   по   один   из   ось   PageSize   размер   страница   по   один   из   ось   отмечать   что   технология   описываемя   в   данный   статья   подразумевать   что   размер   виртуальный   текстура   по   вертикаль   и   горизонталь   равный   и   кратный   степень   двойка   как   и   размер   страница   размер   страница   выбираться   произвольно   исходить   из   потребность   так   размер   страница   в   idTech   5   равный   128   х   128   пиксел   2   для   удобство   быть   нумеровать   mip   уровень   следующий   образ   нулевой   уровень   соответствовать   размер   текстура   128х128   пиксел   соответствовать   размер   один   страница   первый   256х256   второй   512х512   третий   2048х2048   и   так   далее   отмечать   что   это   не   соответствовать   нумерация   принимать   в   OpenGL   т   к   там   нулевой   mip   уровень   соответствовать   максимальный   размер   текстура   почему   нумерация   выбирать   данные   образ   становиться   понятно   далее   нумерация   страница   в   mip   уровень   представлять   на   рисунок   1   рисунок   1   нумерация   страница   виртуальный   текстура   внутри   mip   уровень   как   видно   из   рисунок   1   очевидно   что   удобно   все   виртуальный   текстура   быть   хранить   на   жесткий   диск   в   вид   последовательность   страница   0   1   2   3   4   и   так   далее   такой   образ   доступ   к   данные   страница   просто   вычислять   по   формула   PageFileOffset   PageNumber   PageSize   PageSize   Bpp   2   где   PageFileOffset   смещение   относительно   заголовок   файл   PageNumber   номер   страница   PageSize   размер   страница   Bpp   количество   байт   на   пиксел   очевидно   также   что   это   не   единственный   способ   хранение   виртуальный   текстура   эффективно   все   хранить   страница   в   сжатый   вид   но   это   выходить   за   рамка   данный   статья   4   конвейер   весь   процесс   работа   с   виртуальный   текстура   можно   разбивать   на   несколько   основной   этап   1   определение   видимый   страница   виртуальный   текстура   2   анализ   пункт   1   формирование   список   страница   на   загрузка   отсортировывать   по   приоритет   очередь   приоритет   3   в   соответствие   с   очередь   приоритет   загрузка   виртуальный   страница   в   оперативный   память   формирование   список   загружать   страница   данный   этап   можно   вынести   в   отдельный   поток   4   обновление   текстурный   кеш   5   обновление   таблица   переадресация   6   рендеринг   сцена   далее   мы   рассматривать   каждый   пункт   более   подробно   4   1   определение   видимый   страница   виртуальный   текстура   на   данный   этап   мы   нужно   определять   номер   видимый   страница   ну   и   соответственно   номер   mip   уровень   к   который   данный   страница   принадлежать   я   пробовать   два   способ   определение   видимый   страница   виртуальный   текстура   первый   из   они   основываться   на   принцип   рендеринг   в   сцена   в   текстурный   пространство   4   то   быть   мы   рисовать   сцена   в   текстура   использовать   не   мировой   координата   вершина   а   текстурный   при   это   размер   один   страница   в   текстурный   пространство   соответствовать   один   пиксел   данный   метод   иметь   куча   проблема   так   как   при   рендеринг   в   текстурный   пространство   стандартный   способ   отсечение   уже   не   работать   а   в   шейдер   нужно   передавать   информация   о   плоскость   пирамида   видимость   frustum   и   рассчитывать   clipping   distances   кроме   то   необходимый   ручной   backface   culling   еще   один   существенный   недостаток   данный   метод   являться   необходимость   определение   не   загораживать   ли   один   объект   другой   чтобы   не   допускать   рендеринг   невидимый   в   данный   момент   объект   ну   и   последний   недостаток   который   заставлять   я   выбирать   другой   метод   это   необходимость   в   так   называть   консервативный   растеризатор   conservative   rasterizer   3   дело   в   то   что   если   видно   только   около   50   процент   страница   то   стандартный   GPU   растеризатор   попросту   не   быть   растеризировать   она   в   один   пиксел   такой   образ   мы   терять   ценный   информация   о   нужный   страница   учитывать   сложность   реализация   консервативный   растеризатор   3   данный   метод   в   наш   случай   оказываться   неэффективный   второй   метод   простой   он   заключаться   в   ренедеринг   сцена   в   текстура   feedback   buffer   при   это   в   каждый   пиксел   получать   текстура   кодироваться   номер   страница   виртуальный   текстура   очевидный   недостаток   данный   метод   он   избыточный   так   как   в   разный   пиксел   feedback   буфер   мочь   быть   закодировать   информация   об   одинаковый   страница   использовать   некоторый   приближение   на   практика   размер   feedback   буфер   оказываться   достаточный   выбирать   в   десять   раз   мало   текущий   разрешение   экран   5   что   в   раз   снижать   нагрузка   на   анализ   данный   буфер   далее   мы   рассматривать   какой   образ   кодироваться   информация   о   видимый   страница   и   как   по   виртуальный   координата   определяться   их   номер   на   вход   вершинный   шейдер   мы   оперировать   виртуальный   координата   текстура   virtUV   этап   получение   номер   страница   состоять   из   определение   текущий   mip   уровень   miplevel   и   положение   страница   относительно   текущий   mip   уровень   pageOffset   pageOffset   virtUV   exp2   miplevel   3   на   выход   в   pageOffset   быть   номер   страница   по   x   и   по   y   относительно   текущий   mip   уровень   далее   не   составлять   сложность   простой   арифметический   операция   преобразовывать   pageOffset   в   pageNumber   рисунок   1   здесь   быть   небольшой   тонкость   дело   в   то   что   в   шейдер   мы   мочь   закодировать   число   от   0   до   255   на   один   канал   при   размер   виртуальный   текстура   использовать   в   игра   Rage   128к   x   128k   пиксел   на   верхний   mip   уровень   pageOffset   мочь   превышать   число   255   решать   этот   ограничение   можно   использовать   дополнительный   канал   в   который   кодироваться   дополнительный   восемь   бит   по   четыре   на   pageOffset   x   и   pageOffset   y   такой   образ   максимальный   количество   страница   который   мы   мочь   закодировать   увеличиваться   до   4095   по   x   и   столько   же   по   y   в   оставаться   четвертый   канал   мы   записывать   номер   mip   уровень   страница   еще   один   способ   снимать   ограничение   являться   использование   float   текстура   с   32   битный   канал   но   в   наш   случай   это   накладно   т   к   в   последствие   мы   нужно   быть   передавать   текстура   в   оперативный   память   для   она   анализ   теперь   когда   мы   иметь   feedback   буфер   мы   мочь   приступать   к   он   анализ   4   2   анализ   feedback   буфер   на   данный   этап   мы   нужно   проанализировать   получать   feedback   буфер   и   сформировывать   очередь   страница   на   загрузка   для   это   нужно   прочитывать   данные   в   оперативный   память   из   видео   память   к   счастие   OpenGL   и   DirectX   позволять   это   сделать   правда   цена   медленный   скорость   передача   данные   из   GPU   в   цикл   мы   для   каждый   пиксел   feedback   буфер   декодировать   pageOffset   и   miplevel   преобразовывать   их   в   PageNumber   нумерация   страница   изображать   на   рисунок   1   здесь   мы   понадобиться   дополнительный   структура   данные   так   называть   таблица   страница   pageTable   физически   это   обычный   массив   размер   который   равный   общий   число   страница   TotalPages   каждый   элемент   представлять   себя   структура   из   положение   страница   в   текстурный   кеш   pageX   pageY   и   ее   mip   уровенить   также   предлагаться   создавать   аналогичный   размер   массив   pageInfoTable   поскольку   предлагать   организация   расположение   страница   внутри   mip   уровень   отлично   подходить   для   реализация   Quad   tree   в   pageInfoTable   мы   мочь   сохранять   дополнительный   информация   о   страница   а   именно   о   ее   потомок   а   также   переменный   для   хранение   флаг   Cached   Needed   быть   решать   отделять   pageTable   и   pageInfoTable   только   ради   удобство   подробно   об   это   быть   сказать   чуть   поздно   на   пятый   этап   при   создание   таблица   переадресация   суммировать   вышесказанный   грубый   алгоритм   анализ   feedback   буфер   мочь   быть   представлять   в   вид   следующий   псевдокод   while   читать _ данные _ из _ feedback _ буфер   pageNumber   декодировать _ номер _ страница   текущий _ пиксел   mipLevel   получать _ мип _ уровень   текущий _ пиксел   if   pageInfoTable   pageNumber   flags   CACHED   if   pageInfoTable   pageNumber   flags   NEEDED   pageInfoTable   pageNumber   flags   NEEDED   PriorityQueueNode   n   new   PriorityQueueNode   n   pageNumber   pageNumber   n   mipLevel   mipLevel   priorityQueue   push _ back   n   else   int   cacheIndex   pageTable   pageIndex   pageY   PageCacheGridSize   pageTable   pageIndex   pageX   pageCacheInfo   cacheIndex   time   текущий _ время   вводить   флаг   Needed   мы   исключать   попадание   в   очередь   на   загрузка   одинаковый   страница   а   по   флаг   Cached   мы   исключать   загрузка   страница   который   уже   загружать   в   текстурный   кеш   в   этот   случай   мы   просто   обновлять   время   последний   запрос   страница   в   дальнейший   мы   понадобиться   определять   как   давно   давать   страница   использоваться   чтобы   эффективно   обновлять   текстурный   кеш   этот   информация   храниться   в   pageCacheInfo   при   анализ   feedback   буфер   также   необходимый   сортировка   страница   на   загрузка   по   приоритет   так   чтобы   первый   в   очередь   на   загрузка   быть   страница   с   более   высокий   приоритет   4   3   загрузка   виртуальный   страница   данный   этап   конвейер   легко   распараллеливаться   в   данный   поток   мы   просматривать   очередь   сформировывать   на   этап   анализ   по   формула   2   вычислять   смещение   страница   в   файл   и   формировать   список   загружать   страница   4   4   обновление   текстурный   кеш   мы   подходить   вплотную   к   рассмотрение   так   называть   текстурный   кеш   или   физический   текстура   текстурный   кеш   это   обычный   текстура   располагаться   в   видео   память   так   в   игра   Rage   размер   этот   текстура   составлять   32х32   страница   или   4096х4096   пиксел   2   здесь   необходимо   определять   какой   страница   в   кеш   давно   не   использоваться   для   что   мы   понадобиться   вышеупомянутый   pageCacheInfo   далее   просто   копировать   страница   в   нужный   позиция   текстурный   кеш   помечать   страница   как   Cached   и   снимать   флаг   Cached   со   страница   который   быть   ранее   на   этот   место   4   5   обновление   таблица   переадресация   для   то   чтобы   преобразовывать   виртуальный   координата   в   физический   или   координата   текстурный   кеш   на   этап   рендеринг   сцена   мы   понадобиться   таблица   переадресация   для   это   мы   хорошо   подходить   вышеупомянутый   pageTable   сразу   после   обновление   текстурный   кеш   мы   пробегаться   по   весь   элемент   pageTable   начинать   с   первый   при   этот   если   страница   отсутствовать   в   кеш   проверять   флаг   Cached   мы   приравнивать   pageX   pageY   и   mipLevel   текущий   элемент   pageTable   к   pageX   pageY   и   mipLevel   родительский   такой   образ   мы   пробегаться   по   весь   лист   узел   Quad   tree   в   каждый   храниться   положение   страница   в   кеш   и   ее   mip   уровень   отмечать   что   mip   уровень   страница   в   лист   Quad   tree   мочь   несоответствовать   уровень   лист   в   Quad   tree   поскольку   напрямую   использовать   таблица   переадресация   pageTable   из   шейдер   мы   не   мочь   здесь   мы   понадобиться   еще   один   текстура   текстура   переадресация   этот   текстура   быть   иметь   то   же   количество   mip   уровень   что   и   наш   Quad   tree   обычный   копирование   pageTable   заполнять   mip   уровень   текстура   переадресация   поскольку   элемент   pageTable   представлять   себя   трехбайтовый   структура   pageX   pageY   mipLevel   это   хороший   совместимый   с   трехкомпонентный   текстура   теперь   становиться   понятно   почему   мы   отделять   pageInfoTable   от   pageTable   итак   мы   подходить   к   финальный   этап   к   рендеринг   сцена   4   6   рендеринг   сцена   итак   мы   иметь   набор   вершина   с   виртуальный   текстурный   координата   текстурный   кеш   текстура   переадресация   весь   это   мы   легко   мочь   использовать   в   шейдер   мы   рассчитывать   текущий   texture   lod   в   GLSL   он   можно   рассчитать   с   помощь   dFdx   dFdy   далее   с   помощь   textureLod   на   вход   который   подавать   виртуальный   координата   и   рассчитать   mip   level   lod   извлекать   из   текстура   переадресация   координата   страница   в   текстурный   кеш   vec4   ind   textureLod   indirectionTable   virtUV   lod   ind   floor   ind   255   0   vec2   pageXY   ind   xy   float   mipLevel   ind   z   далее   мы   мочь   рассчитать   физический   координата   vec2   local   fract   virtUV   exp2   mipLevel   vec2   physUV   pageXY   local   CACHE _ SIZE   здесь   CACHE _ SIZE   равный   количество   страница   в   кеш   по   один   из   ось   в   наш   случай   размер   кеш   по   оба   ось   одинаковый   т   е   составлять   32   страница   общий   число   страница   в   кеш   32х32   1024   для   наглядность   мип   уровень   отображать   на   рисунок   2   показывать   скрывать   рисунок   2   видео   в   игра   Rage   5   фильтрация   текстура   поскольку   страница   в   кеш   храниться   в   хаотичный   порядок   мы   мочь   сталкиваться   с   проблема   фильтрация   текстура   на   граница   страница   эффективный   способ   решение   данный   проблема   являться   добавление   некоторый   число   пиксел   на   граница   страница   ребята   из   id   Software   использовать   размер   border   а   равный   4   пиксел   для   каждый   из   сторона   т   е   фактически   визуально   страница   иметь   размер   120х120   пиксел   вместо   128х128   5   6   заключение   на   первый   взгляд   высоко   описывать   конвейер   мочь   показываться   сложный   для   реализация   однако   к   счастие   он   нужно   написать   один   раз   вместе   с   то   мы   получать   возможность   сделать   игровой   мир   более   красивый   и   детализировать   быть   и   противник   данный   технология   действительно   объем   дисковый   пространство   мегатекстура   занимать   немалый   а   несвоевременный   подгрузка   страница   в   текстурный   кеш   мочь   выходить   в   вид   артефакт   при   рендеринг   пример   сие   игра   Rage   кроме   то   необходимый   специфический   тулза   который   поддерживать   мегатекстурирование   однако   несмотря   на   это   виртуальный   текстура   на   мой   взгляд   это   большой   шаг   по   путь   к   фотореалистичный   рендеринг   7   литература   по   тема   1   TANNER   C   C   MIGDAL   C   J   JONES   M   T   The   clipmap   A   virtual   mipmap   In   SIGGRAPH   1998   1998   2   idTech   5   Challenges   From   Texture   Virtualization   to   Massive   Parallelization   3   GPU   Gems   2   Chapter   42   Conservative   Rasterization   4   Sylvain   Lefebvre   Jérome   Darbon   Fabrice   Neyret   Unified   Texture   Management   for   Arbitrary   Meshes   5   GPU   Technology   Conference   Using   Virtual   Texturing   to   Handle   Massive   Texture   Data   clipmaps   мегатекстура   текстурирование   4   июль   2012   комментарий   100   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   GameDev   ru   разработка   игра   2001   2019