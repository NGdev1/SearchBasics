   писать   отладчик   для   Lua   5   1   общий   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   FAQ   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиобщий   писать   отладчик   для   Lua   5   1   автор   ex   в   современный   игра   достаточно   многое   отдаваться   на   откуп   скрипт   самый   распространенный   и   часто   использовать   для   это   скриптовый   язык   являться   Lua   удобный   синтаксис   хороший   скорость   особенно   при   использование   LuaJIT   кроссплатформенность   Lua   использоваться   в   проект   любой   масштаб   от   небольшой   аркада   до   монстр   вроде   World   Of   Warcraft   введение   Breakpoints   Call   stack   Watch   послесловие   введение   при   написание   небольшой   скрипт   не   возникать   проблема   отладка   запись   в   лог   встроенный   проверка   синтаксис   это   достаточно   чтобы   находить   ошибка   в   код   из   сотня   строка   но   проект   разрастаться   все   много   отдаваться   на   откуп   скрипт   в   большой   проект   с   активный   использование   скрипт   без   нормальный   отладчик   не   обходиться   как   это   ни   странно   но   инструмент   для   отладка   практически   нет   я   быть   находить   два   более   менее   адекватный   внешний   отладчик   Decoda   создавать   впечатление   удобный   инструмент   однако   платный   и   LuaEdit   opensource   до   сей   пора   не   релиз   и   не   факт   что   быть   RemDebug   консольный   отладчик   последний   обновление   2006   год   из   встраивать   библиотека   ldb   не   поддерживать   с   2000   год   на   фон   такой   раздолье   не   оставаться   выбор   кроме   как   писать   свой   велосипед   информация   по   написание   отладчик   практически   нет   приходиться   копать   документация   и   собирать   по   крупинка   гугл   стабильно   предлагать   для   отладка   использовать   print   в   этот   статья   я   рассматривать   реализация   три   необходимый   для   отладка   задача   breakpoints   watch   callstack   пример   в   статья   написать   на   паскаль   так   как   работа   со   строка   в   он   просто   и   наглядно   чем   в   C   никакой   труд   не   составлять   переводить   код   на   с   или   любой   другой   язык   Breakpoints   для   реализация   breakpoints   в   Lua   быть   свой   инстумент   Hooks   однако   я   отказываться   от   его   использование   по   два   причина   1   так   и   не   удаваться   заставлять   он   работать   вроде   бы   все   просто   вызов   lua _ sethook   с   MASKLINE   обработка   hook   функция   но   сколько   не   пытаться   hook   ловить   любой   событие   кроме   HOOKLINE   2   тысяча   строка   код   отладка   маленький   функция   10   брейкпоинтов   и   хук   на   каждый   выполняему   строчка   это   явно   не   то   что   мы   нужно   сделать   по   аналогия   с   int   3   при   загрузка   скрипт   в   нужный   мы   место   вставлять   вызов   наш   функция   debug _ breakpoint   id   где   id   номер   брейкпоинт   в   наш   внутренний   список   в   отличие   от   нормальный   дебагер   у   мы   получаться   два   тип   брейкпоинтов   обычный   и   фоновый   обычный   брейкпоинт   ничто   не   отличаться   от   все   привычный   брейкпонит   в   классический   отладчик   фоновый   это   для   трассировка   так   как   у   мы   нет   возможность   сделать   нормальный   трассировка   также   фоновый   мы   мочь   в   реальный   время   заменять   на   обычный   без   перезагрузка   скрипт   debug _ breakpoint   в   случай   если   активный   брейкпоинт   с   номер   id   или   сейчас   идти   трассировка   выполнять   нужный   операция   заполнение   call   stack   обновление   watch   переменный   остановка   весь   процесс   в   движок   кроме   обработка   окно   дебаггер   Call   stack   логика   получение   список   вызов   достаточно   простой   нужно   просматривать   стек   и   вычленять   из   он   функция   в   библиотека   debug   быть   готовый   функция   debug   traceback   но   она   доступный   только   в   скрипт   по   неизвестный   причина   в   LuaAPI   она   не   вынести   конечно   можно   вызывать   Lua   функция   и   забирать   результат   но   это   не   похожий   на   хороший   решение   хотя   traceback   и   не   реализовать   на   уровень   LuaAPI   его   реализация   можно   сделать   самостоятельно   с   помощь   другой   функция   LuaAPI   с   помощь   функци   lua _ getstack   в   цикл   получать   информация   об   уровень   выполнение   начинать   с   1   вообще   стек   индексироваться   с   0   но   0   это   debug _ breakpoint   информация   о   он   мы   получать   не   нужно   и   до   тот   пора   пока   lua _ getstack   не   вернуть   0   до   тот   пора   пока   стек   не   кончаться   lua _ getstack   быть   возвращать   1   от   lua _ getstack   мы   нужно   заполнение   структура   lua _ Debug   который   мы   передавать   в   lua _ getinfo   параметр   what   должный   содержать   символ   Sn   S   для   заполнение   информация   по   исходный   код   n   для   заполнение   информация   об   имя   код   функция   быть   примерно   такой   procedure   luaTraceback   LuaState   Pointer   List   TCallStackList   var   Level   integer   ar   lua _ Debug   Item   TCallStackListItem   begin   Level   1   while   lua _ getstack   LuaState   Level   ar   1   do   begin   lua _ getinfo   LuaState   Sn   ar   if   ar   name   nil   then   Item   FunctionName   ar   name   else   Item   FunctionName   unknown   if   ar   namewhat   nil   then   Item   FunctionType   ar   namewhat   else   Item   FunctionType   unknown   Item   RunType   ar   what   Item   ChunkName   ar   source   List   Add   Item   inc   Level   end   end   lua _ Debug   name   этот   имя   функция   если   определять   имя   функция   невозможно   nil   lua _ Debug   namewhat   это   где   функция   определять   метод   таблица   поле   таблица   в   корень   и   т   п   lua _ Debug   what   это   среда   исполнение   мочь   быть   Lua   или   C   lua _ Debug   source   это   место   где   определять   исходный   код   если   код   загружать   из   файл   то   это   имя   файл   если   из   память   то   имя   чанка   Watch   реализация   слежение   за   переменный   достаточно   простой   никакой   костыль   придумывать   не   приходиться   весь   нужный   инструментарий   предоставлять   LuaAPI   думать   что   с   задача   распарсить   на   часть   строка   вид   self   Objects   0   Caption   вы   справляться   сам   в   Watch   мы   хотеть   иметь   доступ   к   глобальный   переменный   аргумент   функция   и   локальный   переменный   аргумент   функция   относиться   к   локальный   переменный   так   что   обрабатываться   они   вместе   как   и   при   обычный   работа   с   переменный   наш   задача   помещать   переменный   на   вершина   стек   из   она   получать   новый   переменная   и   помещать   она   на   вершина   стек   и   так   пока   не   доходить   до   последний   переменная   в   выражение   с   глобальный   переменный   весь   просто   работать   как   и   всегда   а   вот   с   локальный   сложно   дело   в   то   что   мы   зайти   в   брейкпоинт   с   помощь   функция   debug _ breakpoint   а   значит   в   стек   лежать   переменный   принадлежать   этот   функция   а   отлаживать   функция   находиться   на   стек   на   уровень   высокий   и   обычный   средство   недоступный   к   счастие   LuaAPI   предоставлять   доступ   к   любой   уровень   на   стек   с   помощь   уже   известный   функция   lua _ getstack   тогда   функция   для   вынесение   локальный   переменный   на   вершина   стек   быть   выглядеть   так   Function   luaGetLocalVariable   LuaState   Pointer   const   Name   string   boolean   var   ar   lua _ Debug   VarName   PChar   current   integer   begin   Result   false   if   lua _ getstack   LuaState   1   ar   1   then   begin   вообще   все   сломаться   почему   то   если   getstack   не   срабатывать   твориться   что   то   очень   плохой   Exit   end   current   1   VarName   lua _ getlocal   LuaState   ar   current   while   VarName   nil   do   begin   if   VarName   Name   then   begin   Result   true   получать   нужный   переменная   на   вершина   стек   возвращать   true   и   выходить   Exit   end   lua _ pop   LuaState   1   это   не   тот   переменный   который   мы   нужный   убирать   она   с   вершина   стек   VarName   lua _ getlocal   LuaState   ar   current   inc   current   end   end   послесловие   что   получаться   у   я   после   использование   все   высокий   описывать   вы   мочь   увидеть   в   видео   располагать   ниже   любой   вопрос   дополнение   и   исправление   вы   мочь   писать   в   комментарий   к   статья   как   выясняться   поздно   хук   на   строка   не   ставиться   из   за   использование   LuaJIT   если   использовать   для   отладка   обычный   Lua   библиотека   хук   работать   в   штатный   режим   иметь   смысл   делать   хук   стандартный   способ   скорость   работа   существенно   падать   но   зато   расти   эффективность   отладка   Debugger   Lua   отладка   скрипт   27   апрель   2011   обновление   26   окт   2011   комментарий   25   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   GameDev   ru   разработка   игра   2001   2019