   Unity   Character   Motor   физика   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   FAQ   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьифизика   Unity   Character   Motor   автор   WISHMASTER35   когда   то   давно   еще   во   время   Unity   3   я   становиться   интересно   как   работать   физика   персонаж   и   я   заглядывать   в   класс   CharacterMotor   класс   быть   написать   на   JavaScript   быть   огромный   страшный   и   непонятный   я   решать   переписывать   он   на   C   попутно   отрефакторить   недавно   я   вспомнить   про   свой   старый   CharacterMotor   решать   еще   немного   подправлять   он   и   поделиться   они   то   более   тема   физика   персонаж   не   очень   популярный   я   вообще   не   видеть   никакой   информация   хотя   довольно   интересный   1   введение   2   CharacterController   3   CharacterMotor   4   CharacterMotor _ Movement   5   CharacterMotor _ Jumping   6   FPSInputController   7   MouseLook   8   заключение   1   введение   я   взять   за   основа   CharacterMotor   из   Unity   3   в   Unity   4   CharacterMotor   не   меняться   а   вот   в   Unity   5   это   абсолютно   новый   класс   новый   CharacterMotor   значительно   уменьшаться   в   код   и   видимо   и   в   функционал   я   не   особо   разбираться   в   немой   и   почти   не   использовать   он   но   замечать   что   скольжение   с   крутой   склон   теперь   не   работать   и   вообще   качество   код   я   не   понравиться   видимо   писаться   он   на   скорый   рука   также   Unity   5   переходить   на   новый   PhysX   3   но   в   CharacterController   я   никакой   изменение   не   замечать   так   что   думать   мой   CharacterMotor   не   устаревать   2   CharacterController   обычно   персонаж   не   являться   обычный   физический   объект   и   работать   по   свой   закон   физика   в   Unity   для   персонаж   использоваться   CharacterController   это   комбинация   коллайдер   в   форма   капсула   и   метод   Move   метод   Move   двигать   персонаж   в   указанный   позиция   обрабатывать   при   это   коллизия   обработка   коллизия   тут   тоже   не   обычный   например   коллизия   обрабатываться   так   чтобы   персонаж   мочь   свободно   подниматься   на   небольшой   склон   но   не   мочь   на   большой   или   auto   stepping   фич   который   позволять   персонаж   подниматься   на   маленький   препятствие   CharacterController   не   совмещать   с   RigidBody   это   значит   что   он   не   мочь   взаимодействовать   с   другой   физический   объект   это   создавать   некоторый   проблема   персонаж   не   мочь   двигать   другой   физический   объект   а   другой   объект   не   мочь   сдвигать   персонаж   кинематический   объект   вообще   свободно   проходить   сквозь   персонаж   что   делать   проблематичный   создание   лифт   и   двигаться   платформа   3   CharacterMotor   вместо   RigidBody   мы   должный   использовать   свой   класс   в   Unity   это   CharacterMotor   хотя   CharacterMotor   это   намного   большой   чем   RigidBody   CharacterMotor   отвечать   за   любой   движение   наш   персонаж   например   ходьба   бег   скольжение   падение   прыжок   движение   на   платформа   на   лифт   подъем   по   вертикальный   лестница   плавание   весь   это   реализоваться   фактически   с   помощь   различный   ухищрение   а   не   закон   физика   ведь   персонаж   обычно   вести   себя   не   по   закон   например   персонаж   мочь   немного   управляться   во   время   прыжок   или   падение   или   просто   резко   останавливаться   или   менять   направление   движение   в   Painkiller   дэниел   мочь   ускоряться   просто   прыгать   без   разбег   конечно   это   все   не   сильно   нарушать   закон   игровой   физика   и   можно   быть   бы   попытаться   сделать   максимально   весь   физически   корректно   но   ведь   просто   просто   ограничивать   скорость   падение   чем   вычислять   сопротивление   воздух   я   разделять   мой   CharacterMotor   на   3   partial   класс   CharacterMotor   CharacterMotor _ Movement   и   CharacterMotor _ Jumping   в   оригинальный   класс   быть   еще   класс   отвечать   за   движение   на   платформа   но   я   убирать   он   базовый   часть   CharacterMotor   реализовать   следующий   событие   FixedUpdate   в   который   вызываться   весь   функция   необходимый   для   вычисление   скорость   в   оригинальный   класс   можно   быть   выбирать   использовать   Update   или   FixedUpdate   но   я   убирать   это   т   к   движение   игрок   в   FixedUpdate   выглядеть   вполне   плавно   и   требовать   мало   вычислительный   нагрузка   событие   OnControllerColliderHit   в   который   определяться   стоить   ли   персонаж   на   земля   или   нет   здесь   быть   один   маленький   деталь   персонаж   не   мочь   вставать   на   земля   если   он   находиться   в   состояние   прыжок   и   его   скорость   направлять   вверх   это   нужный   для   то   чтобы   когда   игрок   прыгать   на   крутой   склон   и   касаться   его   то   прыжок   продолжаться   ApplyDownOffset   и   CancelDownOffset   иногда   персонаж   мочь   отрываться   от   земля   чтобы   предотвращать   это   мы   как   бы   применять   дополнительный   гравитация   метод   ApplyDownOffset   смещать   позиция   персонаж   вниз   если   после   этот   смещение   персонаж   все   же   не   касаться   земля   то   это   смещение   нужно   отменять   метод   CancelDownOffset   благодаря   это   персонаж   мочь   с   разбег   переходить   на   очень   крутой   склон   не   отрываться   от   земля   но   можно   поспорить   хороший   это   или   плохой   ибо   пара   это   выглядеть   не   реалистичный   и   странно   возможно   быть   хорошо   уменьшать   смещение   показывать   скрывать   using   UnityEngine   using   System   Collections   using   System   Collections   Generic   AddComponentMenu   Character   CharacterMotor   RequireComponent   typeof   CharacterController   public   partial   class   CharacterMotor   MonoBehaviour   public   CharacterController   controller   get   private   set   internal   Vector3   velocity   internal   Collider   ground   internal   Vector3   groundPoint   groundNormal   internal   Vector3   inputMoveDirection   направление   движение   internal   bool   inputAcceleration   ускоренный   движение   internal   bool   inputJump   прыжок   internal   bool   inputJumpHolding   усиливать   прыжок   public   bool   isGrounded   get   return   ground   null   public   bool   isSliding   get   return   isGrounded   groundNormal   y   Mathf   Cos   controller   slopeLimit   Mathf   Deg2Rad   void   Awake   controller   GetComponent   CharacterController   void   OnEnable   velocity   controller   velocity   private   void   FixedUpdate   ApplyMoving   ApplyGravity   ApplyJumping   var   prevVelocity   velocity   Move   ApplyBraking   prevVelocity   ref   velocity   private   void   Move   Debug   DrawRay   transform   position   velocity   Color   blue   var   offset   ApplyDownOffset   ground   null   groundPoint   groundNormal   Vector3   zero   controller   Move   velocity   Time   deltaTime   velocity   controller   velocity   CancelDownOffset   offset   if   isGrounded   Debug   DrawRay   groundPoint   groundNormal   Color   red   private   float   ApplyDownOffset   из   за   недостаточный   гравитация   персонаж   мочь   отрываться   от   земля   для   предотвращение   это   применять   смещение   вниз   if   isGrounded   isJumping   float   downOffset   Mathf   Max   controller   stepOffset   GetXZ   velocity   magnitude   velocity   Vector3   up   downOffset   return   downOffset   return   0   private   void   CancelDownOffset   float   downOffset   если   персонаж   не   касаться   земля   то   мы   должный   отменять   смещение   if   isGrounded   downOffset   0   transform   position   Vector3   up   downOffset   Time   deltaTime   offset   за   кадр   velocity   Vector3   up   downOffset   offset   за   секунда   void   OnControllerColliderHit   ControllerColliderHit   hit   Debug   DrawRay   hit   point   hit   normal   Color   green   if   isJumping   velocity   y   0   во   время   прыжок   персонаж   не   мочь   вставать   на   земля   if   hit   normal   y   float   Epsilon   IsBelowPart   hit   point   y   if   hit   normal   y   groundNormal   y   выбирать   самый   горизонтальный   поверхность   ground   hit   collider   groundPoint   hit   point   groundNormal   hit   normal   private   bool   IsBelowPart   float   y   float   bottom   transform   position   y   controller   center   y   controller   height   2   controller   radius   return   y   bottom   private   static   Vector3   GetXZ   Vector3   v   return   new   Vector3   v   x   0   v   z   4   CharacterMotor _ Movement   этот   часть   класс   отвечать   за   движение   и   гравитация   и   реализовывать   следующий   ApplyMoving   этот   функция   отвечать   за   ходьба   и   скольжение   по   крутой   склон   кстати   двигаться   персонаж   мочь   и   находиться   в   воздух   движение   реализоваться   не   сила   или   импульс   а   прямой   изменение   скорость   с   помощь   Vector3   MoveTowards   у   этот   подход   быть   свой   плюс   и   минус   главный   плюс   мы   напрямую   задавать   нужный   мы   скорость   другой   особенность   автоматически   реализоваться   сила   трение   и   сила   сопротивление   воздух   но   плюс   это   или   минус   затрудняться   сказать   т   к   при   нормальный   симуляция   физика   сила   суммироваться   но   в   данный   реализация   если   персонаж   уже   иметь   скорость   и   при   это   еще   и   сам   двигаться   то   оба   этот   скорость   не   быть   суммироваться   на   мой   взгляд   этот   функция   самый   спорный   место   т   к   по   логика   вещь   скольжение   здесь   не   место   ведь   скольжение   происходить   под   действие   гравитация   а   не   из   за   движение   игрок   GetDesiredVelocity   функция   вычислять   желаемый   скорость   ходьба   или   бега   GetDirectionSpeedFactor   когда   игрок   идти   бок   или   зад   то   его   скорость   должный   быть   мало   GetSlopeSpeedFactor   когда   игрок   идти   вверх   по   склон   то   его   скорость   тоже   уменьшаться   GetDesiredSlidingVelocity   функция   вычислять   желаемый   скорость   скольжение   когда   персонаж   находиться   на   крутой   склон   то   он   должный   скользить   вниз   по   склон   при   это   игрок   мочь   немного   управлять   свой   движение   AdjustVelocityToGround   выравнивание   вектор   скорость   вдоль   земля   этот   функция   должный   обеспечивать   хороший   соприкасаемость   персонаж   с   земля   но   так   как   это   заниматься   ApplyDownOffset   то   вероятно   в   этот   функция   нет   никакой   смысл   ApplyBraking   когда   персонаж   упираться   в   стена   то   надо   уменьшать   он   скорость   чтобы   он   не   бежать   вдоль   стена   упереться   в   она   нос   ApplyGravity   тут   весь   просто   и   ясно   показывать   скрывать   using   UnityEngine   using   System   Collections   partial   class   CharacterMotor   private   const   float   Gravity   20   private   const   float   MaxFallSpeed   20   private   const   float   WalkSpeed   6   private   const   float   RunSpeed   9   private   const   float   SlidingSpeed   0   4f   private   const   float   SlidingSideSpeed   1   0f   private   const   float   GroundAcceleration   20   private   const   float   AirAcceleration   5   private   void   ApplyMoving   Vector3   desiredVelocity   if   isSliding   desiredVelocity   GetDesiredSlidingVelocity   else   desiredVelocity   GetDesiredVelocity   if   isGrounded   desiredVelocity   AdjustVelocityToGround   desiredVelocity   groundNormal   else   desiredVelocity   y   velocity   y   velocity   Vector3   MoveTowards   velocity   desiredVelocity   GetAcceleration   isGrounded   Time   deltaTime   private   void   ApplyGravity   if   isJumping   velocity   y   Mathf   Min   velocity   y   0   auto   stepping   мочь   толкать   персонаж   вверх   предотвращать   это   velocity   y   Gravity   Time   deltaTime   velocity   y   Mathf   Max   velocity   y   MaxFallSpeed   private   static   void   ApplyBraking   Vector3   prevVelocity   ref   Vector3   realVelocity   когда   Character   упираться   в   стена   он   мочь   начинать   движение   вдоль   стена   чтобы   предотвращать   это   определять   на   сколько   перпендикулярно   Character   упираться   в   стена   и   тормозить   скорость   на   этот   коэфициент   var   hPrevVelocity   GetXZ   prevVelocity   горизонтальный   скорость   var   hRealVelocity   GetXZ   realVelocity   if   hPrevVelocity   Vector3   zero   float   braking   Vector3   Dot   hRealVelocity   hPrevVelocity   hPrevVelocity   sqrMagnitude   1   вектор   одинаковый   0   вектор   разный   braking   Mathf   Clamp01   braking   realVelocity   x   braking   realVelocity   z   braking   private   Vector3   GetDesiredVelocity   float   speed   GetSpeed   inputAcceleration   speed   GetDirectionSpeedFactor   transform   forward   inputMoveDirection   if   isGrounded   speed   GetSlopeSpeedFactor   controller   velocity   return   inputMoveDirection   speed   private   static   float   GetDirectionSpeedFactor   Vector3   characterDirection   Vector3   moveDirection   если   игрок   идти   зад   или   бок   то   скорость   должный   быть   мало   float   dir   Vector3   Dot   characterDirection   moveDirection   normalized   1   идти   вперед   0   бок   1   зад   dir   Mathf   InverseLerp   1   1   dir   from   1   1   to   0   1   return   Mathf   Lerp   0   8f   1   dir   to   0   8   1   backward   sideways   forward   private   static   float   GetSlopeSpeedFactor   Vector3   velocity   уменьшать   скорость   когда   игрок   идти   вверх   по   склон   velocity   сам   принимать   направление   склон   в   результат   вызов   Move   float   slopeAngle   Mathf   Asin   velocity   normalized   y   Mathf   Rad2Deg   0   двигаться   горизонтально   float   t   Mathf   InverseLerp   0   90   slopeAngle   0   90   to   0   1   return   1   t   private   Vector3   GetDesiredSlidingVelocity   Vector3   slopeDir   GetXZ   groundNormal   normalized   Vector3   sideDir   new   Vector3   slopeDir   z   0   slopeDir   x   float   slopeDot   Vector3   Dot   inputMoveDirection   slopeDir   1   двигаться   вдоль   направление   спуск   0   перпендикулярно   спуск   float   sideDot   Vector3   Dot   inputMoveDirection   sideDir   1   двигаться   перпендикулярно   спуск   0   вдоль   спуск   var   desiredVelocity   slopeDir   скольжение   в   направление   спуск   desiredVelocity   slopeDir   slopeDot   SlidingSpeed   движение   в   направление   спуск   desiredVelocity   sideDir   sideDot   SlidingSideSpeed   движение   перпендикулярно   спуск   чем   крутой   склон   тем   много   скорость   float   slopeAngle   Vector3   Angle   groundNormal   Vector3   up   0   горизонтальный   поверхность   90   вертикальный   стена   float   speed   Gravity   slopeAngle   90   return   desiredVelocity   speed   private   static   Vector3   AdjustVelocityToGround   Vector3   velocity   Vector3   groundNormal   выравнивать   вектор   скорость   вдоль   земля   это   обеспечивать   хороший   соприкасаемость   игрок   с   земля   но   т   к   этот   заниматься   ApplyDownOffset   то   данный   метод   вероятно   не   обязательный   return   Vector3   ProjectOnPlane   velocity   groundNormal   normalized   velocity   magnitude   private   static   float   GetSpeed   bool   run   return   run   RunSpeed   WalkSpeed   private   static   float   GetAcceleration   bool   grounded   return   grounded   GroundAcceleration   AirAcceleration   5   CharacterMotor _ Jumping   это   последний   часть   класс   ответственный   за   прыжок   она   реализовать   фактически   один   ApplyJumping   в   который   быть   пара   особенность   игрок   мочь   регулировать   высота   прыжок   отпускать   или   зажимать   кнопка   направление   прыжок   зависеть   от   нормаль   земля   причем   можно   задавать   степерь   влияние   земля   на   обычный   поверхность   и   крутой   склон   показывать   скрывать   using   UnityEngine   using   System   Collections   partial   class   CharacterMotor   private   const   float   BaseJumpHeight   0   5f   private   const   float   ExtraJumpHeight   0   75f   private   static   readonly   float   baseJumpForce   GetJumpForce   BaseJumpHeight   как   сильно   нормаль   земля   влиять   на   направление   прыжок   0   прыжок   вертикальный   нормаль   не   влиять   1   прыжок   перпендикулярно   земля   вдоль   нормаль   private   const   float   GroundJumpImpactFactor   0   1f   private   const   float   SteepGroundJumpImpactFactor   0   5f   когда   игрок   скользить   по   крутой   спуск   internal   bool   isJumping   private   float   jumpStartTime   private   Vector3   jumpDir   private   float   startY   maxY   private   void   ApplyJumping   if   isJumping   isGrounded   stop   jump   isJumping   false   Debug   Log   maxY   startY   высота   прыжок   if   inputJump   isGrounded   start   jump   isJumping   true   jumpStartTime   Time   time   jumpDir   Vector3   Slerp   Vector3   up   groundNormal   GetGroundJumpImpactFactor   isSliding   velocity   y   0   velocity   jumpDir   baseJumpForce   startY   maxY   transform   position   y   if   isJumping   maxY   Mathf   Max   maxY   transform   position   y   if   isJumping   inputJumpHolding   extra   jump   float   jumpHoldingTime   Time   time   jumpStartTime   if   jumpHoldingTime   ExtraJumpHeight   baseJumpForce   velocity   jumpDir   Gravity   Time   deltaTime   private   static   float   GetJumpForce   float   targetJumpHeight   return   Mathf   Sqrt   2   Gravity   targetJumpHeight   private   static   float   GetGroundJumpImpactFactor   bool   sliding   return   sliding   SteepGroundJumpImpactFactor   GroundJumpImpactFactor   6   FPSInputController   чтобы   сделать   полноценный   управляемый   персонаж   мы   нужно   еще   пара   вспомогательный   класс   первый   обрабатывать   ввод   этот   класс   очень   простой   но   в   он   быть   два   особенность   персонаж   мочь   прыгнуть   если   кнопка   прыжок   быть   нажимать   в   последний   0   2   секунда   это   сделать   для   то   чтобы   игрок   мочь   не   ловить   момент   когда   персонаж   касаться   земля   а   мочь   нажимать   кнопка   чуть   рано   использовать   аналоговый   джойстик   игрок   мочь   регулировать   скорость   движение   персонаж   скорость   с   джойстик   находиться   в   промежуток   от   0   до   1   это   скорость   возводиться   в   квадрат   чтобы   игрок   мочь   хорошо   управлять   маленький   скорость   или   что   то   тип   то   т   е   если   игрок   сдвигать   джойстик   лишь   на   0   5   то   скорость   быть   0   25   а   если   джойстик   на   значение   1   то   и   быть   1   сам   я   это   не   тестировать   и   не   уверенный   удобно   ли   это   вообще   кстати   FPS   расшифровываться   по   идея   как   first   person   shooter   показывать   скрывать   using   UnityEngine   using   System   Collections   AddComponentMenu   Character   FPSInputController   RequireComponent   typeof   CharacterMotor   public   class   FPSInputController   MonoBehaviour   private   CharacterMotor   motor   private   float   jumpPressedTime   100   private   bool   prevJumping   false   void   Awake   motor   GetComponent   CharacterMotor   void   Update   if   Input   GetButtonDown   Jump   jumpPressedTime   Time   time   if   Input   GetButton   Jump   jumpPressedTime   100   if   prevJumping   motor   isJumping   jumpPressedTime   100   чтобы   предотвращать   двойной   прыжок   prevJumping   motor   isJumping   motor   inputMoveDirection   GetInputMoveDirection   motor   inputJump   Time   time   jumpPressedTime   0   2f   кнопка   быть   нажимать   в   последний   0   2   секунда   motor   inputJumpHolding   Input   GetButton   Jump   motor   inputAcceleration   Input   GetKey   KeyCode   LeftShift   private   Vector3   GetInputMoveDirection   var   h   Input   GetAxis   Horizontal   var   v   Input   GetAxis   Vertical   Vector3   direction   new   Vector3   h   0   v   if   direction   Vector3   zero   делать   input   dir   более   чувствительный   к   крайний   значение   и   менее   чувствительный   к   средний   это   позволять   легко   контролировать   медленный   скорость   при   использование   аналоговый   джойстик   float   len   direction   magnitude   len   Mathf   Min   1   len   len   len   len   direction   direction   normalized   len   return   transform   TransformDirection   direction   return   Vector3   zero   7   MouseLook   это   последний   и   простой   класс   ответственный   за   вращение   камера   точно   камера   вращаться   только   по   ось   X   а   по   ось   Y   вращаться   весь   персонаж   показывать   скрывать   using   UnityEngine   using   System   Collections   AddComponentMenu   Character   MouseLook   public   class   MouseLook   MonoBehaviour   public   enum   Axis   X   Y   XY   public   Axis   axis   Axis   XY   private   const   float   Sensitivity   5f   private   const   float   MinY   88f   MaxY   88f   private   Vector2   angles   Vector2   zero   void   OnEnable   angles   transform   localEulerAngles   void   Update   if   Cursor   visible   return   float   x   Input   GetAxis   Mouse   X   float   y   Input   GetAxis   Mouse   Y   Vector2   delta   new   Vector2   y   x   angles   delta   Sensitivity   angles   x   Mathf   Clamp   angles   x   MinY   MaxY   if   axis   Axis   Y   angles   x   transform   localEulerAngles   x   if   axis   Axis   X   angles   y   transform   localEulerAngles   y   Quaternion   targetRotation   Quaternion   Euler   angles   transform   localRotation   Quaternion   Slerp   transform   localRotation   targetRotation   40   Time   deltaTime   8   заключение   я   переписывать   этот   юнити   скрипт   практически   до   неузнаваемость   что   то   добавлять   что   то   удалять   но   то   не   менее   принципиально   ничто   не   изменяться   оригинальный   скрипт   для   Unity   4   и   5   вы   мочь   посмотреть   в   корень   репозиторий   код   надеяться   я   доводить   до   нормальный   состояние   но   как   я   сказать   принципиально   ничто   не   изменяться   то   некоторый   вещь   я   не   нравиться   также   быть   еще   много   вещь   который   можно   быть   бы   добавлять   поэтому   я   быть   стараться   обновлять   репозиторий   и   быть   рад   ваш   комментарий   и   предложение   замечать   пара   баг   когда   CharacterController   стоять   на   сфера   то   нормаль   поверхность   сфера   направлять   внутрь   сфера   из   за   этот   персонаж   не   понимать   что   он   стоять   на   земля   на   второй   видео   в   момент   3   07   видно   странный   разрешение   коллизия   который   приводить   к   то   что   CharacterController   резко   толкаться   вниз   когда   напрыгивать   на   такой   платформа   официальный   гид   по   CharacterController   http   docs   nvidia   com   gameworks   content   gameworkslibrary   physx   g   trollers   html   репозиторий   https   bitbucket   org   dddenisss   unity   character   motor   Unity   Unity3D   29   июнь   2016   обновление   26   июль   2016   комментарий   61   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   GameDev   ru   разработка   игра   2001   2019