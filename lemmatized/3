   кой   что   о   размытие   изображение   с   помощь   шейдер   график  
 статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка 

   термин   FAQ   страница   сообщество   форум   качалка   участник   пользователь   темный   тема
   публикация   проект   форум   работа   входить   программированиестатьиграфика   кой   что   о   размытие
 
   изображение   с   помощь   шейдер   автор   сергей   резник   этот   статья  
 познакомить   читатель   с   основной   техника   размытие   изображение   при   помощь   GLSL  
 шейдер 
   данный   техника   широко   применяться   в   игра   для   создание   такой
   эффект   как   засветка   bloom   глубина   резко   изображать   пространство   DOF   эфект
   движение 
   на   большой   скорость   итд   введение   двухпроходный   алгоритм   усреднение  
 соседний   пиксел   треугольный   закон   распределение   нормальный   закон   распределение   введение   по  
 суть   для 
   то   чтобы   размывать   изображение   необходимо   какой   то   образ
   усреднять   значение   цвет   каждый   пиксел   изображение   с   цвет   его   сосед
   в   предел 
   некоторый   диапазон   этот   диапазон   быть   называть   радиус  
 размытие   очевидный   решение   быть   следовать   слагать   значение   цвет   для   каждый  
 пиксел   расположенный   не 
   далеко   чем   радиус   размытие   от   текущий   по
   X   и   Y   координата   а   затем   поделить   они   на   квадрат
   два   радиус   размытие 
   плюс   единица   так   как   мы   слева  
 справа   сверху   и   снизу   выбирать   пиксел   на   расстояние   не   много  
 чем   радиус   центральный   пиксел 
   однако   давать   посчитать   сколько   же   пиксел
   мы   приходиться   получать   из   изображение   результат   работа   вот   такой   код
   int   value   0   for 
   int   y   r   y   R  
 y   for   int   x   r   x   R   x   x   быть  
 значение   равный   1   2   r 
   1   2   r   где   r
   радиус   размытие   для   радиус   размытие   10   это   получаться   441   выборка
   это   огромный   сложность   который   не 
   везде   можно   использовать   именно  
 для   упрощение   этот   сложность   и   придумывать   двухпроходной   алгоритм   размытие   суть  
 такой   алгоритм   состоять   в   то   что 
   изображение   размываться   сначала   по
   горизонталь   или   по   вертикаль   и   сохраняться   во   временный   изображение   после
   что   получать   изображение   размываться   в   другой 
   направление   в   данный  
 случай   мы   получать   сложность   1   2   R   1   2   R  
 для   радиус   размытие   10   мы   получать   42 
   выборка   на   пиксел
   а   это   почти   в   R   раз   мало   также   при   размытие
   изображение   следовать   учитывать   вес   пиксел   при   их 
   вариация   можно  
 получать   различный   результат   так   если   все   пиксел   быть   иметь   одинаковый  
 вес   мы   получать   усреднять   изображение   если   же   придавать 
   центральный   пиксел
   больше   вес   чем   крайний   то   изобажение   быть   более   сконцентрированный   для
   вариация   весы   можно   использовать   различный   закон   распределение   известный 
   из  
 математический   статистика   итак   рассматривать   основной   двухпроходной   алгоритм   размытие   для   пример  
 взять   вот   такой   исходный   картинка   двухпроходная   алгоритм   усреднение   соседний 
   пиксел
   это   наиболее   простой   алгоритм   использовать   равномерый   закон   распределение   в   этот
   случай   весь   пиксел   быть   иметь   одинаковый   вес   полагать   радиус 
  
 размытие   равный   десять   магический   число   21   являться   сумма   весь   весы  
 соседний   пиксел   конечно   же   для   радиус   размытие   равный   10   на 

   это   число   мы   нужно   быть   поделить   сумма   цветок   соседний   пиксел
   как   видно   сумма   центральный   и   соседний   пиксел   с   каждый   из
 
   сторона   в   точность   равняться   значение   2   R   1   такой  
 образ   нет   необходимость   высчитывать   этот   сумма   рассматривать   реализация   данный   алгоритм  
 на 
   шейдерный   язык   GLSL   uniform   sampler2D   source _ image   uniform   vec3
   texel _ radius   in   vec2   TexCoord   out   vec4   FragColor   void   main
   float   radius   texel _ radius 
   z   vec4   value   texture   source _
 image   TexCoord   float   totalScale   2   0   radius   1   0   float  
 x   1   0   while   x   radius 
   vec2   dudv   texel _ radius
   xy   x   value   texture   source _ image   TexCoord   dudv   texture   source
 _ image   TexCoord   dudv   x   1   0   FragColor   value   totalScale 
  
 входной   параметр   являться   сэмплер   для   исходный   изображение   и   трехкомпонентный   вектор  
 который   содержать   в   себя   шаг   размытие   и   радиус   шаг   размытие 

   в   данный   случай   быть   1   0   ширина   изображение   0   0
   для   горизонтальный   размытие   и   0   0   1   0   высота   изображение
 
   для   вертикальный   в   дальнейший   реализация   быть   использовать   тот   же  
 терминология   после   два   проход   размытый   изображение   быть   выглядеть   вот   так  
 треугольный 
   закон   распределение   следующий   по   сложность   алгоритм   являться   алгоритм   использовать
   закон   распределение   симпсон   в   данный   закон   распределение   вес   соседний   точка
   на 
   текстура   с   увеличение   расстояние   до   центральный   точка   убывать  
 линейно   как   и   рано   полагать   радиус   размытие   равный   десять   так  
 же   как 
   и   рано   мы   необходимо   быть   находить   сумма   весь
   весы   соседний   пиксел   текстура   и   поделить   финальный   результат   на   она
   для   это 
   полагать   вес   центральный   пискель   равный   r   1  
 в   такой   случай   вес   соседний   пиксел   быть   изменяться   в   соответствие  
 с   функция   f 
   x   на   картинка   низкий   вес   крайний   точка
   в   этот   случай   быть   равный   единица   сумма   весы   весь   пиксел
   в   данный   случай 
   быть   выражаться   формула   R   1   2  
 реализация   данный   алгоритм   на   GLSL   приводить   ниже   uniform   sampler2D   source _
 image   uniform   vec3   texel _ radius   in 
   vec2   TexCoord   out   vec4
   FragColor   void   main   float   r   texel _ radius   z   float   totalScale
   1   0   r   vec4   value   texture   source _ image 
   TexCoord  
 totalScale   float   x   1   0   while   x   r   vec2   dudv  
 texel _ radius   xy   x   float   scale   1   0   r   x 

   value   scale   texture   source _ image   TexCoord   dudv   texture   source _ image
   TexCoord   dudv   x   1   0   FragColor   value   totalScale   totalScale   результат
   обработка   изображение 
   этот   алгоритм   быть   выглядеть   вот   так   нормальный  
 закон   распределение   следующий   алгоритм   размытие   который   мы   рассматривать   быть   так  
 называть   размытие   по 
   гаусс   именно   оно   использоваться   в   фотошоп   суть
   он   заключаться   в   использование   нормальный   закон   распределение   обычно   нормальный   закон
   распределение   включать   в 
   себя   два   параметр   математический   ожидание   и  
 дисперсия   для   наш   случай   быть   считать   математический   ожидание   равный   ноль  
 в   этот   случай   закон 
   распределение   включать   только   один   параметр   дисперсия
   такой   упрощенный   закон   распределение   показывать   на   рисунок   ниже   функция   f
   x   так   как   в 
   данный   закон   использоваться   дисперсия   величина  
 а   не   радиус   то   воспользоваться   правило   три   сигма   оно   гласить  
 о   то   что   в   диапазон 
   3σ   3σ   попадать   99   73
   весь   величина   из   распределение   полагать   радиус   равный   десять   в   этот
   случай   σ   быть   равный   10 
   3   3   дробный   часть  
 не   учитывать   так   как   мы   делать   шаг   на   целый   число  
 пиксел   в   сторона   от   центральный   следовать 
   замечать   что   в   данный
   алгоритм   сумма   весы   весь   соседний   пиксел   быть   близкий   к   единица
   то   быть   мы   не   приходиться   делить 
   или   умножать   получать  
 результат   на   какой   либо   число   но   также   не   следовать   забывать  
 что   в   выбирать   предел   попадать   не   100 
   величина   а   только
   99   73   это   означать   что   сумма   быть   маленький   единица   и
   финальный   изображение   быть   затемняться   чтобы   устранять   этот 
   недостаток   увеличивать  
 изменять   вес   центральный   точка   на   1   0   сумма   весы   соседний  
 и   в   итог   получать   сумма   вес   весь   пиксел 
   равный   единица
   рассматривать   код   данный   алгоритм   на   GLSL   uniform   sampler2D   source _ image
   uniform   vec3   texel _ radius   in   vec2   TexCoord   out   vec4   FragColor
 
   define   M _ PI   3   1415926535897932384626433832795   float   gauss   float   x  
 float   sigma   float   x _ sqr   x   x   float   sigma _ sqr  
 sigma   sigma   float   sqrt _ value 
   1   0   sqrt   2   0
   M _ PI   sigma _ sqr   float   exp _ value   exp   x _ sqr
   2   0   sigma _ sqr   return   sqrt _ value   exp _ value   void
   main   float 
   r   texel _ radius   z   float   sigma   r  
 3   0   float   sum   0   0   vec4   value   vec4   0  
 0   float   x   1 
   0   while   x   r   float   currentScale
   gauss   x   sigma   sum   2   0   currentScale   vec2   dudv   texel
 _ radius   xy   x   value   currentScale 
   texture   source _ image   TexCoord  
 dudv   texture   source _ image   TexCoord   dudv   x   1   0   value  
 texture   source _ image   TexCoord   1   0   sum   FragColor   value 
   как
   видеть   здесь   выполняться   очень   много   лишний   инструкция   каждый   раз   пересчитываться
   константа   и   т   д   давать   немного   оптимизировать   этот   код 
  
 1   вынести   сигма   из   под   корень   и   вычислять   константа   1  
 0   sqrt   2   0   PI   2   так   как   сигма   у 

   мы   не   меняться   следовательно   не   меняться   весь   выражение   перед   экспонента
   а   так   же   множитель   при   x   в   выражение   внутри   экспонент
 
   следовательно   все   это   можно   посчитать   один   раз   и   вынести  
 за   скобка   3   избавляться   от   лишний   операция   деление   на   три  
 подставлять 
   тройка   в   выражение   после   проделывать   операция   получать   вот   такой
   вот   шейдер   uniform   sampler2D   source _ image   uniform   vec3   texel _ radius
   in   vec2   TexCoord 
   out   vec4   FragColor   define   INV _ SQRT _
 2PI _ X3   1   1968268412042980338198381798031   void   main   float   r   texel _ radius  
 z   float   exp _ value   4   5   r   r   float 
   sqrt
 _ value   INV _ SQRT _ 2PI _ X3   r   float   sum   0   0
   vec4   value   vec4   0   0   float   x   1   0   while
   x   r   float 
   currentScale   exp   exp _ value   x   x  
 sum   currentScale   vec2   dudv   texel _ radius   xy   x   value   currentScale  
 texture   source _ image   TexCoord   dudv   texture   source _ image 
   TexCoord   dudv
   x   1   0   float   correction   1   0   sqrt _ value   2
   0   sum   value   texture   source _ image   TexCoord   correction   FragColor   value
 
   sqrt _ value   такой   оптимизация   мы   не   только   уменьшать   размер  
 шейдер   но   и   увеличивать   скорость   примерно   в   1   15   раз  
 тестироваться   при 
   радиус   размытие   50   это   соглашаться   немного   но   полезно
   результат   размытие   по   гаусс   быть   выглядеть   следующий   образ   полагать   радиус
   размытие   равный 
   30   и   сравнивать   результат   с   размытие   в  
 фотошоп   первый   изображение   размытый   с   радиус   30   пиксел   второй   разница  
 между   приводить   алгоритм 
   и   фильтр   фотошоп   blur   postprocess   28   сентябрь
   2013   комментарий   43   убирать   реклама   контакт   сообщество   участник   каталог   сайт
   категория   архив   новость 
   GameDev   ru   разработка   игра   2001   2019 
 кой что о размытие изображение с помощь шейдер график статья программирование игра новость статья код арт дизайн индустрия подсказка
 термин FAQ страница сообщество форум качалка участник пользователь темный тема публикация проект форум работа входить программированиестатьиграфика кой что о размытие
 изображение с помощь шейдер автор сергей резник этот статья познакомить читатель с основной техника размытие изображение при помощь GLSL шейдер
 данный техника широко применяться в игра для создание такой эффект как засветка bloom глубина резко изображать пространство DOF эфект движение
 на большой скорость итд введение двухпроходный алгоритм усреднение соседний пиксел треугольный закон распределение нормальный закон распределение введение по суть для
 то чтобы размывать изображение необходимо какой то образ усреднять значение цвет каждый пиксел изображение с цвет его сосед в предел
 некоторый диапазон этот диапазон быть называть радиус размытие очевидный решение быть следовать слагать значение цвет для каждый пиксел расположенный не
 далеко чем радиус размытие от текущий по X и Y координата а затем поделить они на квадрат два радиус размытие
 плюс единица так как мы слева справа сверху и снизу выбирать пиксел на расстояние не много чем радиус центральный пиксел
 однако давать посчитать сколько же пиксел мы приходиться получать из изображение результат работа вот такой код int value 0 for
 int y r y R y for int x r x R x x быть значение равный 1 2 r
 1 2 r где r радиус размытие для радиус размытие 10 это получаться 441 выборка это огромный сложность который не
 везде можно использовать именно для упрощение этот сложность и придумывать двухпроходной алгоритм размытие суть такой алгоритм состоять в то что
 изображение размываться сначала по горизонталь или по вертикаль и сохраняться во временный изображение после что получать изображение размываться в другой
 направление в данный случай мы получать сложность 1 2 R 1 2 R для радиус размытие 10 мы получать 42
 выборка на пиксел а это почти в R раз мало также при размытие изображение следовать учитывать вес пиксел при их
 вариация можно получать различный результат так если все пиксел быть иметь одинаковый вес мы получать усреднять изображение если же придавать
 центральный пиксел больше вес чем крайний то изобажение быть более сконцентрированный для вариация весы можно использовать различный закон распределение известный
 из математический статистика итак рассматривать основной двухпроходной алгоритм размытие для пример взять вот такой исходный картинка двухпроходная алгоритм усреднение соседний
 пиксел это наиболее простой алгоритм использовать равномерый закон распределение в этот случай весь пиксел быть иметь одинаковый вес полагать радиус
 размытие равный десять магический число 21 являться сумма весь весы соседний пиксел конечно же для радиус размытие равный 10 на
 это число мы нужно быть поделить сумма цветок соседний пиксел как видно сумма центральный и соседний пиксел с каждый из
 сторона в точность равняться значение 2 R 1 такой образ нет необходимость высчитывать этот сумма рассматривать реализация данный алгоритм на
 шейдерный язык GLSL uniform sampler2D source _ image uniform vec3 texel _ radius in vec2 TexCoord out vec4 FragColor void
 main float radius texel _ radius z vec4 value texture source _ image TexCoord float totalScale 2 0 radius 1
 0 float x 1 0 while x radius vec2 dudv texel _ radius xy x value texture source _ image
 TexCoord dudv texture source _ image TexCoord dudv x 1 0 FragColor value totalScale входной параметр являться сэмплер для исходный
 изображение и трехкомпонентный вектор который содержать в себя шаг размытие и радиус шаг размытие в данный случай быть 1 0
 ширина изображение 0 0 для горизонтальный размытие и 0 0 1 0 высота изображение для вертикальный в дальнейший реализация быть
 использовать тот же терминология после два проход размытый изображение быть выглядеть вот так треугольный закон распределение следующий по сложность алгоритм
 являться алгоритм использовать закон распределение симпсон в данный закон распределение вес соседний точка на текстура с увеличение расстояние до центральный
 точка убывать линейно как и рано полагать радиус размытие равный десять так же как и рано мы необходимо быть находить
 сумма весь весы соседний пиксел текстура и поделить финальный результат на она для это полагать вес центральный пискель равный r
 1 в такой случай вес соседний пиксел быть изменяться в соответствие с функция f x на картинка низкий вес крайний
 точка в этот случай быть равный единица сумма весы весь пиксел в данный случай быть выражаться формула R 1 2
 реализация данный алгоритм на GLSL приводить ниже uniform sampler2D source _ image uniform vec3 texel _ radius in vec2 TexCoord
 out vec4 FragColor void main float r texel _ radius z float totalScale 1 0 r vec4 value texture source
 _ image TexCoord totalScale float x 1 0 while x r vec2 dudv texel _ radius xy x float scale
 1 0 r x value scale texture source _ image TexCoord dudv texture source _ image TexCoord dudv x 1
 0 FragColor value totalScale totalScale результат обработка изображение этот алгоритм быть выглядеть вот так нормальный закон распределение следующий алгоритм размытие
 который мы рассматривать быть так называть размытие по гаусс именно оно использоваться в фотошоп суть он заключаться в использование нормальный
 закон распределение обычно нормальный закон распределение включать в себя два параметр математический ожидание и дисперсия для наш случай быть считать
 математический ожидание равный ноль в этот случай закон распределение включать только один параметр дисперсия такой упрощенный закон распределение показывать на
 рисунок ниже функция f x так как в данный закон использоваться дисперсия величина а не радиус то воспользоваться правило три
 сигма оно гласить о то что в диапазон 3σ 3σ попадать 99 73 весь величина из распределение полагать радиус равный
 десять в этот случай σ быть равный 10 3 3 дробный часть не учитывать так как мы делать шаг на
 целый число пиксел в сторона от центральный следовать замечать что в данный алгоритм сумма весы весь соседний пиксел быть близкий
 к единица то быть мы не приходиться делить или умножать получать результат на какой либо число но также не следовать
 забывать что в выбирать предел попадать не 100 величина а только 99 73 это означать что сумма быть маленький единица
 и финальный изображение быть затемняться чтобы устранять этот недостаток увеличивать изменять вес центральный точка на 1 0 сумма весы соседний
 и в итог получать сумма вес весь пиксел равный единица рассматривать код данный алгоритм на GLSL uniform sampler2D source _
 image uniform vec3 texel _ radius in vec2 TexCoord out vec4 FragColor define M _ PI 3 1415926535897932384626433832795 float gauss
 float x float sigma float x _ sqr x x float sigma _ sqr sigma sigma float sqrt _ value
 1 0 sqrt 2 0 M _ PI sigma _ sqr float exp _ value exp x _ sqr 2
 0 sigma _ sqr return sqrt _ value exp _ value void main float r texel _ radius z float
 sigma r 3 0 float sum 0 0 vec4 value vec4 0 0 float x 1 0 while x r
 float currentScale gauss x sigma sum 2 0 currentScale vec2 dudv texel _ radius xy x value currentScale texture source
 _ image TexCoord dudv texture source _ image TexCoord dudv x 1 0 value texture source _ image TexCoord 1
 0 sum FragColor value как видеть здесь выполняться очень много лишний инструкция каждый раз пересчитываться константа и т д давать
 немного оптимизировать этот код 1 вынести сигма из под корень и вычислять константа 1 0 sqrt 2 0 PI 2
 так как сигма у мы не меняться следовательно не меняться весь выражение перед экспонента а так же множитель при x
 в выражение внутри экспонент следовательно все это можно посчитать один раз и вынести за скобка 3 избавляться от лишний операция
 деление на три подставлять тройка в выражение после проделывать операция получать вот такой вот шейдер uniform sampler2D source _ image
 uniform vec3 texel _ radius in vec2 TexCoord out vec4 FragColor define INV _ SQRT _ 2PI _ X3 1
 1968268412042980338198381798031 void main float r texel _ radius z float exp _ value 4 5 r r float sqrt _
 value INV _ SQRT _ 2PI _ X3 r float sum 0 0 vec4 value vec4 0 0 float x
 1 0 while x r float currentScale exp exp _ value x x sum currentScale vec2 dudv texel _ radius
 xy x value currentScale texture source _ image TexCoord dudv texture source _ image TexCoord dudv x 1 0 float
 correction 1 0 sqrt _ value 2 0 sum value texture source _ image TexCoord correction FragColor value sqrt _
 value такой оптимизация мы не только уменьшать размер шейдер но и увеличивать скорость примерно в 1 15 раз тестироваться при
 радиус размытие 50 это соглашаться немного но полезно результат размытие по гаусс быть выглядеть следующий образ полагать радиус размытие равный
 30 и сравнивать результат с размытие в фотошоп первый изображение размытый с радиус 30 пиксел второй разница между приводить алгоритм
 и фильтр фотошоп blur postprocess 28 сентябрь 2013 комментарий 43 убирать реклама контакт сообщество участник каталог сайт категория архив новость
 GameDev ru разработка игра 2001 2019 кой что о размытие изображение с помощь шейдер график статья программирование игра новость статья код арт дизайн индустрия подсказка
 термин FAQ страница сообщество форум качалка участник пользователь темный тема публикация проект форум работа входить программированиестатьиграфика кой что о размытие
 изображение с помощь шейдер автор сергей резник этот статья познакомить читатель с основной техника размытие изображение при помощь GLSL шейдер
 данный техника широко применяться в игра для создание такой эффект как засветка bloom глубина резко изображать пространство DOF эфект движение
 на большой скорость итд введение двухпроходный алгоритм усреднение соседний пиксел треугольный закон распределение нормальный закон распределение введение по суть для
 то чтобы размывать изображение необходимо какой то образ усреднять значение цвет каждый пиксел изображение с цвет его сосед в предел
 некоторый диапазон этот диапазон быть называть радиус размытие очевидный решение быть следовать слагать значение цвет для каждый пиксел расположенный не
 далеко чем радиус размытие от текущий по X и Y координата а затем поделить они на квадрат два радиус размытие
 плюс единица так как мы слева справа сверху и снизу выбирать пиксел на расстояние не много чем радиус центральный пиксел
 однако давать посчитать сколько же пиксел мы приходиться получать из изображение результат работа вот такой код int value 0 for
 int y r y R y for int x r x R x x быть значение равный 1 2 r
 1 2 r где r радиус размытие для радиус размытие 10 это получаться 441 выборка это огромный сложность который не
 везде можно использовать именно для упрощение этот сложность и придумывать двухпроходной алгоритм размытие суть такой алгоритм состоять в то что
 изображение размываться сначала по горизонталь или по вертикаль и сохраняться во временный изображение после что получать изображение размываться в другой
 направление в данный случай мы получать сложность 1 2 R 1 2 R для радиус размытие 10 мы получать 42
 выборка на пиксел а это почти в R раз мало также при размытие изображение следовать учитывать вес пиксел при их
 вариация можно получать различный результат так если все пиксел быть иметь одинаковый вес мы получать усреднять изображение если же придавать
 центральный пиксел больше вес чем крайний то изобажение быть более сконцентрированный для вариация весы можно использовать различный закон распределение известный
 из математический статистика итак рассматривать основной двухпроходной алгоритм размытие для пример взять вот такой исходный картинка двухпроходная алгоритм усреднение соседний
 пиксел это наиболее простой алгоритм использовать равномерый закон распределение в этот случай весь пиксел быть иметь одинаковый вес полагать радиус
 размытие равный десять магический число 21 являться сумма весь весы соседний пиксел конечно же для радиус размытие равный 10 на
 это число мы нужно быть поделить сумма цветок соседний пиксел как видно сумма центральный и соседний пиксел с каждый из
 сторона в точность равняться значение 2 R 1 такой образ нет необходимость высчитывать этот сумма рассматривать реализация данный алгоритм на
 шейдерный язык GLSL uniform sampler2D source _ image uniform vec3 texel _ radius in vec2 TexCoord out vec4 FragColor void
 main float radius texel _ radius z vec4 value texture source _ image TexCoord float totalScale 2 0 radius 1
 0 float x 1 0 while x radius vec2 dudv texel _ radius xy x value texture source _ image
 TexCoord dudv texture source _ image TexCoord dudv x 1 0 FragColor value totalScale входной параметр являться сэмплер для исходный
 изображение и трехкомпонентный вектор который содержать в себя шаг размытие и радиус шаг размытие в данный случай быть 1 0
 ширина изображение 0 0 для горизонтальный размытие и 0 0 1 0 высота изображение для вертикальный в дальнейший реализация быть
 использовать тот же терминология после два проход размытый изображение быть выглядеть вот так треугольный закон распределение следующий по сложность алгоритм
 являться алгоритм использовать закон распределение симпсон в данный закон распределение вес соседний точка на текстура с увеличение расстояние до центральный
 точка убывать линейно как и рано полагать радиус размытие равный десять так же как и рано мы необходимо быть находить
 сумма весь весы соседний пиксел текстура и поделить финальный результат на она для это полагать вес центральный пискель равный r
 1 в такой случай вес соседний пиксел быть изменяться в соответствие с функция f x на картинка низкий вес крайний
 точка в этот случай быть равный единица сумма весы весь пиксел в данный случай быть выражаться формула R 1 2
 реализация данный алгоритм на GLSL приводить ниже uniform sampler2D source _ image uniform vec3 texel _ radius in vec2 TexCoord
 out vec4 FragColor void main float r texel _ radius z float totalScale 1 0 r vec4 value texture source
 _ image TexCoord totalScale float x 1 0 while x r vec2 dudv texel _ radius xy x float scale
 1 0 r x value scale texture source _ image TexCoord dudv texture source _ image TexCoord dudv x 1
 0 FragColor value totalScale totalScale результат обработка изображение этот алгоритм быть выглядеть вот так нормальный закон распределение следующий алгоритм размытие
 который мы рассматривать быть так называть размытие по гаусс именно оно использоваться в фотошоп суть он заключаться в использование нормальный
 закон распределение обычно нормальный закон распределение включать в себя два параметр математический ожидание и дисперсия для наш случай быть считать
 математический ожидание равный ноль в этот случай закон распределение включать только один параметр дисперсия такой упрощенный закон распределение показывать на
 рисунок ниже функция f x так как в данный закон использоваться дисперсия величина а не радиус то воспользоваться правило три
 сигма оно гласить о то что в диапазон 3σ 3σ попадать 99 73 весь величина из распределение полагать радиус равный
 десять в этот случай σ быть равный 10 3 3 дробный часть не учитывать так как мы делать шаг на
 целый число пиксел в сторона от центральный следовать замечать что в данный алгоритм сумма весы весь соседний пиксел быть близкий
 к единица то быть мы не приходиться делить или умножать получать результат на какой либо число но также не следовать
 забывать что в выбирать предел попадать не 100 величина а только 99 73 это означать что сумма быть маленький единица
 и финальный изображение быть затемняться чтобы устранять этот недостаток увеличивать изменять вес центральный точка на 1 0 сумма весы соседний
 и в итог получать сумма вес весь пиксел равный единица рассматривать код данный алгоритм на GLSL uniform sampler2D source _
 image uniform vec3 texel _ radius in vec2 TexCoord out vec4 FragColor define M _ PI 3 1415926535897932384626433832795 float gauss
 float x float sigma float x _ sqr x x float sigma _ sqr sigma sigma float sqrt _ value
 1 0 sqrt 2 0 M _ PI sigma _ sqr float exp _ value exp x _ sqr 2
 0 sigma _ sqr return sqrt _ value exp _ value void main float r texel _ radius z float
 sigma r 3 0 float sum 0 0 vec4 value vec4 0 0 float x 1 0 while x r
 float currentScale gauss x sigma sum 2 0 currentScale vec2 dudv texel _ radius xy x value currentScale texture source
 _ image TexCoord dudv texture source _ image TexCoord dudv x 1 0 value texture source _ image TexCoord 1
 0 sum FragColor value как видеть здесь выполняться очень много лишний инструкция каждый раз пересчитываться константа и т д давать
 немного оптимизировать этот код 1 вынести сигма из под корень и вычислять константа 1 0 sqrt 2 0 PI 2
 так как сигма у мы не меняться следовательно не меняться весь выражение перед экспонента а так же множитель при x
 в выражение внутри экспонент следовательно все это можно посчитать один раз и вынести за скобка 3 избавляться от лишний операция
 деление на три подставлять тройка в выражение после проделывать операция получать вот такой вот шейдер uniform sampler2D source _ image
 uniform vec3 texel _ radius in vec2 TexCoord out vec4 FragColor define INV _ SQRT _ 2PI _ X3 1
 1968268412042980338198381798031 void main float r texel _ radius z float exp _ value 4 5 r r float sqrt _
 value INV _ SQRT _ 2PI _ X3 r float sum 0 0 vec4 value vec4 0 0 float x
 1 0 while x r float currentScale exp exp _ value x x sum currentScale vec2 dudv texel _ radius
 xy x value currentScale texture source _ image TexCoord dudv texture source _ image TexCoord dudv x 1 0 float
 correction 1 0 sqrt _ value 2 0 sum value texture source _ image TexCoord correction FragColor value sqrt _
 value такой оптимизация мы не только уменьшать размер шейдер но и увеличивать скорость примерно в 1 15 раз тестироваться при
 радиус размытие 50 это соглашаться немного но полезно результат размытие по гаусс быть выглядеть следующий образ полагать радиус размытие равный
 30 и сравнивать результат с размытие в фотошоп первый изображение размытый с радиус 30 пиксел второй разница между приводить алгоритм
 и фильтр фотошоп blur postprocess 28 сентябрь 2013 комментарий 43 убирать реклама контакт сообщество участник каталог сайт категория архив новость
 GameDev ru разработка игра 2001 2019   кой   что   о   размытие   изображение   с   помощь   шейдер   график  
 статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка  
 термин   FAQ   страница   сообщество   форум   качалка   участник   пользователь   темный   тема  
 публикация   проект   форум   работа   входить   программированиестатьиграфика   кой   что   о   размытие  
 изображение   с   помощь   шейдер   автор   сергей   резник   этот   статья   познакомить  
 читатель   с   основной   техника   размытие   изображение   при   помощь   GLSL   шейдер  
 данный   техника   широко   применяться   в   игра   для   создание   такой   эффект  
 как   засветка   bloom   глубина   резко   изображать   пространство   DOF   эфект   движение  
 на   большой   скорость   итд   введение   двухпроходный   алгоритм   усреднение   соседний   пиксел  
 треугольный   закон   распределение   нормальный   закон   распределение   введение   по   суть   для  
 то   чтобы   размывать   изображение   необходимо   какой   то   образ   усреднять   значение  
 цвет   каждый   пиксел   изображение   с   цвет   его   сосед   в   предел  
 некоторый   диапазон   этот   диапазон   быть   называть   радиус   размытие   очевидный   решение  
 быть   следовать   слагать   значение   цвет   для   каждый   пиксел   расположенный   не  
 далеко   чем   радиус   размытие   от   текущий   по   X   и   Y  
 координата   а   затем   поделить   они   на   квадрат   два   радиус   размытие  
 плюс   единица   так   как   мы   слева   справа   сверху   и   снизу  
 выбирать   пиксел   на   расстояние   не   много   чем   радиус   центральный   пиксел  
 однако   давать   посчитать   сколько   же   пиксел   мы   приходиться   получать   из  
 изображение   результат   работа   вот   такой   код   int   value   0   for  
 int   y   r   y   R   y   for   int   x   r  
 x   R   x   x   быть   значение   равный   1   2   r  
 1   2   r   где   r   радиус   размытие   для   радиус   размытие  
 10   это   получаться   441   выборка   это   огромный   сложность   который   не  
 везде   можно   использовать   именно   для   упрощение   этот   сложность   и   придумывать  
 двухпроходной   алгоритм   размытие   суть   такой   алгоритм   состоять   в   то   что  
 изображение   размываться   сначала   по   горизонталь   или   по   вертикаль   и   сохраняться  
 во   временный   изображение   после   что   получать   изображение   размываться   в   другой  
 направление   в   данный   случай   мы   получать   сложность   1   2   R  
 1   2   R   для   радиус   размытие   10   мы   получать   42  
 выборка   на   пиксел   а   это   почти   в   R   раз   мало  
 также   при   размытие   изображение   следовать   учитывать   вес   пиксел   при   их  
 вариация   можно   получать   различный   результат   так   если   все   пиксел   быть  
 иметь   одинаковый   вес   мы   получать   усреднять   изображение   если   же   придавать  
 центральный   пиксел   больше   вес   чем   крайний   то   изобажение   быть   более  
 сконцентрированный   для   вариация   весы   можно   использовать   различный   закон   распределение   известный  
 из   математический   статистика   итак   рассматривать   основной   двухпроходной   алгоритм   размытие   для  
 пример   взять   вот   такой   исходный   картинка   двухпроходная   алгоритм   усреднение   соседний  
 пиксел   это   наиболее   простой   алгоритм   использовать   равномерый   закон   распределение   в  
 этот   случай   весь   пиксел   быть   иметь   одинаковый   вес   полагать   радиус  
 размытие   равный   десять   магический   число   21   являться   сумма   весь   весы  
 соседний   пиксел   конечно   же   для   радиус   размытие   равный   10   на  
 это   число   мы   нужно   быть   поделить   сумма   цветок   соседний   пиксел  
 как   видно   сумма   центральный   и   соседний   пиксел   с   каждый   из  
 сторона   в   точность   равняться   значение   2   R   1   такой   образ  
 нет   необходимость   высчитывать   этот   сумма   рассматривать   реализация   данный   алгоритм   на  
 шейдерный   язык   GLSL   uniform   sampler2D   source _ image   uniform   vec3   texel _
 radius   in   vec2   TexCoord   out   vec4   FragColor   void   main   float  
 radius   texel _ radius   z   vec4   value   texture   source _ image   TexCoord  
 float   totalScale   2   0   radius   1   0   float   x   1  
 0   while   x   radius   vec2   dudv   texel _ radius   xy   x  
 value   texture   source _ image   TexCoord   dudv   texture   source _ image   TexCoord  
 dudv   x   1   0   FragColor   value   totalScale   входной   параметр   являться  
 сэмплер   для   исходный   изображение   и   трехкомпонентный   вектор   который   содержать   в  
 себя   шаг   размытие   и   радиус   шаг   размытие   в   данный   случай  
 быть   1   0   ширина   изображение   0   0   для   горизонтальный   размытие  
 и   0   0   1   0   высота   изображение   для   вертикальный   в  
 дальнейший   реализация   быть   использовать   тот   же   терминология   после   два   проход  
 размытый   изображение   быть   выглядеть   вот   так   треугольный   закон   распределение   следующий  
 по   сложность   алгоритм   являться   алгоритм   использовать   закон   распределение   симпсон   в  
 данный   закон   распределение   вес   соседний   точка   на   текстура   с   увеличение  
 расстояние   до   центральный   точка   убывать   линейно   как   и   рано   полагать  
 радиус   размытие   равный   десять   так   же   как   и   рано   мы  
 необходимо   быть   находить   сумма   весь   весы   соседний   пиксел   текстура   и  
 поделить   финальный   результат   на   она   для   это   полагать   вес   центральный  
 пискель   равный   r   1   в   такой   случай   вес   соседний   пиксел  
 быть   изменяться   в   соответствие   с   функция   f   x   на   картинка  
 низкий   вес   крайний   точка   в   этот   случай   быть   равный   единица  
 сумма   весы   весь   пиксел   в   данный   случай   быть   выражаться   формула  
 R   1   2   реализация   данный   алгоритм   на   GLSL   приводить   ниже  
 uniform   sampler2D   source _ image   uniform   vec3   texel _ radius   in   vec2  
 TexCoord   out   vec4   FragColor   void   main   float   r   texel _ radius  
 z   float   totalScale   1   0   r   vec4   value   texture   source _
 image   TexCoord   totalScale   float   x   1   0   while   x   r  
 vec2   dudv   texel _ radius   xy   x   float   scale   1   0  
 r   x   value   scale   texture   source _ image   TexCoord   dudv   texture  
 source _ image   TexCoord   dudv   x   1   0   FragColor   value   totalScale  
 totalScale   результат   обработка   изображение   этот   алгоритм   быть   выглядеть   вот   так  
 нормальный   закон   распределение   следующий   алгоритм   размытие   который   мы   рассматривать   быть  
 так   называть   размытие   по   гаусс   именно   оно   использоваться   в   фотошоп  
 суть   он   заключаться   в   использование   нормальный   закон   распределение   обычно   нормальный  
 закон   распределение   включать   в   себя   два   параметр   математический   ожидание   и  
 дисперсия   для   наш   случай   быть   считать   математический   ожидание   равный   ноль  
 в   этот   случай   закон   распределение   включать   только   один   параметр   дисперсия  
 такой   упрощенный   закон   распределение   показывать   на   рисунок   ниже   функция   f  
 x   так   как   в   данный   закон   использоваться   дисперсия   величина   а  
 не   радиус   то   воспользоваться   правило   три   сигма   оно   гласить   о  
 то   что   в   диапазон   3σ   3σ   попадать   99   73   весь  
 величина   из   распределение   полагать   радиус   равный   десять   в   этот   случай  
 σ   быть   равный   10   3   3   дробный   часть   не   учитывать  
 так   как   мы   делать   шаг   на   целый   число   пиксел   в  
 сторона   от   центральный   следовать   замечать   что   в   данный   алгоритм   сумма  
 весы   весь   соседний   пиксел   быть   близкий   к   единица   то   быть  
 мы   не   приходиться   делить   или   умножать   получать   результат   на   какой  
 либо   число   но   также   не   следовать   забывать   что   в   выбирать  
 предел   попадать   не   100   величина   а   только   99   73   это  
 означать   что   сумма   быть   маленький   единица   и   финальный   изображение   быть  
 затемняться   чтобы   устранять   этот   недостаток   увеличивать   изменять   вес   центральный   точка  
 на   1   0   сумма   весы   соседний   и   в   итог   получать  
 сумма   вес   весь   пиксел   равный   единица   рассматривать   код   данный   алгоритм  
 на   GLSL   uniform   sampler2D   source _ image   uniform   vec3   texel _ radius  
 in   vec2   TexCoord   out   vec4   FragColor   define   M _ PI   3  
 1415926535897932384626433832795   float   gauss   float   x   float   sigma   float   x _ sqr  
 x   x   float   sigma _ sqr   sigma   sigma   float   sqrt _ value  
 1   0   sqrt   2   0   M _ PI   sigma _ sqr   float  
 exp _ value   exp   x _ sqr   2   0   sigma _ sqr   return  
 sqrt _ value   exp _ value   void   main   float   r   texel _ radius  
 z   float   sigma   r   3   0   float   sum   0   0  
 vec4   value   vec4   0   0   float   x   1   0   while  
 x   r   float   currentScale   gauss   x   sigma   sum   2   0  
 currentScale   vec2   dudv   texel _ radius   xy   x   value   currentScale   texture  
 source _ image   TexCoord   dudv   texture   source _ image   TexCoord   dudv   x  
 1   0   value   texture   source _ image   TexCoord   1   0   sum  
 FragColor   value   как   видеть   здесь   выполняться   очень   много   лишний   инструкция  
 каждый   раз   пересчитываться   константа   и   т   д   давать   немного   оптимизировать  
 этот   код   1   вынести   сигма   из   под   корень   и   вычислять  
 константа   1   0   sqrt   2   0   PI   2   так   как  
 сигма   у   мы   не   меняться   следовательно   не   меняться   весь   выражение  
 перед   экспонента   а   так   же   множитель   при   x   в   выражение  
 внутри   экспонент   следовательно   все   это   можно   посчитать   один   раз   и  
 вынести   за   скобка   3   избавляться   от   лишний   операция   деление   на  
 три   подставлять   тройка   в   выражение   после   проделывать   операция   получать   вот  
 такой   вот   шейдер   uniform   sampler2D   source _ image   uniform   vec3   texel _
 radius   in   vec2   TexCoord   out   vec4   FragColor   define   INV _ SQRT _
 2PI _ X3   1   1968268412042980338198381798031   void   main   float   r   texel _ radius  
 z   float   exp _ value   4   5   r   r   float   sqrt _
 value   INV _ SQRT _ 2PI _ X3   r   float   sum   0   0  
 vec4   value   vec4   0   0   float   x   1   0   while  
 x   r   float   currentScale   exp   exp _ value   x   x   sum  
 currentScale   vec2   dudv   texel _ radius   xy   x   value   currentScale   texture  
 source _ image   TexCoord   dudv   texture   source _ image   TexCoord   dudv   x  
 1   0   float   correction   1   0   sqrt _ value   2   0  
 sum   value   texture   source _ image   TexCoord   correction   FragColor   value   sqrt _
 value   такой   оптимизация   мы   не   только   уменьшать   размер   шейдер   но  
 и   увеличивать   скорость   примерно   в   1   15   раз   тестироваться   при  
 радиус   размытие   50   это   соглашаться   немного   но   полезно   результат   размытие  
 по   гаусс   быть   выглядеть   следующий   образ   полагать   радиус   размытие   равный  
 30   и   сравнивать   результат   с   размытие   в   фотошоп   первый   изображение  
 размытый   с   радиус   30   пиксел   второй   разница   между   приводить   алгоритм  
 и   фильтр   фотошоп   blur   postprocess   28   сентябрь   2013   комментарий   43  
 убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость  
 GameDev   ru   разработка   игра   2001   2019   кой   что   о   размытие   изображение   с   помощь   шейдер   график   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   FAQ   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиграфика   кой   что   о   размытие   изображение   с   помощь   шейдер   автор   сергей   резник   этот   статья   познакомить   читатель   с   основной   техника   размытие   изображение   при   помощь   GLSL   шейдер   данный   техника   широко   применяться   в   игра   для   создание   такой   эффект   как   засветка   bloom   глубина   резко   изображать   пространство   DOF   эфект   движение   на   большой   скорость   итд   введение   двухпроходный   алгоритм   усреднение   соседний   пиксел   треугольный   закон   распределение   нормальный   закон   распределение   введение   по   суть   для   то   чтобы   размывать   изображение   необходимо   какой   то   образ   усреднять   значение   цвет   каждый   пиксел   изображение   с   цвет   его   сосед   в   предел   некоторый   диапазон   этот   диапазон   быть   называть   радиус   размытие   очевидный   решение   быть   следовать   слагать   значение   цвет   для   каждый   пиксел   расположенный   не   далеко   чем   радиус   размытие   от   текущий   по   X   и   Y   координата   а   затем   поделить   они   на   квадрат   два   радиус   размытие   плюс   единица   так   как   мы   слева   справа   сверху   и   снизу   выбирать   пиксел   на   расстояние   не   много   чем   радиус   центральный   пиксел   однако   давать   посчитать   сколько   же   пиксел   мы   приходиться   получать   из   изображение   результат   работа   вот   такой   код   int   value   0   for   int   y   r   y   R   y   for   int   x   r   x   R   x   x   быть   значение   равный   1   2   r   1   2   r   где   r   радиус   размытие   для   радиус   размытие   10   это   получаться   441   выборка   это   огромный   сложность   который   не   везде   можно   использовать   именно   для   упрощение   этот   сложность   и   придумывать   двухпроходной   алгоритм   размытие   суть   такой   алгоритм   состоять   в   то   что   изображение   размываться   сначала   по   горизонталь   или   по   вертикаль   и   сохраняться   во   временный   изображение   после   что   получать   изображение   размываться   в   другой   направление   в   данный   случай   мы   получать   сложность   1   2   R   1   2   R   для   радиус   размытие   10   мы   получать   42   выборка   на   пиксел   а   это   почти   в   R   раз   мало   также   при   размытие   изображение   следовать   учитывать   вес   пиксел   при   их   вариация   можно   получать   различный   результат   так   если   все   пиксел   быть   иметь   одинаковый   вес   мы   получать   усреднять   изображение   если   же   придавать   центральный   пиксел   больше   вес   чем   крайний   то   изобажение   быть   более   сконцентрированный   для   вариация   весы   можно   использовать   различный   закон   распределение   известный   из   математический   статистика   итак   рассматривать   основной   двухпроходной   алгоритм   размытие   для   пример   взять   вот   такой   исходный   картинка   двухпроходная   алгоритм   усреднение   соседний   пиксел   это   наиболее   простой   алгоритм   использовать   равномерый   закон   распределение   в   этот   случай   весь   пиксел   быть   иметь   одинаковый   вес   полагать   радиус   размытие   равный   десять   магический   число   21   являться   сумма   весь   весы   соседний   пиксел   конечно   же   для   радиус   размытие   равный   10   на   это   число   мы   нужно   быть   поделить   сумма   цветок   соседний   пиксел   как   видно   сумма   центральный   и   соседний   пиксел   с   каждый   из   сторона   в   точность   равняться   значение   2   R   1   такой   образ   нет   необходимость   высчитывать   этот   сумма   рассматривать   реализация   данный   алгоритм   на   шейдерный   язык   GLSL   uniform   sampler2D   source _ image   uniform   vec3   texel _ radius   in   vec2   TexCoord   out   vec4   FragColor   void   main   float   radius   texel _ radius   z   vec4   value   texture   source _ image   TexCoord   float   totalScale   2   0   radius   1   0   float   x   1   0   while   x   radius   vec2   dudv   texel _ radius   xy   x   value   texture   source _ image   TexCoord   dudv   texture   source _ image   TexCoord   dudv   x   1   0   FragColor   value   totalScale   входной   параметр   являться   сэмплер   для   исходный   изображение   и   трехкомпонентный   вектор   который   содержать   в   себя   шаг   размытие   и   радиус   шаг   размытие   в   данный   случай   быть   1   0   ширина   изображение   0   0   для   горизонтальный   размытие   и   0   0   1   0   высота   изображение   для   вертикальный   в   дальнейший   реализация   быть   использовать   тот   же   терминология   после   два   проход   размытый   изображение   быть   выглядеть   вот   так   треугольный   закон   распределение   следующий   по   сложность   алгоритм   являться   алгоритм   использовать   закон   распределение   симпсон   в   данный   закон   распределение   вес   соседний   точка   на   текстура   с   увеличение   расстояние   до   центральный   точка   убывать   линейно   как   и   рано   полагать   радиус   размытие   равный   десять   так   же   как   и   рано   мы   необходимо   быть   находить   сумма   весь   весы   соседний   пиксел   текстура   и   поделить   финальный   результат   на   она   для   это   полагать   вес   центральный   пискель   равный   r   1   в   такой   случай   вес   соседний   пиксел   быть   изменяться   в   соответствие   с   функция   f   x   на   картинка   низкий   вес   крайний   точка   в   этот   случай   быть   равный   единица   сумма   весы   весь   пиксел   в   данный   случай   быть   выражаться   формула   R   1   2   реализация   данный   алгоритм   на   GLSL   приводить   ниже   uniform   sampler2D   source _ image   uniform   vec3   texel _ radius   in   vec2   TexCoord   out   vec4   FragColor   void   main   float   r   texel _ radius   z   float   totalScale   1   0   r   vec4   value   texture   source _ image   TexCoord   totalScale   float   x   1   0   while   x   r   vec2   dudv   texel _ radius   xy   x   float   scale   1   0   r   x   value   scale   texture   source _ image   TexCoord   dudv   texture   source _ image   TexCoord   dudv   x   1   0   FragColor   value   totalScale   totalScale   результат   обработка   изображение   этот   алгоритм   быть   выглядеть   вот   так   нормальный   закон   распределение   следующий   алгоритм   размытие   который   мы   рассматривать   быть   так   называть   размытие   по   гаусс   именно   оно   использоваться   в   фотошоп   суть   он   заключаться   в   использование   нормальный   закон   распределение   обычно   нормальный   закон   распределение   включать   в   себя   два   параметр   математический   ожидание   и   дисперсия   для   наш   случай   быть   считать   математический   ожидание   равный   ноль   в   этот   случай   закон   распределение   включать   только   один   параметр   дисперсия   такой   упрощенный   закон   распределение   показывать   на   рисунок   ниже   функция   f   x   так   как   в   данный   закон   использоваться   дисперсия   величина   а   не   радиус   то   воспользоваться   правило   три   сигма   оно   гласить   о   то   что   в   диапазон   3σ   3σ   попадать   99   73   весь   величина   из   распределение   полагать   радиус   равный   десять   в   этот   случай   σ   быть   равный   10   3   3   дробный   часть   не   учитывать   так   как   мы   делать   шаг   на   целый   число   пиксел   в   сторона   от   центральный   следовать   замечать   что   в   данный   алгоритм   сумма   весы   весь   соседний   пиксел   быть   близкий   к   единица   то   быть   мы   не   приходиться   делить   или   умножать   получать   результат   на   какой   либо   число   но   также   не   следовать   забывать   что   в   выбирать   предел   попадать   не   100   величина   а   только   99   73   это   означать   что   сумма   быть   маленький   единица   и   финальный   изображение   быть   затемняться   чтобы   устранять   этот   недостаток   увеличивать   изменять   вес   центральный   точка   на   1   0   сумма   весы   соседний   и   в   итог   получать   сумма   вес   весь   пиксел   равный   единица   рассматривать   код   данный   алгоритм   на   GLSL   uniform   sampler2D   source _ image   uniform   vec3   texel _ radius   in   vec2   TexCoord   out   vec4   FragColor   define   M _ PI   3   1415926535897932384626433832795   float   gauss   float   x   float   sigma   float   x _ sqr   x   x   float   sigma _ sqr   sigma   sigma   float   sqrt _ value   1   0   sqrt   2   0   M _ PI   sigma _ sqr   float   exp _ value   exp   x _ sqr   2   0   sigma _ sqr   return   sqrt _ value   exp _ value   void   main   float   r   texel _ radius   z   float   sigma   r   3   0   float   sum   0   0   vec4   value   vec4   0   0   float   x   1   0   while   x   r   float   currentScale   gauss   x   sigma   sum   2   0   currentScale   vec2   dudv   texel _ radius   xy   x   value   currentScale   texture   source _ image   TexCoord   dudv   texture   source _ image   TexCoord   dudv   x   1   0   value   texture   source _ image   TexCoord   1   0   sum   FragColor   value   как   видеть   здесь   выполняться   очень   много   лишний   инструкция   каждый   раз   пересчитываться   константа   и   т   д   давать   немного   оптимизировать   этот   код   1   вынести   сигма   из   под   корень   и   вычислять   константа   1   0   sqrt   2   0   PI   2   так   как   сигма   у   мы   не   меняться   следовательно   не   меняться   весь   выражение   перед   экспонента   а   так   же   множитель   при   x   в   выражение   внутри   экспонент   следовательно   все   это   можно   посчитать   один   раз   и   вынести   за   скобка   3   избавляться   от   лишний   операция   деление   на   три   подставлять   тройка   в   выражение   после   проделывать   операция   получать   вот   такой   вот   шейдер   uniform   sampler2D   source _ image   uniform   vec3   texel _ radius   in   vec2   TexCoord   out   vec4   FragColor   define   INV _ SQRT _ 2PI _ X3   1   1968268412042980338198381798031   void   main   float   r   texel _ radius   z   float   exp _ value   4   5   r   r   float   sqrt _ value   INV _ SQRT _ 2PI _ X3   r   float   sum   0   0   vec4   value   vec4   0   0   float   x   1   0   while   x   r   float   currentScale   exp   exp _ value   x   x   sum   currentScale   vec2   dudv   texel _ radius   xy   x   value   currentScale   texture   source _ image   TexCoord   dudv   texture   source _ image   TexCoord   dudv   x   1   0   float   correction   1   0   sqrt _ value   2   0   sum   value   texture   source _ image   TexCoord   correction   FragColor   value   sqrt _ value   такой   оптимизация   мы   не   только   уменьшать   размер   шейдер   но   и   увеличивать   скорость   примерно   в   1   15   раз   тестироваться   при   радиус   размытие   50   это   соглашаться   немного   но   полезно   результат   размытие   по   гаусс   быть   выглядеть   следующий   образ   полагать   радиус   размытие   равный   30   и   сравнивать   результат   с   размытие   в   фотошоп   первый   изображение   размытый   с   радиус   30   пиксел   второй   разница   между   приводить   алгоритм   и   фильтр   фотошоп   blur   postprocess   28   сентябрь   2013   комментарий   43   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   GameDev   ru   разработка   игра   2001   2019