   rectilinear   texture   warping   график   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   faq   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиграфика   rectilinear   texture   warping   автор   mephisto   std   в   данный   статья   я   рассказывать   об   адаптивный   метод   теневой   карта   под   название   rectilinear   texture   warping   for   adaptive   shadow   maps   о   его   достоинство   и   недостаток   а   также   о   реальный   опыт   использование   данный   метод   в   проект   и   что   из   это   выходить   очень   хотеться   чтобы   данный   статья   быть   все   таки   технический   а   не   журналистский   но   в   тот   же   время   не   хотеться   сразу   на   полный   скак   врываться   в   код   поэтому   для   плавность   хотеться   бы   рассказывать   немного   о   тень   в   график   создание   реалистичный   эффективный   по   производительность   тень   один   из   самый   актуальный   задача   компьютерный   график   с   начинать   время   один   из   подзадача   освещение   за   последний   20   год   тень   в   игра   эволюционировать   до   неузнаваемость   краткий   экскурс   в   история   shadow   mapping   адаптивный   метод   теневой   карта   rectilinear   texture   warping   for   fast   adaptive   shadow   mapping   деталь   имплементация   недостаток   еще   что   нибудь   краткий   экскурс   в   история   если   в   случай   тень   от   статический   объект   довольно   приемлемый   результат   получать   еще   в   quake   1   с   использование   запечение   освещение   в   lightmaps   то   с   тень   от   динамический   объект   долгий   время   все   быть   не   так   радужно   вначале   тень   вообще   никто   особо   не   заморачиваться   самый   первый   тень   от   персонаж   быть   просто   дополнительный   спрайт   размазывать   пятно   который   проецироваться   на   геометрия   под   персонаж   потом   довольно   популярный   становиться   shadow   volumes   они   же   stencil   shadows   метод   заключаться   в   то   что   для   источник   свет   геометрически   находиться   контур   объект   edge   считаться   граница   объект   если   знак   dot   product   нормаль   с   light   vector   для   два   примыкать   полигон   иметь   разный   знак   а   затем   из   этот   контур   строиться   shadow   volume   который   по   суть   быть   вытягивать   контур   объект   а   вектор   вытяжение   контур   быть   направление   свет   затем   данный   volume   рисоваться   в   stencil   сначала   с   back   culling   а   затем   вычитаться   из   stencil   с   front   culling   такой   образ   в   стенсила   у   мы   оставаться   разница   между   front   и   back   куллинг   что   по   суть   являться   пересечение   volume   с   геометрия   то   быть   с   тень   из   минус   данный   подход   хотеться   выделять   зависимость   вычислительный   стоимость   от   геометрия   высокий   нагрузка   на   cpu   а   также   жесткий   край   тень   весь   это   вкупе   заставлять   почти   весь   современный   движок   отказываться   от   этот   метод   самый   хороший   качество   тень   разумеется   достигаться   с   помощь   честный   просчет   траектория   луч   свет   ray   tracing   сейчас   данный   техника   практически   неприменимый   в   real   time   приложение   так   как   стоимость   данный   подход   весьма   большой   однако   же   в   offline   рендеры   cg   заставка   фильм   мультфильм   и   т   п   использоваться   преимущественно   именно   она   никакой   сомнение   нет   в   то   что   данный   техника   являться   технологический   пик   лайтинг   в   компьютерный   графика   и   тень   в   частность   так   как   повторять   механизм   реальный   мир   не   являться   приближение   и   потому   давать   визуальный   результат   который   наиболее   близкий   к   идеальный   и   если   позволять   производительность   железо   рано   или   поздно   весь   real   time   рендеры   быть   работать   именно   так   shadow   mapping   пока   это   не   происходить   использоваться   аппроксимация   который   наиболее   близкий   к   рейтрейсинг   shadow   mapping   shadow   mapping   это   довольно   старый   метод   для   создание   тень   становиться   на   данный   момент   золотой   стандарт   индустрия   вряд   ли   сейчас   можно   встречать   aaa   проект   в   который   не   использоваться   данный   техника   вкратце   для   каждый   источник   свет   который   должный   отбрасывать   тень   мы   ставить   камера   в   который   рисовать   расстояние   до   весь   объект   который   у   мы   на   путь   после   что   получать   результат   мы   использовать   уже   для   рисование   с   позиция   основной   камера   чтобы   определять   освещать   ли   данный   пиксел   тот   или   иной   источник   свет   или   нет   я   не   быть   вдаваться   в   деталь   реализация   данный   метод   благо   информация   на   давать   тема   полно   о   что   хотеться   поговорить   так   это   о   минус   данный   метод   главный   минус   данный   метод   по   сравнение   с   ray   tracing   в   то   что   качество   тень   напрямую   зависеть   от   разрешение   текстура   в   который   тень   рендериваться   в   тот   время   как   качество   ray   traced   тень   всегда   идеально   что   это   означать   де   факто   для   визуал   например   у   мы   быть   лампочка   который   использовать   shadow   map   карта   тень   разрешение   512х512   издалека   тень   от   данный   лампочка   казаться   четкий   но   стоить   подлетать   близко   как   тень   быстро   терять   свой   качество   конечно   быть   метода   борьба   с   данный   артефакт   например   использовать   алгоритм   для   сглаживание   и   смягчение   тень   это   помогать   до   определенный   степень   но   что   если   мы   например   не   хотеть   мягкий   тень   если   хотеть   чтобы   в   точка   контакт   с   поверхность   тень   быть   жесткий   если   увеличивать   разрешение   shadow   map   то   данный   артефакт   также   исчезать   ну   не   совсем   всегда   можно   находить   зум   при   который   пикселизация   вновь   вылезать   но   увеличение   размер   карта   тень   немедленно   наказывать   мы   fps   падать   количество   память   уменьшаться   а   память   весьма   ценный   ресурс   особенно   на   консоли   к   то   же   если   теневой   источник   свет   в   кадр   1000   для   каждый   использовать   шадоумап   8192x8192   эдак   никакой   ресурс   не   хватить   адаптивный   метод   теневой   карта   итак   увеличение   разрешение   в   целое   работать   но   необходимый   алгоритм   который   позволять   увеличивать   разрешение   так   чтобы   не   занимать   весь   видеопамять   и   опускать   fps   до   ноль   нужный   механизм   который   позволять   динамически   изменять   разрешение   теневой   карта   в   зависимостити   от   происходить   на   экран   то   быть   адаптивность   первый   что   приходить   в   голова   это   уменьшать   разрешение   теневой   карта   если   источник   свет   далеко   и   увеличивать   если   источник   свет   близко   для   точечный   point   источник   свет   такой   подход   мочь   срабатывать   если   не   углубляться   в   проблема   менеджмент   создание   менеджмент   ресурс   и   т   п   но   работать   ли   такой   подход   если   у   мы   spot   или   directional   light   ладно   для   spot   light   можно   находить   расстояние   до   light   volume   это   не   так   тривиальный   как   в   случай   point   но   тоже   не   очень   сложно   и   худо   бедно   срабатывать   но   как   быть   с   солнце   солнце   бесконечно   удалять   от   главный   камера   оперировать   расстояние   до   источник   свет   тут   бессмысленно   что   можно   придумывать   чтобы   более   эффективно   использовать   пространство   теневой   карта   для   солнце   для   решение   такой   проблема   быть   метод   так   называть   каскад   быть   несколько   пермутация   данный   метод   различаться   по   имплементация   но   общий   подход   у   все   один   пространство   разбиваться   на   каскад   в   зависимоти   от   удаление   от   главный   камера   каскад   это   по   суть   несколько   теневой   карта   с   точка   зрение   ресурс   часто   все   это   один   большой   текстура   поделить   на   несколько   участок   одинаковый   размер   в   который   рисоваться   объект   в   зависимость   от   попадание   в   каскад   такой   образ   получаться   что   например   область   вокруг   камера   размер   15м   х   15м   получать   в   теневой   карта   например   участок   1024х1024   следующий   каскад   уже   значительно   много   по   размер   30м   х   30м   но   получать   тот   же   1024х1024   но   так   как   объект   данный   каскад   удалять   от   камера   то   разница   с   точка   зрение   главный   камера   быть   минимальный   данный   подход   в   целое   неплохо   работать   и   по   сей   день   для   он   придумывать   немало   оптимизация   который   позволять   еще   немного   улучшать   данный   подход   но   даже   с   каскад   у   данный   подход   оставаться   все   тот   же   классический   недостаток   tradeoff   пикселизация   перформанс   все   таки   15м   х   15м   это   много   а   1024х1024   не   очень   можно   увеличивать   разрешение   шадоумап   играться   с   размер   каскад   пока   не   находиться   приемлемый   сочетание   перформанс   качество   тут   все   зависеть   и   от   специфика   проект   и   от   то   какой   уровень   детализация   тень   необходимый   понятно   что   в   fps   данный   проблема   стоять   более   остро   чем   например   в   tps   или   стратегия   в   более   или   менее   современный   игра   этот   проблема   так   и   решаться   находиться   приемлимый   баланс   в   регулировка   каскад   каков   же   недостаток   классический   каскад   в   целое   они   несколько   первый   фундаментальный   недостаток   рисование   объект   несколько   раз   тогда   как   более   мелкий   объект   можно   однозначно   относить   к   какой   то   каскад   и   рисовать   1   раз   то   более   крупный   попадать   сразу   в   несколько   каскад   и   вызывать   дополнительный   дип   к   такой   крупный   объект   как   правило   относиться   terrain   здание   транспортный   средство   и   т   п   второй   фундаментальный   недостаток   неэффективный   использование   пространство   карта   тень   взглядывать   на   этот   рисунок   ниже   из   он   видно   что   в   карта   тень   рендериваться   огромный   область   хотя   на   дело   мы   увидеть   на   экран   лишь   малый   она   часть   rectilinear   texture   warping   for   fast   adaptive   shadow   mapping   наконец   то   переходить   из   обзорный   часть   к   обсуждать   тема   автор   данный   метод   насколько   я   известно   являться   paul   rosen   из   university   of   south   florida   информация   можно   находить   тут   http   www   cspaul   com   wordpress   projects   rtw   итак   метод   shadow   map   warping   преследовать   тот   же   цель   что   и   например   каскад   позволять   использовать   пространство   более   эффективно   но   с   более   высокий   степень   адаптивность   чем   каскад   каскад   для   адаптирование   использовать   лишь   положение   и   направление   взгляд   главный   камера   в   тот   время   как   smw   использовать   еще   и   актуальный   буфер   глубина   depth   buffer   позволять   в   точность   определять   какой   часть   теневой   карта   быть   видный   а   какой   нет   общий   алгоритм   метод   таков   1   мы   брать   depth   buffer   если   быть   earlyz   то   можно   взять   он   иначе   можно   взять   с   прошлый   кадр   2   делать   репроекция   в   light   space   т   е   как   бы   источник   свет   увидеть   в   точность   то   что   видеть   мы   при   репроекция   в   пиксел   записываться   importance   информация   который   позволять   судить   о   то   насколько   данный   пиксел   важный   с   точка   зрение   главный   камера   в   качество   importance   логично   использовать   какой   то   функция   от   расстояние   до   главный   камера   3   на   основа   репроекция   и   importance   map   создаваться   warp   buffer   буффер   в   который   содержаться   коэффициент   сжатие   насколько   тот   или   иной   область   теневой   карта   важный   и   должный   быть   расширять   ну   или   наоборот   неважный   и   должный   быть   суживать   4   с   помощь   warp   buffer   выполняться   эффективный   рендер   тень   в   один   проход   на   получаться   теневой   карта   тот   объект   часть   объект   тень   от   который   находиться   близко   к   главный   камера   быть   занимать   много   место   а   тот   объект   тень   от   который   не   видный   мочь   схлопнуться   в   один   пиксел   5   с   помощь   тот   же   warp   buffer   теневой   карта   резолвиться   во   front   pass   6   profit   для   визуальный   представление   работа   данный   метод   я   предлагать   посмотреть   видео   от   автор   метод   и   еще   один   видео   от   я   деталь   имплементация   в   данный   раздел   я   описывать   тот   место   в   мой   реализация   rtw   который   мочь   вызывать   трудность   и   вопрос   полный   искодный   код   мой   dx11   standalone   тестовый   версия   rtw   можно   посмотреть   вот   тут   https   github   com   m10914   fett _ framework   ветка   rectilinear _ shadows   итак   первый   что   нужно   сделать   это   репроекция   depth   buffer   в   пространство   теневой   камера   делать   это   можно   с   помощь   compute   shader   с   использование   атомарный   операция   ведь   несколько   точка   front   buffer   мочь   репроектиться   в   один   и   тот   же   точка   shadow   buffer   код   cs   шейдер   репроекция   samplerstate   samplerdefault   register   s0   texture2d   txdepthbuffer   register   t0   rwstructuredbuffer   int   outbuffer   register   u0   cbuffer   cbdefault   register   b0   matrix   matworldviewinv   matrix   matprojinv   matrix   matworldviewlight   matrix   matprojlight   numthreads   16   16   1   void   cs _ main   uint3   gid   sv _ groupid   uint3   dtid   sv _ dispatchthreadid   uint3   gtid   sv _ groupthreadid   uint   gi   sv _ groupindex   float2   texcoord   float2   float2   dtid   xy   rtw _ width   float   depth   txdepthbuffer   samplelevel   samplerdefault   texcoord   0   r   reconstruction   float2   cspos   float2   texcoord   x   2   1   1   texcoord   y   2   1   float4   depthcoord   float4   cspos   xy   depth   1   depthcoord   mul   matprojinv   depthcoord   depthcoord   mul   matworldviewinv   depthcoord   depthcoord   depthcoord   w   reprojection   float4   ncoord   mul   matworldviewlight   depthcoord   ncoord   mul   matprojlight   ncoord   ncoord   ncoord   w   ncoord   xy   mad   ncoord   xy   0   5   0   5   int   indx   int   ncoord   x   rtw _ width   int   indy   int   1   0   ncoord   y   rtw _ width   int   index   indx   indy   rtw _ width   linearize   float   f   1   float   n   0   1   float   z   2   n   f   n   depth   f   n   float   intermediate   saturate   1   z   int   rval   intermediate   100000   0   if   indx   rtw _ width   indx   0   indy   0   indy   rtw _ width   interlockedmax   outbuffer   index   rval   вначале   реконструировать   world   position   пиксел   потом   делать   проекция   в   light   space   вычислять   importance   и   через   атомарный   операция   записывать   в   результирующий   буффер   в   данный   случай   importance   обратно   пропорционально   линейный   глубина   так   как   0   глубина   должный   давать   абсолютный   важность   это   означать   что   данный   пиксел   находиться   прямо   перед   камера   а   1   глубина   нулевой   второй   этап   создание   warp   buffer   тут   важный   роль   играть   слово   rectilinear   прямоугольный   особенность   метод   заключаться   в   то   что   варпинг   происходить   независимо   только   по   два   ось   x   и   y   потому   сам   буфер   состоять   из   два   одномерный   массив   который   соответствовать   ось   x   и   y   теневой   карта   для   создание   warp   buffer   вначале   из   2d   importance   map   создаваться   два   1d   importance   array   элемент   независимо   собираться   по   ось   и   фильтроваться   по   max   это   означать   что   весь   линия   где   быть   хоть   один   важный   точка   быть   считаться   важный   samplerstate   samlinear   register   s0   samplerstate   sambackbuffer   register   s1   samplerstate   samdepth   register   s2   if   x   y   we   can   do   this   trick   unite   two   buffers   into   one   rwstructuredbuffer   float2   outbuffer   register   u0   structuredbuffer   int   inbuffer   register   t0   numthreads   8   1   1   dispatch   128   1   1   we   have   1024   x   calls   void   calcimportance   uint3   gid   sv _ groupid   uint3   dtid   sv _ dispatchthreadid   uint3   gtid   sv _ groupthreadid   uint   gi   sv _ groupindex   float2   res   0   for   int   i   0   i   width   i   res   x   max   res   x   float   inbuffer   int   dtid   x   width   i   100000   0   res   y   max   res   y   float   inbuffer   dtid   x   int   i   width   100000   0   outbuffer   dtid   x   res   xy   затем   importance   arrays   конвертироваться   в   warp   buffers   который   тоже   являть   себя   два   одномерный   массив   чтобы   варпинг   не   происходить   скачок   неплохо   бы   сделать   блюр   получаться   warp   buffer   для   создание   warp   buffer   использоваться   нетривиальный   формула   который   обеспечивать   гладкость   варпинг   в   то   смысл   что   вертекс   после   варп   оставаться   в   тот   же   порядок   что   и   до   варп   то   быть   один   вертекс   не   мочь   обгонять   другой   samplerstate   samlinear   register   s0   samplerstate   sambackbuffer   register   s1   samplerstate   samdepth   register   s2   rwstructuredbuffer   float2   outbuffer   register   u0   structuredbuffer   float2   inbuffer   register   t0   numthreads   8   1   1   dispatch   128   1   1   we   have   1024   x   calls   void   calcwarp   uint3   gid   sv _ groupid   uint3   dtid   sv _ dispatchthreadid   uint3   gtid   sv _ groupthreadid   uint   gi   sv _ groupindex   float2   totalsum   0   float2   partialsum   0   for   int   i   0   i   width   i   totalsum   inbuffer   i   xy   if   i   dtid   x   partialsum   totalsum   outbuffer   dtid   x   partialsum   totalsum   float2   dtid   xx   width   numthreads   8   1   1   void   blurwarp   uint3   gid   sv _ groupid   uint3   dtid   sv _ dispatchthreadid   uint3   gtid   sv _ groupthreadid   uint   gi   sv _ groupindex   float   coeffs   7   0   127325   0   107778   0   081638   0   055335   0   033562   0   018216   0   008847   float2   sum   inbuffer   dtid   x   0   134598   unroll   for   int   i   0   i   7   i   int   ind _ pos   min   dtid   x   i   1   width   int   ind _ neg   max   0   dtid   x   i   1   sum   inbuffer   ind _ pos   inbuffer   ind _ neg   coeffs   i   outbuffer   dtid   x   sum   теперь   у   мы   готовый   warp   buffer   большой   часть   работа   сделать   теперь   при   рендер   в   шадоумап   необходимо   использовать   warp   buffer   structuredbuffer   float2   warpmaps   register   t0   vertex   shader   float4   rpos   mul   input   pos   mul   world   mvplight   rpos   rpos   w   rpos   xy   mad   float2   rpos   x   rpos   y   0   5   0   5   float2   indexs   rpos   xy   width   float2   warps   float2   lerp   warpmaps   floor   indexs   x   y   warpmaps   floor   indexs   x   1   y   frac   indexs   x   lerp   warpmaps   floor   indexs   y   x   warpmaps   floor   indexs   y   1   x   frac   indexs   y   rpos   xy   warps   output   pos   rpos   вначале   мы   получать   координата   пиксел   на   шадоумап   в   ndc   затем   по   этот   координата   находить   необходимый   элемент   массив   warpmaps   отдельно   по   ось   x   и   y   и   затем   выполнять   варпинг   увеличение   уменьшение   объект   в   зависимость   от   его   важность   вот   и   все   теперь   в   shadow   map   у   мы   объект   заполнять   пространство   соответствие   с   их   важность   при   резолва   shadow   map   мы   также   должный   использовать   warp   buffer   чтобы   корректно   рассчитать   текстурный   координата   pixel   shader   obtain   standart   non   warped   shadowmap   coords   float2   ncoord   getshadowmapcoordinates   perform   warping   float2   indexs   ncoord   xy   width   float2   warps   float2   lerp   warpmaps   ceil   indexs   x   y   warpmaps   ceil   indexs   x   1   y   frac   indexs   x   lerp   warpmaps   ceil   indexs   y   x   warpmaps   ceil   indexs   y   1   x   frac   indexs   y   ncoord   xy   warps   sample   shadowmap   float   shadowdepth   txshadowmap   sample   samdepth   float2   ncoord   x   1   ncoord   y   r   вот   и   все   как   выглядеть   данный   метод   в   работа   можно   посмотреть   в   видео   высоко   недостаток   к   сожаление   при   весь   теоретический   привлекательность   данный   метод   обладать   рядом   фатальный   недостаток   который   делать   его   применение   практически   невозможный   в   реальный   проект   в   частность   именно   в   наш   проект   приходиться   отказываться   от   данный   техника   именно   из   за   вышеозначенный   недостаток   джиттеринг   метод   очень   чувствительный   к   положение   камера   из   за   это   даже   микро   движение   камера   мочь   вызывать   передвижение   объект   на   shadowmap   и   если   на   важный   объект   этот   не   быть   заметный   то   на   объект   занимать   мало   пиксел   на   shadow   map   этот   изменение   пиксел   быть   очень   заметно   особенно   это   видно   на   тень   от   тонкий   или   мелкий   объект   ветка   и   лист   из   за   постоянный   микроизменение   камера   возникать   постоянный   мельтешение   тень   иначе   говорить   джиттеринг   данный   недостаток   обладать   к   сожаление   весь   адаптивный   метод   можно   уменьшать   джиттеринг   с   помощь   снаппинг   главный   камера   использовать   для   расчет   координата   и   вращение   камера   с   сильно   уменьшать   точность   чтобы   микроизменение   камера   не   вызывать   перераспределение   теневой   карта   но   полностью   от   он   избавляться   невозможно   джиттеринг   неизбежный   спутник   весь   адаптивный   метод   который   зависеть   от   содержимый   depth   buffer   и   положение   камера   некорректный   резолвы   в   данный   конкретный   метод   быть   еще   один   фатальный   недостаток   дело   в   то   что   применение   warp   buffer   при   рендерингде   в   теневой   карта   повертексный   а   при   резолва   попиксельный   по   суть   это   означать   что   если   большой   полигон   сильно   растягиваться   то   он   не   в   курс   какой   варпинг   происходить   у   он   в   середина   а   при   резолва   этот   варпинг   применяться   что   означать   что   в   центр   такой   полигон   быть   некорректный   тень   для   то   чтобы   избегать   данный   артефакт   использоваться   адаптивный   тесселяция   смысл   в   данный   случай   как   можно   сильно   приближать   повертексный   варп   к   попиксельный   данный   метод   быть   опробовать   и   он   действительно   почти   полностью   убирать   этот   артефакт   но   к   сожаление   на   правильный   адаптивный   тесселяция   уходить   очень   много   время   что   убивать   практически   весь   профит   связывать   с   переход   на   rtw   как   вариант   можно   изначально   делать   мелкий   геометрия   тогда   тесселяция   не   понадобиться   но   этот   вариант   не   выглядеть   удачный   так   как   накладывать   ограничение   на   ассета   а   это   обычно   не   очень   приветствоваться   еще   что   нибудь   быть   еще   один   адаптивный   теневой   метод   который   достоить   упоминание   он   лишать   недостаток   некорректный   резолвы   но   в   он   по   прежний   быть   джиттеринг   называться   он   sample   distribution   shadow   maps   https   software   intel   com   en   us   articles   sample   distribution   shadow   maps   по   суть   свой   данный   метод   иметь   много   общий   с   rtw   он   также   использовать   репроекция   depth   buffer   но   вместо   то   чтобы   строить   warp   buffers   он   просто   модифицировать   теневой   уменьшать   она   фрустум   и   такой   образ   теневой   камера   рендерит   только   то   что   видеть   главный   камера   визуальный   демонстрация   полезный   ссылка   http   www   gamedev   ru   code   articles   gpsm   похожий   адаптивный   метод   для   тень   от   аврелий   http   www   cspaul   com   wordpress   projects   rtw   shadowmap   тень   12   октябрь   2016   обновление   24   апр   2017   комментарий   29   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   gamedev   ru   разработка   игра   2001   2019