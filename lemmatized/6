   coverage   buffer   из   cryengine   в   деталь   график   статья   программирование   игра   новость   статья   код   арт   дизайн   индустрия   подсказка   термин   faq   страница   сообщество   форум   качалка   участник   пользователь   темный   тема   публикация   проект   форум   работа   входить   программированиестатьиграфика   coverage   buffer   из   cryengine   в   деталь   автор   mephisto   std   некоторый   время   назад   я   наткнуться   в   замечательный   презентация   secrets   of   cryegnine   3   graphics   technology   от   не   менее   замечательный   nickolay   kasyan   nicolas   schulz   и   tiago   sousa   на   описание   любопытный   технология   называть   автор   coverage   buffer   с   сам   презентация   можно   ознакомляться   тут   http   www   slideshare   net   tiagoalexsousa   secrets   of   cryengine   3   g   cs   technology   технология   представлять   как   основной   метод   окклюдить   куллинг   активно   использовать   начинать   с   crysis   2   так   как   никакой   внятный   пейпер   по   данный   технология   crytek   не   предоставлять   а   разбираться   быть   интересный   то   приходиться   плясать   с   то   что   иметь   что   итак   идея   по   слово   автор   презентация   заключаться   в   следующий   получать   depth   buffer   предыдущий   кадр   сделать   репроекция   в   текущий   кадр   софтварный   растеризовать   bbox   ы   объект   проверять   видный   ли   они   камера   и   рисовать   не   рисовать   метод   в   принцип   не   содержать   никакой   революционный   идея   отличие   от   основной   конкурент   software   occlusion   culling   заключаться   в   тот   в   тот   метод   мы   необходимо   строго   поделить   объект   на   категория   occluder   occludee   что   не   всегда   возможно   сделать   итак   еще   раз   кратко   резюмировать   каков   плюс   этот   метод   не   нужно   разделять   объект   на   occluder   occludee   использование   уже   готовый   depth   buffer   ну   и   очевидный   минус   ошибка   связывать   с   отставание   на   1   кадр   репроекция   полностью   не   решать   данный   проблема   оверхед   при   полный   видимость   объект   связывать   с   манипуляция   с   depth   buffer   downscale   lock   и   т   д   где   так   уж   получаться   что   я   гуглить   в   сторона   occlusion   culling   не   просто   так   на   проект   необходимо   быть   решать   довольно   важный   задача   связывать   с   тормоз   возникать   из   за   огромный   лесной   массив   речь   идти   конечно   же   о   горячо   любимый   я   life   is   feudal   весь   скрин   ниже   быть   оттуда   итак   вкратце   суть   изначальный   проблема   быть   остров   густо   засаживать   дерево   рисоваться   весь   этот   действо   на   движок   torque3d   из   оптимизация   изначально   встроенный   в   движок   быть   неплохой   система   батчинга   биллборд   для   дальний   дерево   и   инстансинг   для   тот   который   близко   однако   решение   рисовать   не   рисовать   приниматься   по   дефолт   исключительно   в   результат   frustum   culling   а   т   е   мы   смотреть   попадать   ли   данный   дерево   батч   в   пирамида   и   если   попадать   то   рисовать   однако   такой   подход   не   вполне   оправдывать   себя   в   случай   действительно   большой   лесной   массив   с   десяток   тысяча   дерево   в   этот   случай   попадать   во   фрустум   и   как   следствие   рисоваться   тот   дерево   который   находиться   за   стена   гора   и   другой   дерево   из   за   это   бюджет   кадр   терпеть   катастрофический   потеря   даже   смотреть   сквозь   стена   в   направление   центр   остров   рисование   невидимый   батч   и   дерево   занимать   порядко   20   30мс   что   в   общий   то   вплотную   приближаться   к   рассчетный   бюджет   кадр   33мс   как   результат   игрок   получать   драматический   падение   фпс   просто   глядеть   в   направление   центр   остров   для   решение   данный   задача   быть   решать   воспользоваться   технология   coverage   buffer   если   бы   я   писать   например   диплом   то   тут   бы   стоить   сделать   обзор   весь   остальной   метод   oc   обозначать   плюс   и   минус   и   обосновывать   почему   быть   выбирать   именно   этот   к   счастие   это   не   диплом   потому   ограничиваться   один   предложение   после   чтение   многочисленный   пейпер   и   статья   переписка   и   беседа   с   более   мудрый   и   опытный   коллега   быть   решать   опробовать   этот   метод   то   более   что   в   бой   он   уже   себя   показывать   оставаться   лишь   посмотреть   как   он   показывать   себя   в   наш   ситуация   когда   как   теперь   переходить   к   технический   деталь   и   собственно   код   первый   задача   который   вставать   это   получать   depth   buffer   torque3d   который   на   момент   написание   статья   поддерживать   directx   только   9й   версия   накладывать   в   этот   свет   определенный   ограничение   как   получать   depth   buffer   в   directx   9   ответ   находиться   на   сайт   арас   пранцкевичус   я   не   уверенный   что   правильно   транслитерировать   его   фамилия   это   главный   render   guy   известный   движок   unity   http   aras   p   info   texts   d3d9gpuhacks   html   оказываться   что   depth   buffer   получать   в   directx   9   весь   таки   можно   но   для   это   нужно   использовать   специальный   формат   intz   согласно   официальный   документация   от   amd   и   nvidia   весь   видеокарта   выпускать   начинать   с   2008го   год   поддерживать   данный   формат   для   более   ранний   быть   rawz   так   что   можно   без   особый   опасение   пользоваться   данный   хак   ссылка   на   документация   amd   и   nvidia   код   использование   тривиальный   взять   из   один   из   пейпер   вверху   приводить   его   тут   чтобы   так   сказать   весь   яйцо   быть   в   один   корзина   intz   скрывать   define   fourcc _ intz   d3dformat   makefourcc   i   n   t   z   determine   if   intz   is   supported   hresult   hr   hr   pd3d   checkdeviceformat   adapterordinal   devicetype   adapterformat   d3dusage _ depthstencil   d3drtype _ texture   fourcc _ intz   bool   bintzdepthstenciltexturessupported   hr   d3d _ ok   create   an   intz   depth   stencil   texture   idirect3dtexture9   pintzdst   pd3ddevice   createtexture   dwwidth   dwheight   1   d3dusage _ depthstencil   fourcc _ intz   d3dpool _ default   pintzdst   null   retrieve   depth   buffer   surface   from   texture   interface   idirect3dsurface9   pintzdstsurface   pintzdst   getsurfacelevel   0   pintzdstsurface   bind   depth   buffer   pd3ddevice   setdepthstencilsurface   pintzdstsurface   bind   depth   buffer   texture   pd3ddevice   settexture   0   pintzdst   дальнейший   подготовка   depth   buffer   а   downscale   до   низкий   разрешение   быть   выбирать   256х128   lock   memcpy   reprojection   все   тут   достаточно   тривиальный   downscale   делаться   с   маска   max   браться   максимальный   расстояние   близко   к   камера   дабы   не   закрывать   что   лишний   репроекция   делаться   путем   применение   обратный   матрица   от   предыдущий   кадр   и   новый   от   текущий   возникать   пробел   замазываться   maxvalue   дабы   не   закрывать   чего   лишний   итак   теперь   быть   depth   buffer   теперь   дело   за   малое   софтварной   растеризация   ббокс   софтварной   растеризация   давать   тема   никак   нельзя   называть   нехоженный   тропа   уже   довольно   много   мусолить   на   разный   лад   однако   внятный   инструкция   к   реализация   находить   не   так   то   просто   самый   полезный   материал   который   я   находить   по   сабж   быть   тут   https   software   intel   com   en   us   blogs   2013   09   06   software   occlus   ling   update   2   это   крайне   полезный   интеловский   демка   по   conventional   occlusion   culling   который   все   рекомендовать   внутри   много   полезный   первый   версия   функция   для   софтварный   растеризация   быть   реализовать   в   так   сказать   plain   c   она   работать   но   довольно   медленно   спасибо   комрад   bazhenovc   подсказывать   переписывать   на   sse   я   по   молодость   с   sse   еще   не   работать   но   с   божий   и   интеловский   помощь   переписывать   на   sse   становиться   работать   в   2   2   5   раз   быстро   вот   она   магия   simd   делиться   код   безвозмездно   юзать   на   здоровье   если   вдруг   кто   замечать   какой   недочет   или   возможность   для   оптимизация   очень   просить   сообщать   код   скрывать   static   const   int   sbbindexlist   36   index   for   top   4   8   7   4   7   3   index   for   bottom   5   1   2   5   2   6   index   for   left   5   8   4   5   4   1   index   for   right   2   3   7   2   7   6   index   for   back   6   7   8   6   8   5   index   for   front   1   4   3   1   3   2  __ m128   ssetransformcoords  __ m128   v  __ m128   m  __ m128   vresult  _ mm _ shuffle _ ps   v   v  _ mm _ shuffle   0   0   0   0   vresult  _ mm _ mul _ ps   vresult   m   0  __ m128   vtemp  _ mm _ shuffle _ ps   v   v  _ mm _ shuffle   1   1   1   1   vtemp  _ mm _ mul _ ps   vtemp   m   1   vresult  _ mm _ add _ ps   vresult   vtemp   vtemp  _ mm _ shuffle _ ps   v   v  _ mm _ shuffle   2   2   2   2   vtemp  _ mm _ mul _ ps   vtemp   m   2   vresult  _ mm _ add _ ps   vresult   vtemp   vresult  _ mm _ add _ ps   vresult   m   3   return   vresult  __ forceinline  __ m128i   min   const  __ m128i   v0   const  __ m128i   v1  __ m128i   tmp   tmp  _ mm _ min _ epi32   v0   v1   return   tmp  __ forceinline  __ m128i   max   const  __ m128i   v0   const  __ m128i   v1  __ m128i   tmp   tmp  _ mm _ max _ epi32   v0   v1   return   tmp   struct   ssevfloat4  __ m128   x  __ m128   y  __ m128   z  __ m128   w   get   4   triangles   from   vertices   void   ssegather   ssevfloat4   pout   3   int   triid   const  __ m128   xformedpos   for   int   i   0   i   3   i   int   ind0   sbbindexlist   triid   3   i   0   1   int   ind1   sbbindexlist   triid   3   i   3   1   int   ind2   sbbindexlist   triid   3   i   6   1   int   ind3   sbbindexlist   triid   3   i   9   1  __ m128   v0   xformedpos   ind0  __ m128   v1   xformedpos   ind1  __ m128   v2   xformedpos   ind2  __ m128   v3   xformedpos   ind3  _ mm _ transpose4 _ ps   v0   v1   v2   v3   pout   i   x   v0   pout   i   y   v1   pout   i   z   v2   pout   i   w   v3   now   x   contains   x0   x1   x2   x3   y   y0   y1   y2   y3   and   so   on   bool   rasterizetestbboxsse   box3f   box  __ m128   matrix   float   buffer   point4i   res   verts   and   flags  __ m128   verticessse   8   int   flags   8   static   point4f   vertices   8   static   point4f   xformedpos   3   static   int   flagsloc   3   set   daz   and   fz   mxcsr   bits   to   flush   denormals   to   zero   i   e   make   it   faster   denormal   are   zero   daz   is   bit   6   and   flush   to   zero   fz   is   bit   15   so   to   enable   the   two   to   have   to   set   bits   6   and   15   which   1000   0000   0100   0000   0x8040  _ mm _ setcsr  _ mm _ getcsr   0x8040   init   vertices   point3f   center   box   getcenter   point3f   extent   box   getextents   point4f   vcenter   point4f   center   x   center   y   center   z   1   0   point4f   vhalf   point4f   extent   x   0   5   extent   y   0   5   extent   z   0   5   1   0   point4f   vmin   vcenter   vhalf   point4f   vmax   vcenter   vhalf   fill   vertices   vertices   0   point4f   vmin   x   vmin   y   vmin   z   1   vertices   1   point4f   vmax   x   vmin   y   vmin   z   1   vertices   2   point4f   vmax   x   vmax   y   vmin   z   1   vertices   3   point4f   vmin   x   vmax   y   vmin   z   1   vertices   4   point4f   vmin   x   vmin   y   vmax   z   1   vertices   5   point4f   vmax   x   vmin   y   vmax   z   1   vertices   6   point4f   vmax   x   vmax   y   vmax   z   1   vertices   7   point4f   vmin   x   vmax   y   vmax   z   1   transforms   for   int   i   0   i   8   i   verticessse   i  _ mm _ loadu _ ps   vertices   i   verticessse   i   ssetransformcoords   verticessse   i   matrix  __ m128   vertx  _ mm _ shuffle _ ps   verticessse   i   verticessse   i  _ mm _ shuffle   0   0   0   0   xxxx  __ m128   verty  _ mm _ shuffle _ ps   verticessse   i   verticessse   i  _ mm _ shuffle   1   1   1   1   yyyy  __ m128   vertz  _ mm _ shuffle _ ps   verticessse   i   verticessse   i  _ mm _ shuffle   2   2   2   2   zzzz  __ m128   vertw  _ mm _ shuffle _ ps   verticessse   i   verticessse   i  _ mm _ shuffle   3   3   3   3   wwww   static   const  __ m128   sign _ mask  _ mm _ set1 _ ps   0   f   0   f   1   31   vertw  _ mm _ andnot _ ps   sign _ mask   vertw   abs   vertw  _ mm _ shuffle _ ps   vertw  _ mm _ set1 _ ps   1   0f  _ mm _ shuffle   0   0   0   0   w   w   1   1   vertw  _ mm _ shuffle _ ps   vertw   vertw  _ mm _ shuffle   3   0   0   0   w   w   w   1   project   verticessse   i  _ mm _ div _ ps   verticessse   i   vertw   now   vertices   are   between   1   and   1   const  __ m128   sadd  _ mm _ setr _ ps   res   x   0   5   res   y   0   5   0   0   const  __ m128   smult  _ mm _ setr _ ps   res   x   0   5   res   y   0   5   1   1   verticessse   i  _ mm _ add _ ps   sadd  _ mm _ mul _ ps   verticessse   i   smult   rasterize   the   aabb   triangles   4   at   a   time   for   int   i   0   i   12   i   4   ssevfloat4   xformedpos   3   ssegather   xformedpos   i   verticessse   by   3   vertices   fxptx   0   x0   x1   x2   x3   of   1st   vert   in   4   triangles   fxptx   1   x0   x1   x2   x3   of   2nd   vert   in   4   triangles   and   so   on  __ m128i   fxptx   3   fxpty   3   for   int   m   0   m   3   m   fxptx   m  _ mm _ cvtps _ epi32   xformedpos   m   x   fxpty   m  _ mm _ cvtps _ epi32   xformedpos   m   y   fab   x   y   ax   by   c   0   fab   x   y   ya   yb   x   xb   xa   y   xa   yb   xb   ya   0   compute   a   ya   yb   for   the   3   line   segments   that   make   up   each   triangle  __ m128i   a0  _ mm _ sub _ epi32   fxpty   1   fxpty   2  __ m128i   a1  _ mm _ sub _ epi32   fxpty   2   fxpty   0  __ m128i   a2  _ mm _ sub _ epi32   fxpty   0   fxpty   1   compute   b   xb   xa   for   the   3   line   segments   that   make   up   each   triangle  __ m128i   b0  _ mm _ sub _ epi32   fxptx   2   fxptx   1  __ m128i   b1  _ mm _ sub _ epi32   fxptx   0   fxptx   2  __ m128i   b2  _ mm _ sub _ epi32   fxptx   1   fxptx   0   compute   c   xa   yb   xb   ya   for   the   3   line   segments   that   make   up   each   triangle  __ m128i   c0  _ mm _ sub _ epi32  _ mm _ mullo _ epi32   fxptx   1   fxpty   2  _ mm _ mullo _ epi32   fxptx   2   fxpty   1  __ m128i   c1  _ mm _ sub _ epi32  _ mm _ mullo _ epi32   fxptx   2   fxpty   0  _ mm _ mullo _ epi32   fxptx   0   fxpty   2  __ m128i   c2  _ mm _ sub _ epi32  _ mm _ mullo _ epi32   fxptx   0   fxpty   1  _ mm _ mullo _ epi32   fxptx   1   fxpty   0   compute   triangle   area  __ m128i   triarea  _ mm _ mullo _ epi32   b2   a1   triarea  _ mm _ sub _ epi32   triarea  _ mm _ mullo _ epi32   b1   a2  __ m128   oneovertriarea  _ mm _ div _ ps  _ mm _ set1 _ ps   1   0f  _ mm _ cvtepi32 _ ps   triarea  __ m128   z   3   z   0   xformedpos   0   w   z   1  _ mm _ mul _ ps  _ mm _ sub _ ps   xformedpos   1   w   z   0   oneovertriarea   z   2  _ mm _ mul _ ps  _ mm _ sub _ ps   xformedpos   2   w   z   0   oneovertriarea   use   bounding   box   traversal   strategy   to   determine   which   pixels   to   rasterize  __ m128i   startx  _ mm _ and _ si128   max   min   min   fxptx   0   fxptx   1   fxptx   2  _ mm _ set1 _ epi32   0  _ mm _ set1 _ epi32   1  __ m128i   endx   min   max   max   fxptx   0   fxptx   1   fxptx   2  _ mm _ set1 _ epi32   res   x   1  __ m128i   starty  _ mm _ and _ si128   max   min   min   fxpty   0   fxpty   1   fxpty   2  _ mm _ set1 _ epi32   0  _ mm _ set1 _ epi32   1  __ m128i   endy   min   max   max   fxpty   0   fxpty   1   fxpty   2  _ mm _ set1 _ epi32   res   y   1   now   we   have   4   triangles   set   up   rasterize   them   each   individually   for   int   lane   0   lane   4   lane   skip   triangle   if   area   is   zero   if   triarea   m128i _ i32   lane   0   continue   extract   this   triangle   s   properties   from   the   simd   versions  __ m128   zz   3   for   int   vv   0   vv   3   vv   zz   vv  _ mm _ set1 _ ps   z   vv   m128 _ f32   lane   drop   culled   triangle   int   startxx   startx   m128i _ i32   lane   int   endxx   endx   m128i _ i32   lane   int   startyy   starty   m128i _ i32   lane   int   endyy   endy   m128i _ i32   lane  __ m128i   aa0  _ mm _ set1 _ epi32   a0   m128i _ i32   lane  __ m128i   aa1  _ mm _ set1 _ epi32   a1   m128i _ i32   lane  __ m128i   aa2  _ mm _ set1 _ epi32   a2   m128i _ i32   lane  __ m128i   bb0  _ mm _ set1 _ epi32   b0   m128i _ i32   lane  __ m128i   bb1  _ mm _ set1 _ epi32   b1   m128i _ i32   lane  __ m128i   bb2  _ mm _ set1 _ epi32   b2   m128i _ i32   lane  __ m128i   cc0  _ mm _ set1 _ epi32   c0   m128i _ i32   lane  __ m128i   cc1  _ mm _ set1 _ epi32   c1   m128i _ i32   lane  __ m128i   cc2  _ mm _ set1 _ epi32   c2   m128i _ i32   lane  __ m128i   aa0inc  _ mm _ mul _ epi32   aa0  _ mm _ setr _ epi32   1   2   3   4  __ m128i   aa1inc  _ mm _ mul _ epi32   aa1  _ mm _ setr _ epi32   1   2   3   4  __ m128i   aa2inc  _ mm _ mul _ epi32   aa2  _ mm _ setr _ epi32   1   2   3   4  __ m128i   alpha0  _ mm _ add _ epi32  _ mm _ mul _ epi32   aa0  _ mm _ set1 _ epi32   startxx  _ mm _ mul _ epi32   bb0  _ mm _ set1 _ epi32   startyy   alpha0  _ mm _ add _ epi32   cc0   alpha0  __ m128i   beta0  _ mm _ add _ epi32  _ mm _ mul _ epi32   aa1  _ mm _ set1 _ epi32   startxx  _ mm _ mul _ epi32   bb1  _ mm _ set1 _ epi32   startyy   beta0  _ mm _ add _ epi32   cc1   beta0  __ m128i   gama0  _ mm _ add _ epi32  _ mm _ mul _ epi32   aa2  _ mm _ set1 _ epi32   startxx  _ mm _ mul _ epi32   bb2  _ mm _ set1 _ epi32   startyy   gama0  _ mm _ add _ epi32   cc2   gama0   int   rowidx   startyy   res   x   startxx  __ m128   zx  _ mm _ mul _ ps  _ mm _ cvtepi32 _ ps   aa1   zz   1   zx  _ mm _ add _ ps   zx  _ mm _ mul _ ps  _ mm _ cvtepi32 _ ps   aa2   zz   2   zx  _ mm _ mul _ ps   zx  _ mm _ setr _ ps   1   f   2   f   3   f   4   f   texels   traverse   for   int   r   startyy   r   endyy   r   rowidx   res   x   alpha0  _ mm _ add _ epi32   alpha0   bb0   beta0  _ mm _ add _ epi32   beta0   bb1   gama0  _ mm _ add _ epi32   gama0   bb2   compute   barycentric   coordinates   z0   as   an   origin   int   index   rowidx  __ m128i   alpha   alpha0  __ m128i   beta   beta0  __ m128i   gama   gama0   compute   barycentric   interpolated   depth  __ m128   depth   zz   0   depth  _ mm _ add _ ps   depth  _ mm _ mul _ ps  _ mm _ cvtepi32 _ ps   beta   zz   1   depth  _ mm _ add _ ps   depth  _ mm _ mul _ ps  _ mm _ cvtepi32 _ ps   gama   zz   2  __ m128i   anyout  _ mm _ setzero _ si128  __ m128i   mask  __ m128   previousdepth  __ m128   depthmask  __ m128i   finalmask   for   int   c   startxx   c   endxx   c   4   index   4   alpha  _ mm _ add _ epi32   alpha   aa0inc   beta  _ mm _ add _ epi32   beta   aa1inc   gama  _ mm _ add _ epi32   gama   aa2inc   depth  _ mm _ add _ ps   depth   zx   mask  _ mm _ or _ si128  _ mm _ or _ si128   alpha   beta   gama   previousdepth  _ mm _ loadu _ ps   buffer   index   calculate   current   depth   log   depth   6   907755375   0   048254941  __ m128   curdepth  _ mm _ mul _ ps  _ mm _ sub _ ps   log _ ps   depth  _ mm _ set1 _ ps   6   907755375  _ mm _ set1 _ ps   0   048254941   curdepth  _ mm _ sub _ ps   curdepth  _ mm _ set1 _ ps   0   05   depthmask  _ mm _ cmplt _ ps   curdepth   previousdepth   finalmask  _ mm _ andnot _ si128   mask  _ mm _ castps _ si128   depthmask   anyout  _ mm _ or _ si128   anyout   finalmask   for   each   column   if  _ mm _ testz _ si128   anyout  _ mm _ set1 _ epi32   0x80000000   stop   timer   queryperformancecounter   t2   compute   and   print   the   elapsed   time   in   millisec   elapsedtime   t2   quadpart   t1   quadpart   1000   0   frequency   quadpart   rasterizationstats   rasterizessetimespent   elapsedtime   return   true   early   exit   for   each   row   for   each   triangle   for   each   set   of   simd   triangles   return   false   собственно   все   технология   coverage   buffer   в   общий   черта   готовый   в   процесс   имплементация   правда   вскрываться   еще   ряд   другой   сложность   и   баг   связывать   с   рендер   лес   на   борьба   с   который   уходить   в   20   раз   много   время   чем   на   сам   c   buffer   но   борьба   с   они   не   входить   в   тема   данный   пост   результат   использование   технология   c   buffer   для   интеллектуальный   oc   для   рендеринг   лес   позволять   уменьшать   время   рендер   кадр   на   открытый   пространство   от   5   до   20мс   а   в   закрывать   до   30мс   в   случай   когда   отсекаться   весь   растительность   однако   давать   оверхед   в   1   5   2мс   при   неэффективный   отсечение   т   е   технология   использовать   но   ничто   не   отсечься   резальт   можно   быть   наблюдать   в   проект   после   внимательный   тестирование   в   то   число   и   на   совместимость   с   архаичный   машина   думать   через   пара   неделя   coverage   buffer   cryengine   occlusion   culling   21   октябрь   2015   обновление   31   дека   2018   комментарий   23   убирать   реклама   контакт   сообщество   участник   каталог   сайт   категория   архив   новость   gamedev   ru   разработка   игра   2001   2019